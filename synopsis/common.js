/* 
! Двоичная система счисления.
  По сути, любое число можно расписать в виде суммы цифр, каждая из которых умножена на десять в определенной степени. В случае единиц, эта степень — нулевая
  Пример: 1573 = 3*10 0 + 7*10 1 + 5*10 2 + 1*10 3. Число, на степень которого умножаются цифры называется базой системы счисления. Для десятичной системы базой, логично, является десятка.
  Давайте найдем десятичный аналог двоичного числа 1011012:
    1011012 = 1*2 0 + 0*2 1 + 1*2 2 + 1*2 3 + 0*2 4 + 1*2 5 = 1 + 0 + 4 + 8 + 0 + 32 = 4510
    const bin = 1010100;

    function convertBinToDec(bin) {
      let dec = 0;
      let power = 0;
      while (bin > 0) {
        dec += (bin % 10) * Math.pow(2, power);
        bin = Math.floor(bin / 10);
        power++;
      }
      return dec;
    }

    convertBinToDec(bin);//?

  Перевод целых десятичных чисел в любую другую системы счисления осуществляется делением числа на основание новой системы счисления до тех пор, пока в остатке не останется число меньшее основания новой системы счис­ления. Новое число записывается в виде остатков деления, начиная с последнего.
  const dec = 84;

  function convertDecToBin(dec) {
    let bin = '';
    while (dec > 0) {
      bin = (dec % 2) + bin;
      dec = Math.floor(dec / 2);
    }
    return bin;
  }
  
  convertDecToBin(dec);//?

!Базовые структуры данных и их организация (массив, список, стек, очередь, дерево, хэш таблица и т. д.).
?Эффективность («О» большое): 
  О(1) константная сложность | означает, что данной операции требуется константное время. Например, за константное время выполняется поиск элемента в хэш-таблице, так как вы напрямую запрашиваете какой-то элемент, не делая никаких сравнений.
  O(log n) логарифмическая сложность | Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам.
  O(n) линейная сложность| Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.
  O(n log n) линейно-логарифмическая сложность | Пример алгоритма с линейно-логарифмической временной сложностью — сортировка слиянием.
  O(n2) — квадратичная сложность | Проще говоря, это линейная временная сложность в квадрате. Если, к примеру, в нашем наборе данных есть 2 элемента, за время работы алгоритма будет выполнено 4 операции. Если в наборе 4 элемента, то операций будет 16. При 6 элементах будет 36 операций, и так далее.
  O(n!) факториальную сложность | Хорошим примером алгоритма с факториальной временной сложностью может послужить простая рекурсивная функция. Эта функция принимает число в качестве входных данных и умножает его на факториал числа, меньшего на единицу.
?Массив:
  Упорядоченный набор элементов, к каждому из которых можно обратиться по его индексу (порядковому номеру в массиве).
    Оптимален для индексирования (получения элемента массива через его номер). 
    Плох для поиска, вставки и удаления, если не делать этого в самом конце массива.
      *-Индексирование: O(1).
      *-Поиск: O(n).
      *-Двоичный поиск: O(log n).
      *-Вставка: недопустимо (если не делать этого в самом конце массива).
?Список (связный список):
  Данные хранятся в узлах, указывающих на другие узлы. По итогу список выглядит, как вложенные друг в друга объекты.
  У каждого узла есть value (значение этого элемента(узла)) и nextNode (ссылка на следующий элемент связного списка).
    Оптимален для вставки и удаления (т.к. надо просто "перекинуть" указатель с определенного элемента на следующий).
    Плох для индексирования и поиска (сложно получить элемент по его номеру или просто найти элемент из-за вложенности).
?Стек
  Обычно реализуется с помощью связного списка, может быть создан и из массива
  Обычно реализуется с помощью связного списка, может быть создан и из массива
  Стеки — это LIFO-структуры данных (last in, first out).
  Аналог стека — стопка тарелок: последнюю добавленную в стопку тарелку возьмут первой.
  Голова – единственное место для вставки и удаления элементов.
?Очереди
  Как и стек очереди могут быть реализованы с помощью связного списка или массива
  Очереди — это FIFO-структуры данных (first in, first out).
  Аналог очереди - очередь в магазине: первого покупателя обслужат первым
  Элементы удаляются из головы, а добавляются в хвост.
    Эффективность списка, стека, очереди («О» большое):
      *Индексирование: O(n).
      *Поиск: O(n).
      *Двоичный поиск: O(n).
      *Вставка: O(1).
?Хэш-таблица (объект)
  Данные хранятся в виде пар ключ-значение.
    Оптимальны для поиска, вставки и удаления.
    Эффективность («О» большое):
      *Индексирование: O(1).
      *Поиск: O(1).
      *Вставка: O(1).
?Двоичное дерево
  Двоичное дерево — структура данных, в которой каждый узел имеет максимум два дочерних элемента. Дочерние элементы бывают левым и правым. Ключ левого дочернего узла меньше, чем у родительского. Ключ правого дочернего узла больше, чем у родительского.
    Оптимальны для сортировки и поиска.
      Эффективность («О» большое):
        *Индексирование: O(log n).
        *Поиск: O(log n).
        *Вставка: O(log n).
! Базовые алгоритмы сортировки и поиска.
  Алгоритмы сортировки упорядочивают элементы по определённому критерию. 
  








































*/