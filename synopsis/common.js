/* 
! Двоичная система счисления.
  По сути, любое число можно расписать в виде суммы цифр, каждая из которых умножена на десять в определенной степени. В случае единиц, эта степень — нулевая
  Пример: 1573 = 3*10 0 + 7*10 1 + 5*10 2 + 1*10 3. Число, на степень которого умножаются цифры называется базой системы счисления. Для десятичной системы базой, логично, является десятка.
  Давайте найдем десятичный аналог двоичного числа 1011012:
    1011012 = 1*2 0 + 0*2 1 + 1*2 2 + 1*2 3 + 0*2 4 + 1*2 5 = 1 + 0 + 4 + 8 + 0 + 32 = 4510
    const bin = 1010100;

    function convertBinToDec(bin) {
      let dec = 0;
      let power = 0;
      while (bin > 0) {
        dec += (bin % 10) * Math.pow(2, power);
        bin = Math.floor(bin / 10);
        power++;
      }
      return dec;
    }

    convertBinToDec(bin);//?

  Перевод целых десятичных чисел в любую другую системы счисления осуществляется делением числа на основание новой системы счисления до тех пор, пока в остатке не останется число меньшее основания новой системы счис­ления. Новое число записывается в виде остатков деления, начиная с последнего.
  const dec = 84;

  function convertDecToBin(dec) {
    let bin = '';
    while (dec > 0) {
      bin = (dec % 2) + bin;
      dec = Math.floor(dec / 2);
    }
    return bin;
  }
  
  convertDecToBin(dec);//?

!Базовые структуры данных и их организация (массив, список, стек, очередь, дерево, хэш таблица и т. д.).
?Эффективность («О» большое): 
  О(1) константная сложность | означает, что данной операции требуется константное время. Например, за константное время выполняется поиск элемента в хэш-таблице, так как вы напрямую запрашиваете какой-то элемент, не делая никаких сравнений.
  O(log n) логарифмическая сложность | Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам.
  O(n) линейная сложность| Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.
  O(n log n) линейно-логарифмическая сложность | Пример алгоритма с линейно-логарифмической временной сложностью — сортировка слиянием.
  O(n2) — квадратичная сложность | Проще говоря, это линейная временная сложность в квадрате. Если, к примеру, в нашем наборе данных есть 2 элемента, за время работы алгоритма будет выполнено 4 операции. Если в наборе 4 элемента, то операций будет 16. При 6 элементах будет 36 операций, и так далее.
  O(n!) факториальную сложность | Хорошим примером алгоритма с факториальной временной сложностью может послужить простая рекурсивная функция. Эта функция принимает число в качестве входных данных и умножает его на факториал числа, меньшего на единицу.
?Массив:
  Упорядоченный набор элементов, к каждому из которых можно обратиться по его индексу (порядковому номеру в массиве).
    Оптимален для индексирования (получения элемента массива через его номер). 
    Плох для поиска, вставки и удаления, если не делать этого в самом конце массива.
      *-Индексирование: O(1).
      *-Поиск: O(n).
      *-Двоичный поиск: O(log n).
      *-Вставка: недопустимо (если не делать этого в самом конце массива).
?Список (связный список):
  Данные хранятся в узлах, указывающих на другие узлы. По итогу список выглядит, как вложенные друг в друга объекты.
  У каждого узла есть value (значение этого элемента(узла)) и nextNode (ссылка на следующий элемент связного списка).
    Оптимален для вставки и удаления (т.к. надо просто "перекинуть" указатель с определенного элемента на следующий).
    Плох для индексирования и поиска (сложно получить элемент по его номеру или просто найти элемент из-за вложенности).
?Стек
  Обычно реализуется с помощью связного списка, может быть создан и из массива
  Обычно реализуется с помощью связного списка, может быть создан и из массива
  Стеки — это LIFO-структуры данных (last in, first out).
  Аналог стека — стопка тарелок: последнюю добавленную в стопку тарелку возьмут первой.
  Голова – единственное место для вставки и удаления элементов.
?Очереди
  Как и стек очереди могут быть реализованы с помощью связного списка или массива
  Очереди — это FIFO-структуры данных (first in, first out).
  Аналог очереди - очередь в магазине: первого покупателя обслужат первым
  Элементы удаляются из головы, а добавляются в хвост.
    Эффективность списка, стека, очереди («О» большое):
      *Индексирование: O(n).
      *Поиск: O(n).
      *Двоичный поиск: O(n).
      *Вставка: O(1).
?Хэш-таблица (объект)
  Данные хранятся в виде пар ключ-значение.
    Оптимальны для поиска, вставки и удаления.
    Эффективность («О» большое):
      *Индексирование: O(1).
      *Поиск: O(1).
      *Вставка: O(1).
?Двоичное дерево
  Двоичное дерево — структура данных, в которой каждый узел имеет максимум два дочерних элемента. Дочерние элементы бывают левым и правым. Ключ левого дочернего узла меньше, чем у родительского. Ключ правого дочернего узла больше, чем у родительского.
    Оптимальны для сортировки и поиска.
      Эффективность («О» большое):
        *Индексирование: O(log n).
        *Поиск: O(log n).
        *Вставка: O(log n).

! Базовые алгоритмы сортировки
  Алгоритмы сортировки упорядочивают элементы по определённому критерию. 
  ?Bubble sort
    Принцип действий прост, но эффективен он лишь для небольших массивов. Алгоритм считается учебным.
    В то же время метод сортировки обменами лежит в основе некоторых более совершенных алгоритмов, таких как сортировка перемешиванием, пирамидальная сортировка и быстрая сортировка.
    Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент.
    Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. 
      *Наилучший вариант: O(n).
      *Средний и худший варианты: O(n²).
  function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - 1 - i; j++) {
        if (arr[j + 1] < arr[j]) {
          let t = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = t;
        }
      }
    }
    return arr;
  }
  bubbleSort(arr);
  ? merge sort
    Это один из фундаментальных алгоритмов сортировки.
    Весь набор данных делится минимум на две группы. Пары значений сравниваются между собой, наименьшее перемещается влево. После сортировки внутри всех пар, сравниваются левые значения двух левых пар. 
      Таким образом, создаётся группа из четырёх значений: два наименьшие — слева, наибольшие — справа. Процесс повторяется до тех пор, пока не останется только один набор.
        *Наилучший вариант: O(n).
        *Средний и худший варианты: O(n log n).
  function merge(left, right) {
    let arr = []
    // Break out of loop if any one of the array gets empty
    while (left.length && right.length) {
      // Pick the smaller among the smallest element of left and right sub arrays 
      if (left[0] < right[0]) {
        arr.push(left.shift())
      } else {
        arr.push(right.shift())
      }
    }
    // Concatenating the leftover elements
    // (in case we didn't go through the entire left or right array)
    return [...arr, ...left, ...right]
  }
  function mergeSort(array) {
    const half = array.length / 2

    // Base case or terminating case
    if (array.length < 2) {
      return array
    }

    const left = array.splice(0, half)
    return merge(mergeSort(left), mergeSort(array))
  }
  ? quick sort
  Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем O(n log n) обменов при упорядочении n-элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.
  Алгоритм состоит из трёх шагов:
    1. Выбор опорного элемента из массива.
    2. Перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные — после.
    3. Рекурсивное применение первых двух шагов к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один или отсутствуют элементы.
      *Наилучший вариант: O(n).
      *Средний вариант: O(n log n).
      *Худший вариант: O(n²).
  function quickSort(arr) {
    if (arr.length == 0) return [];
    let a = [],
      b = [],
      p = arr[0];

    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < p) a.push(arr[i]);
      else b.push(arr[i]);
    }
    return quickSort(a).concat(p, quickSort(b));
  }
  quickSort(arr);

  ? Сравнение алгоритмов сортировки слиянием и быстрой сортировки
    Быстрая сортировка на практике зачастую эффективнее. Сортировка слиянием сразу делит набор данных на наименьшие возможные группы, 
      а затем восстанавливает набор, инкрементально сортируя и укрупняя группы. Быстрая сортировка последовательно делит набор по среднему значению, пока он не будет отсортирован рекурсивно.

?Реализация Javascript Array.sort 
  quick sort  WebKit (Chrome, Safari…) . В зависимости от типа массива используются разные методы сортировки:
    Числовые массивы (или массивы примитивного типа) сортируются с помощью функции стандартной библиотеки C++ которая реализует некоторые варианты быстрой сортировки
    Непрерывные массивы нечислового типа преобразуются в строки и сортируются с использованием сортировки слиянием, если она доступна
    Для других типов (несмежных массивов и предположительно для ассоциативных массивов) WebKit использует либо сортировку выбором (которую они называют «минимальной» сортировкой ), либо, в некоторых случаях, сортировку через дерево AVL.

! Базовые алгоритмы поиска
  ? Линейный поиск
  ? Бинарный поиск
  Данные должны быть отсортированы
    Для поиска значения вы сначала сравниваете значение со средним элементом списка. Если они равны, значение поиска найдено. Если значение поиска больше, чем средний элемент, выполняется поиск в верхней половине данных. 
    Затем вы сравниваете средний элемент этого раздела со значением поиска. В качестве альтернативы, если элемент меньше среднего элемента, вы ищете в нижней половине списка и сравниваете его среднее значение. 
    Список многократно делится пополам до тех пор, пока элемент не будет найден или не останется элементов для поиска.
      *Сложность алгоритма поиска O(log n)
function binarySearch (list, item) {
	let low = 0;
	let high = list.length - 1;

	while (low <= high) {
		let mid = Math.floor((low + high) / 2);
		let guess = list[mid];
		if (guess === item) {
			return mid;
		}
		if (guess > item) {
			high = mid - 1;
		}
		if (guess < item) {
			low = mid + 1;
		}
	}
	return null;
}
! basic OOP
  2 подхода в программировании:
  Процедурный подход:
    Программа, написанная в процедурном стиле, ожидает на вход какие-то данные. => Выполняет ряд процедур(Они же функции.) => Возвращает результат.
    Изначально все программы писались с процедурном подходе. Но когда программы стали большими, стало понятно, что это не подходит.
    Сложно конфигурировать приложения управлять сущностями И сложно делать декомпозицию.
  Объектно-ориентированный подход:
    С момента своего появления, Объектно ориентированное программирование (ООП) было и остается одной из самых популярных парадигм, которая позволяет писать модульный расширяемый код с использованием хорошо зарекомендовавших себя практик.
    ООП включает в себя принципы, которые позволяют сократить дублирование кода до минимума, а так же более четко выявлять составные логические части программы, ограничивая области потенциальной ошибки.
    Четкая логическая структура программы в свою очередь позволяет выявлять наиболее удачные варианты построения программы в "паттерны проектирования" которые по факту являются общепринятыми лучшими практиками программирования, способные помочь в построении программ любой сложности.
    2 основных понятия парадигме ООП:
      *-Классы: Это некоторое описание характеристик.
      *-Объект: конкретный экземпляр У которого каждая характеристика имеет конкретное значение.
      В контексте ООП характеристики - свойства, а действия - методы.
      */ 
      class rectangle {  //? Класс
        constructor(width, height) {
          this.width = width;
          this.height = height;
        }
        calcArea() {
          return this.width * this.height;
        }
      }
      const rect = new rectangle(10, 20); //? Объект
      rect.calcArea(); //? Действие 
      /*
      Из любого класса мы можем создать столько объектов, сколько нам потребуется. Хороший практика является делать классы под конкретные задачи.
    ООП построенно на 3 основных концепциях.
    *-Инкапсуляция
    *-Наследование
    *-Полиморфизм
    ?Инкапсуляция - Тесно соприкасается с таким понятием, как сокрытие.
      Суть инкапсуляции в том, что сам класс является Своего рода капсулой. Которая содержит свойства и методы для работы с этими свойствами. То есть, позволяет нам их объединить.
      Сокрытие же эта та часть, которая находится внутри и на которую мы снаружи повлиять не можем.
      И чтобы делать какие то свойства публичными или приватными, существуют модификаторы доступа. Ими помечаются свойства и методы. Приватные используется только внутри класса. Вызвать их извне невозможно.
      class rectangle {
        private _width; //? _ В js и ts cоглашение, которые указывают, что свойства приватное.
        private _height; //? Чаще всего все свойства делают приватными.
        constructor(width, height) {
          this._width = width;
          this._height = height;
        }
        public get width() { //? public По умолчанию, но хороший тон указывает его явно.
          return this._width;
        }
        public set width(value) {//? Делаем проверку any
          if (value <= 0) {
            this._width = 1;
          } else {
            this._width = value;
          }
        }
        get area() { //? А для доступа к ним используются get и set.
          return this._width * this.height;
        }
        //? В данном случае у нас высота является приватной, так как мы не задали для нее get и set.
        //? И работать мы с ней сможем только изнутри этого класса.
      }
    ?Наследование
      


































*/