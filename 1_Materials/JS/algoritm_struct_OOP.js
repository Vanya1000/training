/* 
! Двоичная система счисления.
  По сути, любое число можно расписать в виде суммы цифр, каждая из которых умножена на десять в определенной степени. В случае единиц, эта степень — нулевая
  Пример: 1573 = 3*10 0 + 7*10 1 + 5*10 2 + 1*10 3. Число, на степень которого умножаются цифры называется базой системы счисления. Для десятичной системы базой, логично, является десятка.
  Давайте найдем десятичный аналог двоичного числа 1011012:
    1011012 = 1*2 0 + 0*2 1 + 1*2 2 + 1*2 3 + 0*2 4 + 1*2 5 = 1 + 0 + 4 + 8 + 0 + 32 = 4510
    const bin = 1010100;

    function convertBinToDec(bin) {
      let dec = 0;
      let power = 0;
      while (bin > 0) {
        dec += (bin % 10) * Math.pow(2, power);
        bin = Math.floor(bin / 10);
        power++;
      }
      return dec;
    }

    convertBinToDec(bin);//?

  Перевод целых десятичных чисел в любую другую системы счисления осуществляется делением числа на основание новой системы счисления до тех пор, пока в остатке не останется число меньшее основания новой системы счис­ления. Новое число записывается в виде остатков деления, начиная с последнего.
  const dec = 84;

  function convertDecToBin(dec) {
    let bin = '';
    while (dec > 0) {
      bin = (dec % 2) + bin;
      dec = Math.floor(dec / 2);
    }
    return bin;
  }
  
  convertDecToBin(dec);//?

!Базовые структуры данных и их организация (массив, список, стек, очередь, дерево, хэш таблица и т. д.).
?Эффективность («О» большое): 
  О(1) константная сложность | означает, что данной операции требуется константное время. Например, за константное время выполняется поиск элемента в хэш-таблице, так как вы напрямую запрашиваете какой-то элемент, не делая никаких сравнений.
  O(log n) логарифмическая сложность | Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам.
  O(n) линейная сложность| Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.
  O(n log n) линейно-логарифмическая сложность | Пример алгоритма с линейно-логарифмической временной сложностью — сортировка слиянием.
  O(n2) — квадратичная сложность | Проще говоря, это линейная временная сложность в квадрате. Если, к примеру, в нашем наборе данных есть 2 элемента, за время работы алгоритма будет выполнено 4 операции. Если в наборе 4 элемента, то операций будет 16. При 6 элементах будет 36 операций, и так далее.
  O(n!) факториальную сложность | Хорошим примером алгоритма с факториальной временной сложностью может послужить простая рекурсивная функция. Эта функция принимает число в качестве входных данных и умножает его на факториал числа, меньшего на единицу.
?Массив:
  Упорядоченный набор элементов, к каждому из которых можно обратиться по его индексу (порядковому номеру в массиве).
    Оптимален для индексирования (получения элемента массива через его номер). 
    Плох для поиска, вставки и удаления, если не делать этого в самом конце массива.
      *-Индексирование: O(1).
      *-Поиск: O(n).
      *-Двоичный поиск: O(log n).
      *-Вставка: недопустимо (если не делать этого в самом конце массива).
?Список (связный список):
  Данные хранятся в узлах, указывающих на другие узлы. По итогу список выглядит, как вложенные друг в друга объекты.
  У каждого узла есть value (значение этого элемента(узла)) и nextNode (ссылка на следующий элемент связного списка).
    Оптимален для вставки и удаления (т.к. надо просто "перекинуть" указатель с определенного элемента на следующий).
    Плох для индексирования и поиска (сложно получить элемент по его номеру или просто найти элемент из-за вложенности).
?Стек
  Обычно реализуется с помощью связного списка, может быть создан и из массива
  Стеки — это LIFO-структуры данных (last in, first out).
  Аналог стека — стопка тарелок: последнюю добавленную в стопку тарелку возьмут первой.
  Голова – единственное место для вставки и удаления элементов.
?Очереди
  Как и стек очереди могут быть реализованы с помощью связного списка или массива
  Очереди — это FIFO-структуры данных (first in, first out).
  Аналог очереди - очередь в магазине: первого покупателя обслужат первым
  Элементы удаляются из головы, а добавляются в хвост.
    Эффективность списка, стека, очереди («О» большое):
      *Индексирование: O(n).
      *Поиск: O(n).
      *Двоичный поиск: O(n).
      *Вставка: O(1).
?Хэш-таблица (объект)
  Данные хранятся в виде пар ключ-значение.
    Оптимальны для поиска, вставки и удаления.
    Эффективность («О» большое):
      *Индексирование: O(1).
      *Поиск: O(1).
      *Вставка: O(1).
?Двоичное дерево
  Двоичное дерево — структура данных, в которой каждый узел имеет максимум два дочерних элемента. Дочерние элементы бывают левым и правым. Ключ левого дочернего узла меньше, чем у родительского. Ключ правого дочернего узла больше, чем у родительского.
    Оптимальны для сортировки и поиска.
      Эффективность («О» большое):
        *Индексирование: O(log n).
        *Поиск: O(log n).
        *Вставка: O(log n).

! Базовые алгоритмы сортировки
  Алгоритмы сортировки упорядочивают элементы по определённому критерию. 
  ?Bubble sort
    Принцип действий прост, но эффективен он лишь для небольших массивов. Алгоритм считается учебным.
    В то же время метод сортировки обменами лежит в основе некоторых более совершенных алгоритмов, таких как сортировка перемешиванием, пирамидальная сортировка и быстрая сортировка.
    Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент.
    Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. 
      *Наилучший вариант: O(n).
      *Средний и худший варианты: O(n²).
  function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - 1 - i; j++) {
        if (arr[j + 1] < arr[j]) {
          let t = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = t;
        }
      }
    }
    return arr;
  }
  bubbleSort(arr);
  ? merge sort
    Это один из фундаментальных алгоритмов сортировки.
    Весь набор данных делится минимум на две группы. Пары значений сравниваются между собой, наименьшее перемещается влево. После сортировки внутри всех пар, сравниваются левые значения двух левых пар. 
      Таким образом, создаётся группа из четырёх значений: два наименьшие — слева, наибольшие — справа. Процесс повторяется до тех пор, пока не останется только один набор.
        *Наилучший вариант: O(n).
        *Средний и худший варианты: O(n log n).
  function merge(left, right) {
    let arr = []
    // Break out of loop if any one of the array gets empty
    while (left.length && right.length) {
      // Pick the smaller among the smallest element of left and right sub arrays 
      if (left[0] < right[0]) {
        arr.push(left.shift())
      } else {
        arr.push(right.shift())
      }
    }
    // Concatenating the leftover elements
    // (in case we didn't go through the entire left or right array)
    return [...arr, ...left, ...right]
  }
  function mergeSort(array) {
    const half = array.length / 2

    // Base case or terminating case
    if (array.length < 2) {
      return array
    }

    const left = array.splice(0, half)
    return merge(mergeSort(left), mergeSort(array))
  }
  ? quick sort
  Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем O(n log n) обменов при упорядочении n-элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.
  Алгоритм состоит из трёх шагов:
    1. Выбор опорного элемента из массива.
    2. Перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные — после.
    3. Рекурсивное применение первых двух шагов к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один или отсутствуют элементы.
      *Наилучший вариант: O(n).
      *Средний вариант: O(n log n).
      *Худший вариант: O(n²).
  function quickSort(arr) {
    if (arr.length == 0) return [];
    let a = [],
      b = [],
      p = arr[0];

    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < p) a.push(arr[i]);
      else b.push(arr[i]);
    }
    return quickSort(a).concat(p, quickSort(b));
  }
  quickSort(arr);

  ? Сравнение алгоритмов сортировки слиянием и быстрой сортировки
    Быстрая сортировка на практике зачастую эффективнее. Сортировка слиянием сразу делит набор данных на наименьшие возможные группы, 
      а затем восстанавливает набор, инкрементально сортируя и укрупняя группы. Быстрая сортировка последовательно делит набор по среднему значению, пока он не будет отсортирован рекурсивно.

?Реализация Javascript Array.sort 
  quick sort  WebKit (Chrome, Safari…) . В зависимости от типа массива используются разные методы сортировки:
    Числовые массивы (или массивы примитивного типа) сортируются с помощью функции стандартной библиотеки C++ которая реализует некоторые варианты быстрой сортировки
    Непрерывные массивы нечислового типа преобразуются в строки и сортируются с использованием сортировки слиянием, если она доступна
    Для других типов (несмежных массивов и предположительно для ассоциативных массивов) WebKit использует либо сортировку выбором (которую они называют «минимальной» сортировкой ), либо, в некоторых случаях, сортировку через дерево AVL.

! Базовые алгоритмы поиска
  ? Линейный поиск
  ? Бинарный поиск
  Данные должны быть отсортированы
    Для поиска значения вы сначала сравниваете значение со средним элементом списка. Если они равны, значение поиска найдено. Если значение поиска больше, чем средний элемент, выполняется поиск в верхней половине данных. 
    Затем вы сравниваете средний элемент этого раздела со значением поиска. В качестве альтернативы, если элемент меньше среднего элемента, вы ищете в нижней половине списка и сравниваете его среднее значение. 
    Список многократно делится пополам до тех пор, пока элемент не будет найден или не останется элементов для поиска.
      *Сложность алгоритма поиска O(log n)
function binarySearch (list, item) {
	let low = 0;
	let high = list.length - 1;

	while (low <= high) {
		let mid = Math.floor((low + high) / 2);
		let guess = list[mid];
		if (guess === item) {
			return mid;
		}
		if (guess > item) {
			high = mid - 1;
		}
		if (guess < item) {
			low = mid + 1;
		}
	}
	return null;
}
! basic OOP
  2 подхода в программировании:
  Процедурный подход:
    Программа, написанная в процедурном стиле, ожидает на вход какие-то данные. => Выполняет ряд процедур(Они же функции.) => Возвращает результат.
    Изначально все программы писались с процедурном подходом. Но когда программы стали большими, стало понятно, что это не подходит.
    Сложно конфигурировать приложения управлять сущностями И сложно делать декомпозицию.
  Объектно-ориентированный подход:
    С момента своего появления, Объектно ориентированное программирование (ООП) было и остается одной из самых популярных парадигм, которая позволяет писать модульный расширяемый код с использованием хорошо зарекомендовавших себя практик.
    ООП включает в себя принципы, которые позволяют сократить дублирование кода до минимума, а так же более четко выявлять составные логические части программы, ограничивая области потенциальной ошибки.
    Четкая логическая структура программы в свою очередь позволяет выявлять наиболее удачные варианты построения программы в "паттерны проектирования" которые по факту являются общепринятыми лучшими практиками программирования, способные помочь в построении программ любой сложности.
    2 основных понятия парадигме ООП:
      *-Классы: Это некоторое описание характеристик.
      *-Объект: конкретный экземпляр У которого каждая характеристика имеет конкретное значение.
      В контексте ООП характеристики - свойства, а действия - методы.
      */ 
      class rectangle {  //? Класс
        constructor(width, height) {
          this.width = width;
          this.height = height;
        }
        calcArea() {
          return this.width * this.height;
        }
      }
      const rect = new rectangle(10, 20); //? Объект
      rect.calcArea(); //? Действие 
      /*
      Из любого класса мы можем создать столько объектов, сколько нам потребуется. Хороший практика является делать классы под конкретные задачи.
    ООП построенно на 3 основных концепциях.
    *-Инкапсуляция
    *-Наследование
    *-Полиморфизм
    ?Инкапсуляция - Тесно соприкасается с таким понятием, как сокрытие.
      Суть инкапсуляции в том, что сам класс является Своего рода капсулой. Которая содержит свойства и методы для работы с этими свойствами. То есть, позволяет нам их объединить.
      Сокрытие же эта та часть, которая находится внутри и на которую мы снаружи повлиять не можем.
      И чтобы делать какие то свойства публичными или приватными, существуют модификаторы доступа. Ими помечаются свойства и методы. Приватные используется только внутри класса. Вызвать их извне невозможно.
      class rectangle {
        private _width; //? _ В js и ts cоглашение, которые указывают, что свойства приватное.
        private _height; //? Чаще всего все свойства делают приватными.
        constructor(width, height) {
          this._width = width;
          this._height = height;
        }
        public get width() { //? public По умолчанию, но хороший тон указывает его явно.
          return this._width;
        }
        public set width(value) {//? Делаем проверку any
          if (value <= 0) {
            this._width = 1;
          } else {
            this._width = value;
          }
        }
        get area() { //? А для доступа к ним используются get и set.
          return this._width * this.height;
        }
        //? В данном случае у нас высота является приватной, так как мы не задали для нее get и set.
        //? И работать мы с ней сможем только изнутри этого класса.
      }
    ?Наследование
      Дублирование кода это плохо. В общем случае нужно стараться свести дублирование кода к минимуму и всегда придерживаться принципа Don't Repeat Yourself(DRY) - не повторяйтесь.
      Наследование - это принцип ООП, который позволяет сводить дублирование кода к минимуму. С его помощью при ПРАВИЛЬНО ПОСТРОЕННОЙ АБСТРАКЦИИ  можно переиспользовать методы и свойства объектов.
      Из биологии, это как раз возможность биологических организмов передавать признаки от родителей к детям.
      Например class employee расширяет class person(наследуя все свойства и методы), а class developer расширяет class person добавляя новые свойства и методы.
      Хорошо спроектированная система, опыт позволяет очень эффективно перенес пользовать код, масштабировать его и поддерживать.
      class Person {
        constructor(firstName, lastName, age) {
          this._firstName = firstName;
          this._lastName = lastName;
          this._age = age;
        }
      
        get firstName() {
          return this._firstName;
        }
        set firstName(value) {
          this._firstName = value;
        }
        get lastName() {
          return this._lastName;
        }
        set lastName(value) {
          this._lastName = value;
        }
        get age() {
          return this._age;
        }
        set age(value) {
          if (value < 0) {
            throw new Error('Age must be positive');
          } else {
            this._age = value;
          }
        }
      }

      class Employee extends Person {
        constructor(firstName, lastName, age, inn, number,snils) { //? Конструктор также по умолчанию наследуется.
          super(firstName, lastName, age);//? Просто ссылка на родительский конструктор. Он будет вызван в первую очередь.
          this.inn = inn;
          this.number = number;
          this.snils = snils;
        }
      
      }

      const employee = new Employee('Иван', 'Иванов', 30, '1234567890123', '1234567890123', '1234567890123');

      class Developer extends Employee {
        constructor(firstName, lastName, age, inn, number, snils, level, language) {
          super(firstName, lastName, age, inn, number, snils);
          this.level = level;
          this.language = language;
        }
      }

      const Developer = new developer('Иван', 'Иванов', 30, '1234567890123', '1234567890123', '1234567890123', 'junior', 'Java');
    ? Полиморфизм
      ```RSS Именно способность разных объектов выполнять одинаковые действия и называется полиморфизмом в программировании.
      ! Один интерфейс со множеством реализаций.
      ! Можем переопределють методы унаследованные от родителя. Либо создать абстрактный класс, который будет содержать методы, которые будут обязательными для всех дочерних классов, но их реализация будет разной.
        Инструменты полиморфизма:
          *наследование от классов
          *абстрактные классы
          *интерфейсы
          Когда мы наследуемся от какого-то класса или имплементируем какой-либо интерфейс - мы обязаны реализовать все его методы. Взамен мы получаем уверенность в том, что поведение программы не будет 
          меняться даже при том, что используются разные типы объектов. Это является одним из важнейших свойств которое используется во многих паттернах проектирования.
      ```
      В контексте ООП - Позволяет одному и тому же фрагменту кода работать разными типами данных. Один из самых важных принципов в ООП.
      Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.
      Чтобы это произошло полиморфизм использует наследование.
    Выделяют 2 основных типа полиморфизма. 
      *ad-hoc(является мнимым) полиморфизм - полиморфизм, который применяется к объектам, которые не имеют никакого предка.
        Это самый простой тип полиморфизма. Он связан с тем, что в зависимости от типов аргументов применяется разная реализация какой-то операции. Использовался при написании javascript.
        1 + 1; // 2
        'cat' + 'dog'; // catdog 

        class Calulator {// Один метод работает с 2 типами данных. Это происходит за счет перегрузки методов.
          add(a: Number, b: Number) {
            return a + b;
          }
          add(a: String, b: String) {
            return a + b;
          }
        }
        add(1, 2); // => 3
        add('a', 'b'); // => 'ab'
        Также считается привидением типов это когда явно дочерний класс преобразовываем к родительскому.
      *Параметрический(истинный)
        Задача: Реализовать функцию которая сможет принимать в себя неограниченное количество объектов унаследованных от Person
          Первое что приходит в голову, это написать функцию, которая принимает 3 аргумента. Массив объектов, созданных с person 2й массив созданных из разраб и 3й созд из просто работник. 
          По каждому из массивов проитерироваться. И у каждого объекта вызвать метод, который отвечает за приветствие. (Но это максимально глупо, так как у нас может быть очень глубокая вложенность объектов.)
          !Но
          class Person {
            constructor(firstName, lastName, age) {
              this._firstName = firstName;
              this._lastName = lastName;
              this._age = age;
            }
            greeting() {//! акцент на том кто он
              return `Hello, I am human and my name ${this._firstName}`;
            }
          }
          
          class Employee extends Person {
            constructor(firstName, lastName, age, inn, number,snils) { 
              super(firstName, lastName, age);
              this.inn = inn;
              this.number = number;
              this.snils = snils;
            }
            greeting() {//! акцент на том кто он
              return `Hello, I am employee and my name ${this._firstName}`;
            }
          }

          class Developer extends Employee {
            constructor(firstName, lastName, age, inn, number, snils, level, language) {
              super(firstName, lastName, age, inn, number, snils);
              this.level = level;
              this.language = language;
            }
            greeting() {//! акцент на том кто он
              return `Hello, I am developer and my name ${this._firstName}`;
            }
          }
          const person = new Person('Человек', 'Человекович', 30);
          const employee = new Employee('Джумар', 'Фаллович', 30, '1234567890123', '1234567890123', '1234567890123');
          const developer = new Developer('Иван', 'Иванов', 30, '1234567890123', '1234567890123', '1234567890123', 'junior', 'Java');
          
          const personList = [person, employee, developer]; //! массив объектов
          
          function massGreeting(person) {//! Интересуемся по массиву и для каждого объекта вызываем метод.
            for (let i = 0; i < personList.length; i++) { 
              console.log(personList[i].greeting());
            }
          }//! При этом никакие классы внутри функции не задействованы. Данное поведение называется полиморфизмом. Вне зависимости от типа объекта функции работает со всеми одинаково.
          |//! Много форм, но работаем со всеми ними одинаково.
          massGreeting(personList);//?
    До этого мы рассмотрели взаимодействие между классов в виде наследования. Но существуют и другие способы взаимодействия между классами.
    В объектно-ориентированных языках программирования существует три способа организации взаимодействия между классами.
      *Композиция:
        Есть класс автомобиль И он содержит другие объекты внутри себя, которые использует.
        И что характерно для композиции, двигатель и колеса не могут существовать отдельно от класса автомобиль.
        Они являются составными частями автомобилей, создаются внутри него.
      *Агрегация:
        Есть класс елочка который передается класс, автомобиль извне. Она может использоваться независимо в разных объектах.
        Она независимо от класса автомобиль и передается в него откуда-то извне. Через параметры конструктора. В этом и заключается основное отличие агрегации от композиции.
        class Freshener {
        
        }

        class Engine {
          drive() {
            return 'Enige works';
          }
        }

        class Wheel {
          drive() {
            return 'Wheels go';
          }
        }

        class Car {
          enige: Enige;
          wheel: Wheel[];
          freshener: Freshener;
        
          constructor(freshener) {//? Инициализируем освежитель извне Принимая параметрам конструктора. Он живет отдельной жизнью вне зависимости от класса car.
            //? Агрегация
            this.freshener = freshener();
            |//? Композиция. Самое важное здесь, что все эти объекты создаются внутри конструктора. А не создаются где то вне.
            this.engine = new Engine();
            this.wheels.push(new Wheel());
            this.wheels.push(new Wheel());
            this.wheels.push(new Wheel());
            this.wheels.push(new Wheel());
          }
          drive() {// Вызываем единственный метод, и внутри этого метода происходит некоторое из делегирование.
            this.engine.drive();
            for (let i = 0; i < this.wheels.length; i++) {
              this.wheels[i].drive();
            }
          }
        }

        const vw = newCar();
        vw.drive();
    Абстрактные классы и интерфейсы
      *interface:
        interface Client {//? Описаны некоторые методы. Но при этом нет реализации.  Это как оглавление в учебнике. Говорит, что нужно сделать, но не говорит как.
          connect(url: string): void;
          read(): void;
          write(data: string): void;
        }
        const client = new Client();// !!! Нельзя так!
      *Абстракция:
        Абстракция - Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации.
        Похожи на интерфейсы. В них также можно объявлять абстрактные методы. Которые будут аналогом методов в интерфейсе(не будет реализации).
        Но также можно создавать и обычное методы, с какой то реализацией с какой-то логикой.
        И класс, который наследуется от абстрактного, унаследует все обычные методы и также должен будет реализовать методы абстрактные.
          abstract class Client {// 
            connect(url: string): void {
              //Здесь логика
            }
          
            absract read(): string;
            abstract write(data: string): void;
          }
      Интерфейсы используются более часто. 
      Интерфейсы позволяют писать более гибкие код. Достигать более гибкого полиморфизма. И в целом систему необходимо проектировать на уровне интерфейсов.
        interface Read {
          read(url);
        }
        interface Write {
          write(data);
        }
        Есть класс, который имплементируют как reader, так и writer.

        class FileClient implements Read, Write { //Под имплементацию подразумевается, что класс должен реализовывать все методы, которые есть в интерфейсе.
          read(url) {// Наследоваться мы можем только от одного класса, а имплементировать можем неограниченное количество интерфейсов.
            //логика
          }
          write(data) {
            //логика
          }
        }
    

*/