/* 
!JavaScript:
    +Data types
      Динамическая типизация: JavaScript является слабо типизированным или динамическим языком. Это значит, что вам не нужно определять тип переменной заранее.
      Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов:
      Примитивы:
        -String строковый тип данных
        -Number числовой тип данных
        -BigInt number не может содержать числа больше, чем  9007199254740991 9 квадрильенов что бы создать значен типа BigInt добавляем n в конце лисла.
        -Boolean логический тип данных
        -Undefined переменная объявлена, но значение не присвоено
        -Null typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов; При попытке обратиться к объекту которого нет. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
        -Symbol используется для создания уникальных идентификаторов в объектах. В некоторых языках программирования символы также называются атомами.
      Object:
        Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;
        Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.
        JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами.
        Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
        Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt. Таким образом, они имеют разный набор методов.
        Все примитивы, кроме null и undefined, предоставляют множество полезных методов. 
      Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
        Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».
    +let var const - differences
      Существует 2 основных отличия var от let/const:
        1. Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
        2. «var» допускает повторное объявление переменной. let, будет ошибка
        3. «var» обрабатываются в начале запуска функции. Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того, 
          в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции). Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
          Объявления переменных «всплывают», но присваивания значений – нет. Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. 
      Переменные let:
        1. Видны только после объявления и только в текущем блоке.
        2. Нельзя переобъявлять (в том же блоке).
        3. При объявлении переменной в цикле for(let …) – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная let.
      Переменная const – это константа, в остальном – как let.
    ?ternary operator
      Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента. Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
    +switch case - examples, where it can be useful
      Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
      Конструкция «switch» может заменить несколько проверок if. При сравнении она использует оператор строгого равенства ===.
        1. Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
        2. Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
        3. Если ни один case не совпал – выполняется (если есть) вариант default.
      Несколько вариантов case, использующих один код, можно группировать.
           */
          let a2 = 2 + 2;
          switch (a2) {
            case 3:
              alert( 'Маловато' );
              break;
            case 4:
              alert( 'В точку!' );
              break;
            case 5:
              alert( 'Перебор' );
              break;
            default:
              alert( "Нет таких значений" );
          }
          /*
    +Loops
    ?for loop
    ?while loop
    ?do while loop
      Цикл «while»
      do {// тело цикла} while (condition); Цикл сначала выполнит тело, а затем проверит условие condition
      for начало let i = 0 | условие	i < 3 | тело	alert(i) | шаг	i++
      Прерывание цикла: «break»
        Код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а не передал -  прерывает. Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом
      Переход к следующей итерации: continue
        При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true). Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
      Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.
        
    +type conversions
      Строковое: Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
      Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
        undefiend => NaN
        null => 0
        true/false => 1/0
        string => Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
      Логическое: Происходит в математических операциях. Может быть вызвано с помощью Boolean(value).
        0, null, undefined, NaN, "", false, -0, 0n => false
        любое другое значение => true
      Автоматическое: математические операторы преобразуют знач к числам, кроме + если одно из слагаемых строка, то и все остальные приводятся к строкам ‘1’ + 2 // '12’

      +Strict comparison
        Операторы сравнения возвращают значения логического типа.
        Строки сравниваются посимвольно в лексикографическом порядке. Используется кодировка Unicode, а не настоящий алфавит
        Значения разных типов при сравнении приводятся к числу?? (null undefiend). Исключением является сравнение с помощью операторов строгого равенства/неравенства.
        Оператор строгого равенства === проверяет равенство без приведения типов. Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.
        Значения null и undefined равны == друг другу и не равны любому другому значению. Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===.
        Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.
      ?Object.is (optional)
      Все мы знаем что в js нет строгой типизации переменных и параметров , и из этого могут вытекать неприятные последствия. 
      Поэтому проверять два значения на равенства рекомендуется через оператор эквивалентности ===, который сравнивает два аргумента не только по значению , но и по типу.
        -console.log(+0 === -0); //true
        -console.log(NaN === NaN); //false
        -console.log(5 === '5');//false
      Как можно заметить и здесь не все гладко, в примерах где +0 === -0, NaN === NaN, нам вернулся не совсем тот результат который мы ожидали.
        -console.log(Object.is(+0 , -0)); //false
        -console.log(Object.is(NaN, NaN)); //true
        -console.log(Object.is(5 , '5'));//false
      Но появление этого метода не означает закат операторов сравнения (==) и (===), поэтому вы можете пользоваться и старыми операторами, только 
      помните что если корректность работы вашего кода зависит от особых случаев, то метод Object.is(), может стать для вас альтернативным решением.
      Поведение этого метода не аналогично оператору === (en-US). Оператор === (en-US) (также как и оператор == (en-US)) считает числовые значения -0 и +0 равными, а значение Number.NaN не равным самому себе.
      ?what is polyfills
        Полифил — это фрагмент кода, который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию.
        Из-за меньшей производительности и ограниченной функциональности нельзя использовать исключительно полифилы. Нативная реализация API быстрее и с ней можно сделать больше, чем с помощью полифила.
        Babel:
          Когда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их. И не везде реализованы все функции.
          И тут приходит на помощь Babel. Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.
        Polyfills can be implemented in a variety of ways, such as using JavaScript code, libraries, or other tools. They can be written by individual developers, or provided by third-party libraries or frameworks. 
          One potential disadvantage of using polyfills is that they can add additional code to a website or application, which can increase load times and potentially slow down performance. 
          However, in many cases, the benefits of providing modern functionality to older browsers outweigh the potential downsides.
          if (!Array.prototype.includes) {} // проверяем наличие метода includes в прототипе Array
    +Number methods
        -num.toString(base) возвращает строковое представление числа в той или иной системе счисления (base). от 2 до 36 (по умолчанию 10) 
        -num.toFixed(...) возвращает строку с числом, записанным с указанным числом десятичных знаков: var x = 9.656; x.toFixed(2); => "9.66" x.toFixed(0); => returns 10 x.toFixed(6); => returns 9.656000
      Методы преобразования переменных в числовой тип (Global):
        -Number() преобразования переменных JavaScript в числа: Number(true) => 1 | Number("  10") => возвращает 10 | Number("10 20") => NaN 
        -parseInt() парсит строку и возвращает целое число. В строке можно использовать пробелы. Возвращается только первое число: parseInt("10 20 30") => 10 | parseInt('25px') => 25 | parseInt("years 10") => NaN 
        -parseFloat() парсит строку и возвращает число с десятичной точкой. parseFloat("10.33") => 10.33 | parseFloat("10 20") => 10
      Проверка безопастности числа:
        -Number.isFinite(value) проверяет, является ли значение числом и не NaN. Возвращает true или false.
        -Number.isNaN(value) проверяет, является ли значение NaN. Возвращает true или false.
        -Number.isSafeInteger() true, если передаваемое значение является безопасным целым числом ( -123 ) => true | ( "123" ) => false | ( [] ) => false | ( undefined ) => false
      Округление: Объект Math, который содержит несколько функций для работы с округлением:
        -Math.floor(2.8) = 2 в меньш сторону
        -Math.ceil(2.2) = 3 в большую сторону 
        -Math.round(2.5) = 3 Округляет до целого числа.
      Получение случайного числа:
        -Math.random() В диапазоне от 0(включительно) до 1(но не включая 1)
      Другие:
        -Math.max(a, b, c...) Math.min(a, b, c...) Возвращает наибольшее/наименьшее число 
        -Math.pow(x, y) Возвращает число x в степени y
        -Math.abs() возвращает модуль числа, то есть из отрицательного числа делает положительное. (3) => 3 | (-3) => 3 | (0) => 0
    +String methods
      Поиск подстроки:
        -str.indexOf(substr, pos) Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. второй аргумент позволяет начать поиск с определённой позиции
          Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:
        -str.lastIndexOf(substr, position) ищет с конца строки к её началу. Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.
        -str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет. Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции.
        -str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой. Пример: str.startsWith("abc") вернёт true, если str начинается с "abc".
      Получение подстроки:
        -str.slice(start [, end]) от start до end (не включая end)	можно передавать отрицательные значения let str = "stringify"  str.slice(0, 5) => "strin" end отсутствует, slice возвращает символы до конца строки
          Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки: let str = "stringify" str.slice(-4, -1) => // gif
        -str.substring(start [, end]) между start и end	отрицательные значения равнозначны 0. Это — почти то же, что и slice, но можно задавать start больше end.
          Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами. let str = "stringify"; str.substring(2, 6) => // "ring" str.substring(6, 2) => // "ring"
          Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.
        -str.substr(start [, length]) length символов, начиная от start. В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции: let str = "stringify" str.substr(2, 4) => // "ring"
          Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца: let str = "stringify" str.substr(-4, 2) => // "gi"
      Сравнение строк: Используется кодировка Unicode
        -str.codePointAt(pos) возвращает кодовое значение символа в строке str на позиции pos. Если pos не задан, возвращает кодовое значение первого символа. Если pos больше длины строки, возвращает undefined. 
        -String.fromCodePoint(code) возвращает строку, представляющую кодовое значение code. Если code не является кодовым значением, возвращается пустая строка. fromCodePoint(90) ) => // Z
      Изменение регистра:
        -str.toUpperCase() Возвращает верхний регистр строки.
        -str.toLowerCase() Возвращает нижний регистр строки.
      Доступ к символам: 
        -str[0] возвращает первый символ строки str | если символ с такой позицией отсутствует, тогда [] вернёт undefined
        -str.charAt(0) возвращает первый символ строки str (существует в основном по историческим причинам.) если символ с такой позицией отсутствует charAt — пустую строку 
      полезные методы:
        -str.trim() — убирает пробелы в начале и конце строки.
        -str.repeat(n) — повторяет строку n раз.
        -str.replace("Microsoft", "W3Schools"); не изменяет строку, для которой он вызывается. возвращает новую строку. заменяет только первое совпадение
          Чтобы заменить все совпадения, используйте регулярное выражение с /gфлагом let text = "Please visit Microsoft and Microsoft!"; text.replace(/Microsoft/g, "W3Schools"); => "Please visit W3Schools and W3Schools!"
          Нечувствительный к регистру: let text = "Please visit Microsoft and Microsoft!"; text.replace(/microsoft/gi, "W3Schools"); => "Please visit W3Schools and W3Schools!"
      Property:
        -str.length  = кол-во символов. 
      
  +Arrays Built-in methods
    Варианты создания массива:
      let a = [];
      let b = new Array(1); // [undefined]
      let c = new Array(1,2); // [1,2]
      let d = Array.from('foo'); // ['f', 'o', 'o']

      Array.from: 
      let s = new Set(['foo', window]); 
      let e = Array.from(s); // ['foo', window]

      let f = Array.from([1, 2, 3], x => x + x); // [2, 4, 6]

      let g = Array.from({ length: 5 }, (v, k) => k); // [0, 1, 2, 3, 4]

      Array.of:  
      Array.of(1);         // [1]
      Array.of(1, 2, 3);   // [1, 2, 3]
      Array.of(undefined); // [undefined]
    Методы массива:
      Добавление/удаление элементов:
        -push(...items)добавляет items в конец массива.
        -pop() удаляет элемент в конце массива и возвращает его.
        -unshift(...items) добавляет items в начало массива.
        -shift() удаляет элемент в начале массива и возвращает его.
        
        -splice  Умеет всё: добавлять, удалять и заменять элементы. arr.splice(index[, deleteCount, elem1, ..., elemN]) Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
          удаление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент => ["Я", "JavaScript"] | arr.splice(-1,1) – первый с конца. 
          добавление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 0, "программирование"); // начиная с позиции 1, добавить 0 элементов => ["Я", "программирование", "изучаю", "JavaScript"] | arr.splice(-1,0, "программирование") – первый с конца.
          удаление и замена: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1, "программирование"); // начиная с позиции 1, удалить 1 элемент и вставить "программирование" => ["Я", "программирование"]
          Отрицательные индексы разрешены: let arr = [1, 2, 5];  arr.splice(-1, 0, 3, 4); => [1, 2, 3, 4, 5]
        -slice arr.slice([start], [end]) Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
          let arr = ["t", "e", "s", "t"];  arr.slice(1, 3) => ["e", "s"] arr.slice(-2) => ["s", "t"] 
          Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
        -concat arr.concat(arg1, arg2...) Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения. Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
          let arr = ["t", "e", "s", "t"];  arr.concat("test", "test2") => ["t", "e", "s", "t", "test", "test2"]
      Перебор: 
        -forEach Позволяет запускать функцию для каждого элемента массива. arr.forEach(function(item, index, array) { // ... делать что-то с item }); Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
      Поиск в массиве: (Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.)
        -arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
        -arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
        -arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен. let arr = [1, 0, false]; arr.includes(0) => true arr.includes(2) => false
          Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf.
        -arr.find(fn) findLast()  Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием? Функция вызывается по очереди для каждого элемента массива. Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
          let result = arr.find(function(item, index, array) { // если true - возвращается текущий элемент и перебор прерывается // если все итерации оказались ложными, возвращается undefined});
        -arr.findIndex(fn) findLastIndex() по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
        -arr.filter(fn) На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn). Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов. let someUsers = users.filter(item => item.id < 3);
      Преобразование и упорядочения массива:
        -arr.map(fn) применяет функцию fn к каждому элементу массива и возвращает новый массив. Функция fn принимает 3 аргумента: item, index и array.
        -arr.sort(fn) сортирует массив на месте(копия массива не создаётся), меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. let arr = [ 1, 2, 15 ]; arr.sort(); => [ 1, 15, 2 ]
          По умолчанию элементы сортируются как строки. Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что "2" > "15".
          Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная быстрая сортировка). 
          Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение.
          На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше». Это позволяет писать более короткие функции: let arr = [ 1, 15, 2 ]; arr.sort((a, b) => a - b); => [ 1, 2, 15 ]
          arr.sort((a, b) => b.localeCompare(a)); => [ 15, 2, 1 ] // сортировка по убыванию localeCompare - 
        -arr.reverse() Метод reverse() на месте переставляет элементы массива (меняя исходный массив), на котором он был вызван, изменяет массив и возвращает ссылку на него.
        _-str.split(delim) Он разбивает строку на массив по заданному разделителю delim. В примере  таким разделителем является строка из запятой и пробела. let arr = names.split(', '); Или с пустым аргументом разбил бы строку на массив букв  str.split('')
          У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2); => [ 'Вася', 'Петя' ]
        -arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.
        -reduce/reduceRight Они используются для вычисления какого-нибудь единого значения на основе всего массива. let value = arr.reduce(function(previousValue, item, index, array) {...}, [initial]);
          Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов. 
          previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial), а при отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
          При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент. По окончании он становится результатом reduce.
      Array.isArray([1, 2, 3]) - Массивы не образуют отдельный тип языка. Они основаны на объектах. Поэтому typeof не может отличить простой объект от массива. Он возвращает true, если value массив, и false, если нет.
      Другие:
        -arr.some(fn)/arr.every(fn) Функция fn вызывается для каждого элемента массива. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
        -arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end. Если end не задан, заполняется до конца массива.
        -arr.copyWithin(target, start, end) – копирует массив с индекса start до end в массив с индексом target. Если end не задан, копируется до конца массива. [1, 2, 3, 4, 5].copyWithin(0, 3); => [4, 5, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(0, 3, 4); => [4, 2, 3, 4, 5]
        -arr.flat(n) – var newArray = arr.flat(depth); Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth. (На сколько уровней вложенности уменьшается мерность исходного массива. По умолчанию 1.)
          const arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); => [1, 2, 3, 4, [5, 6]]      const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr4.flat(Infinity); => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          Метод flat удаляет пустые слоты из массива: var arr4 = [1, 2, , 4, 5]; arr4.flat(); => [1, 2, 4, 5]
        -arr.flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. 
          Это идентично map функции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно.
          let arr1 = ["it's Sunny in", "", "California"]; arr1.map(x => x.split(" ")); => [["it's","Sunny","in"],[""],["California"]] arr1.flatMap(x => x.split(" ")); => ["it's","Sunny","in", "", "California"]
        -arr.keys() возвращает новый итератор массива Array Iterator, содержащий ключи каждого индекса в массиве. var arr = ['a', 'b', 'c']; var iterator = arr.keys(); iterator.next() => { value: 0, done: false }
        -arr.values() возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.
        -arr.toString() возвращает строковое представление указанного массива и его элементов. Cоединяет массив и возвращает одну строку, содержащую каждый элемент массива, разделённый запятыми.
        -Array.from(arrayLike[, mapFn[, thisArg]]) создаёт новый экземпляр Array из arrayLike или итерируемого объекта.
          arrayLike - Массивоподобный или итерируемый объект, преобразуемый в массив.
          mapFn - Отображающая функция, вызываемая для каждого элемента массива.
          thisArg - Значение, используемое в качестве this при выполнении mapFn.
        -Array.of() - Разница между Array.of() и конструктором Array заключается в обработке целочисленных аргументов: Array.of(7) создаёт массив с одним элементом 7, а Array(7) создаёт пустой массив со значением свойства 
          length равным 7 (Замечание: подразумевается 7 пустых слотов, а не слоты со значением undefined).  Array.of(7); // [7] | Array(7); // массив с 7 пустыми слотами
    ?Know how to copy array part
    ?Know how to flatten nested array
    */
    Array.prototype.flatten = function() {
      var ret = [];
      for(var i = 0; i < this.length; i++) {
          if(Array.isArray(this[i])) {
              ret = ret.concat(this[i].flatten());
          } else {
              ret.push(this[i]);
          }
      }
      return ret;
  };
    /*

  ?Arrays Iterating, Sorting, Filtering
    ?Be able to custom sorting for Array
    */
    array.sort((x, y) => {
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
      return 0;
    });
    /*
    ?Be able to filter Array elements
    ?Know how to sort Array
    ?Know several method how to iterate Array elements
  +Objects Built-in methods.
    Варианты создания объектов:
      1. var obj = new Object();
      2. var obj = {};
      3. var obj = Object.create(null);
      4. constructor function
    let user = new Object(); // синтаксис "конструктор объекта" let user = {};  // синтаксис "литерал объекта" 
    Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
      Они хранят свойства (пары ключ-значение), где:
        -Ключи свойств должны быть строками или символами (обычно строками).
        -Значения могут быть любого типа.
      Чтобы получить доступ к свойству, мы можем использовать:
        -Запись через точку: obj.property.
        -Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
      Дополнительные операторы:
        -Удаление свойства: delete obj.prop.
        -Проверка существования свойства: "key" in obj. Если вы хотите рассматривать только свойства самого объекта, а не его прототипов, используйте getOwnPropertyNames(), hasOwnProperty() или propertyIsEnumerable. if( obj.hasOwnProperty( prop ) ) { ... }
        -Перебор свойств объекта: цикл for for (let key in obj).
    Упорядочение свойств объекта - Если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать? 
      Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
    ?Know how to use built-in methods
      -Object.create() - создаёт новый объект с указанным прототипом и свойствами. Object.create(proto[, propertiesObject])
        Параметры
          -proto - Объект, который станет прототипом вновь созданного объекта.
          -propertiesObject - как 2й аргумент defineProperties Если указан и не равен undefined, должен быть объектом, чьи собственные перечисляемые свойства (то есть такие, которые определены на самом объекте, а не унаследованы по цепочке прототипов) указывают дескрипторы свойств, добавляемых в новый объект.
            Имена добавляемых свойств совпадают с именами свойств в этом объекте. Эти свойства соответствуют второму аргументу метода Object.defineProperties().
        Возвращаемые значения: Новый объект с заданным прототипом и свойствами.
      -Object.assign() - используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.
        Object.assign(target, ...sources) => Возвращается получившийся целевой объект. Object.assign({}, obj1, obj2) в пустой объект копируются свойства из obj1 и obj2. что бы не мутировать исходные объекты.
        (Он использует внутренний метод [[Get]] на исходных объектах и внутренний метод [[Set]] на целевом объекте, так что он также вызывает геттеры и сеттеры. Именно поэтому он присваивает свойства вместо простого копирования или определения новых свойств.
        Это поведение может сделать метод непригодным для вливания новых свойств в прототип, если вливаемые исходные объекты содержат геттеры. Вместо него для копирования в прототипы определений свойств, включая признак их перечисляемости, следует использовать методы Object.getOwnPropertyDescriptor() и Object.defineProperty().)
      -Object.keys() - Метод Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов). //* Object.keys(obj)
        Метод Object.keys возвращает массив строковых элементов, соответствующих именам перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном перечислении свойств в объекте через цикл. 
        (Если вы хотите увидеть все свойства, а не только перечисляемые, смотрите метод Object.getOwnPropertyNames().)
      -Object.values() - возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов. Object.values(obj)
      -Object.entries() - возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in перечисляет свойства из цепочки прототипов).
        Порядок элементов в массиве который возвращается Object.entries() не зависит от того как объект объявлен. Если существует необходимость в определённом порядке, то  массив должен быть отсортирован до вызова метода, например Object.entries(obj).sort((a, b) => a[0] - b[0]);.

      -Object.prototype.hasOwnProperty() -  возвращает логическое значение, указывающее, содержит ли объект указанное свойство. obj.hasOwnProperty(prop) prop Имя проверяемого свойства. в отличие от оператора in, этот метод не проверяет существование свойств в цепочке прототипов объекта.
      -Object.hasOwn(instance, prop) - 2022 obj.hasOwnProperty(prop) должен вызываться так, но проблема в том что его пожно перезатереть - теперь он статический и не может быть перезатерт.
      -Object.prototype.propertyIsEnumerable() - возвращает логическое значение, указывающее, является ли указанное свойство перечислимым. obj.propertyIsEnumerable(prop) prop Имя проверяемого свойства.
      -Object.getPrototypeOf() - возвращает прототип (то есть значение внутреннего свойства [[Prototype]]) указанного объекта. Object.getPrototypeOf(obj)
      -Foo.prototype.isPrototypeOf(bar) - возвращает логическое значение, указывающее, является ли прототипом объекта Foo объект bar. obj.isPrototypeOf(inher)

      -Object.freeze() - замораживает объект, после чего нельзя будет изменить, добавить или удалить свойства из него.
      -Object.isFrozen() - возвращает true, если объект заморожен, иначе false.
      -Object.preventExtensions() - предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).
      -Object.seal() - not only prevents an object from having new properties added to it, but it also prevents existing properties from being deleted or reconfigured
      -Object.isSealed() - возвращает true, если объект заморожен, иначе false.
      -Object.isExtensible() - возвращает true, если объект расширяем, иначе false.

      -Object.defineProperties() - определяет новые или изменяет существующие свойства, непосредственно на объекте, возвращая этот объект. //* Object.defineProperties(obj, props)
        Параметры:
          -obj Объект, на котором определяются новые или изменяются существующие свойства.
          -props Объект, чьи собственные перечисляемые свойства представляют собой дескрипторы для создаваемых или изменяемых свойств. Дескрипторы свойств обладают следующими дополнительными ключами
            -configurable: Равен true только в том случае, если тип этого дескриптора свойства может быть изменён и если свойство может быть удалено из содержащего его объекта. Значение по умолчанию установлено в false. // false => запретить удаление "delete user.name"
            -enumerableРавен: true только в том случае, если это свойство можно увидеть через перечисление свойств содержащего его объекта. Значение по умолчанию установлено в false. // false => запретить перечисление "for..in"
            -value: Значение, ассоциированное со свойством. Может быть любым допустимым значением JavaScript (числом, объектом, функцией и т.д.). Значение по умолчанию установлено в undefined.
            -writable: Равен true только в том случае, если значение, ассоциированное со свойством, может быть изменено с помощью оператора присваивания (en-US). Значение по умолчанию установлено в false. // false => запретить присвоение "user.name="
            -get: Функция, возвращающая значение свойства. Значение по умолчанию установлено в undefined.
            -set: Функция, принимающая значение и возвращающая новое значение свойства. Значение по умолчанию установлено в undefined.
              Object.defineProperties(object1, {
                property1: {
                  value: 42,
                  writable: true
                },
                property2: {}
              });
        Возвращаемое значение: Объект, переданный в функцию.
      -Object.defineProperty() - определяет новое или изменяет !существующее свойство, непосредственно на объекте, возвращая этот объект. //* Object.defineProperty(obj, prop, descriptor) descriptor - Дескриптор определяемого или изменяемого свойства.
        Этот метод позволяет точно добавлять или изменять свойства объекта. Обычное добавление свойств через присваивание создаёт свойства, которые можно увидеть через перечисление свойств 
        (с помощью цикла for...in или метода Object.keys), чьи значения могут быть изменены и которые могут быть удалены. Этот же метод позволяет настроить эти дополнительные детали свойства.
        Дескрипторы свойств, присутствующие в объектах, бывают двух основных типов: дескрипторы данных и дескрипторы доступа.
          Дескриптор данных — это свойство, имеющее значение, которое может быть (а может и не быть) записываемым.
          Дескриптор доступа — это свойство, описываемое парой функций — геттером и сеттером.
          Дескриптор может быть только чем-то одним из этих двух типов; он не может быть одновременно обоими.
          И дескриптор данных, и дескриптор доступа являются объектами. Они обладают следующими обязательными ключами: См выше prop
            Object.defineProperty(object1, 'property1', {
              value: 42,
              writable: false
            });
    ?Static Object methods
      Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса. В объявлении класса они помечаются ключевым словом static.
      Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта. Синтаксис:
      */
      class MyClass {
        static property = '...';
      
        static method() {
          '...'
        }
      }
      /*
      Технически, статическое объявление – это то же самое, что и присвоение классу:
      MyClass.property = ...
      MyClass.method = ...
      Статические свойства и методы наследуются. Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.
      к статическому полю нельзя обратиться через this, только через имя класса. Поскольку статический метод относится классу в целом, а не к объекту, то мы НЕ можем обращаться в нем к нестатическим полям/свойствам и методам объекта, наподобие следующего: 
      Person.printAge();  // undefined printAge не статический метод, поэтому мы не можем обратиться к нему через имя класса, а только через объект.
      Однако мы можем использовать в статических методах слово this для обращения к статическим полям и другим статическим методам:

  ?Object as Hash.
    Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object.
    Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть". У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений. 
    Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу. Она позволяет организовать данные ассоциативного массива удобным для хранения способом. 
    Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей. 
      Хеширование
        Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива. Для получения индекса из ключа нужно выполнить два действия: найти хеш (хешировать ключ) и привести его к индексу (например, через остаток от деления).
        Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины.  Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". 
        Хеш всегда одинаковый для одних и тех же данных! console.log(hash); // => -337197338 С хешированием мы встречаемся в разработке часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 не что иное, как хеш, полученный в результате хеширования данных коммита.
        После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления: const index = Math.abs(hash) % 1000; // по модулю // Это делается для того, чтобы индексы не были слишком большими
          Запись:
            const data = {}; data['key'] = 'value';Такая простая, на первый взгляд, строчка, запускает целый процесс. Ниже его грубое описание, без деталей и с упрощениями: Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне
              1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
              const internal = [];
              Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:
              2. Хеширует ключ. Результатом хеширования становится число.
              const hash = crc32.str('key');
              3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
              const index = Math.abs(hash) % 1000;
              В значение внутреннего индексированного массива, по найденному индексу, записывается ещё один массив, первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
              internal[index] = ['key', 'value'];
          Чтение: 
            1. Хешируется ключ. Результатом хеширования становится число.
            const hash = crc32.str('key');
            2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
            const index = Math.abs(hash % 1000);
            3. Если индекс существует, то извлекается массив, который находился внутри, и возвращается наружу.
            return internal[index]; // ['key', 'value']
      Коллизии
        Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат работы хеш-функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.
        Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. Есть несколько способов разрешения коллизий (открытая адресация, метод цепочек), и каждому из них соответствует свой тип хеш-таблицы.
    ?Be able to loop through Object keys
    */
    const objHash = {
      'one': 1,
      'two': 2,
      'three': 3,
    }
    for (let key in objHash) {
      if (Щиоусе.hasOwnProperty(key)) { // if (Object.hasOwn(objHash, key)) {
        console.log(`${key}: ${objHash[key]}`);
      }
    }
    // цикл по ключам и значениям
    for (let [key, value] of Object.entries(user)) {
      alert(`${key}:${value}`); // name:John, затем age:30
    }
    const objKey = Object.keys(objHash)
    /*

    +Преобразование объектов в примитивы:
      JavaScript совершенно не позволяет настраивать, как операторы работают с объектами. В отличие от некоторых других языков программирования, таких как Ruby или C++, мы не можем реализовать специальный объектный метод для обработки сложения (или других операторов).
      В случае таких операций, объекты автоматически преобразуются в примитивы, затем выполняется сама операция над этими примитивами, и на выходе мы получим примитивное значение.
      Это важное ограничение: результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!
    Правила преобразования:
      1. Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
      2. Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
      3. Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
      Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы.
    Хинты:
      Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:
        - "string" Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:
          _вывод alert(obj);
          _используем объект в качестве ключа anotherObj[obj] = 123;
        - "number" Для преобразования объекта к числу, в случае математических операций:
          _явное преобразование let num = Number(obj);
          _математические (не считая бинарного плюса) let n = +obj; // унарный плюс let delta = date1 - date2;
          _сравнения больше/меньше let greater = user1 > user2;
          Большинство встроенных математических функций также включают в себя такое преобразование.
        - "default" Происходит редко, когда оператор «не уверен», какой тип ожидать. Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). 
          Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
          Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".
          _бинарный плюс использует хинт "default" let total = obj1 + obj2;
          _obj == number использует хинт "default" if (user == 1) { ... };
          _Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".
      Впрочем на практике, всё немного проще.
        Все встроенные объекты, за исключением одного (объект Date), реализуют "default" преобразование тем же способом, что и "number". И нам следует поступать так же.
        Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
          1. Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
          2. Иначе, если хинт равен "string" попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
          3. Иначе, если хинт равен "number" или "default" попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.
      Symbol.toPrimitive - Давайте начнём с первого метода. Есть встроенный символ с именем Symbol.toPrimitive, который следует использовать для обозначения метода преобразования, вот так:
        */
        let user22 = {
          name: "John",
          money: 1000,
          [Symbol.toPrimitive](hint) { // принимает hint
            alert(`hint: ${hint}`);
            return hint == "string" ? `{name: "${this.name}"}` : this.money;
          }
        };
        alert(user22); // hint: string -> {name: "John"}
        alert(+user22); // hint: number -> 1000
        alert(user22 + 500); // hint: default -> 1500
        /*
        Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
        Как мы можем видеть из кода, user становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. Единый метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования.
      toString/valueOf - Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:
        -Для хинта "string": вызвать метод toString, а если он не существует, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).
        -Для других хинтов: valueOf, а если он не существует, то toString (таким образом, valueOf имеет приоритет для математических операций).
        Они предоставляют альтернативный «старомодный» способ реализации преобразования.
        Эти методы должны возвращать примитивное значение. Если toString или valueOf возвращает объект, то он игнорируется (так же, как если бы метода не было).
        По умолчанию обычный объект имеет следующие методы toString и valueOf:
          -Метод toString возвращает строку "[object Object]". let user = {name: "John"}; => alert(user); // [object Object]
          -Метод valueOf возвращает сам объект. let user = {name: "John"}; => alert(user.valueOf() === user); // true
        */
          let user2 = {
            name: "John",
            money: 1000,
              // для хинта равного "string"
            toString() {
              return `{name: "${this.name}"}`;
            },
          
            // для хинта равного "number" или "default"
            valueOf() {
              return this.money;
            }
          
          };
          alert(user); // hint: string -> {name: "John"}
          alert(+user); // hint: number -> 1000
          alert(user + 500); // hint: default -> 1500
          /*
          Как видим, получилось то же поведение, что и в предыдущем примере с Symbol.toPrimitive.
      Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. В этом случае мы можем реализовать только toString:
          */
        let user3 = {
          name: "John",
          money: 1000,
          toString() {
            return this.name;
          }
        };
        alert(user); // toString -> John
        alert(user + 500); // toString -> John500
        /*
        В отсутствие Symbol.toPrimitive и valueOf, toString обработает все примитивные преобразования.
          Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.
          Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возращал именно число для хинта "number".
          Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.
      Дальнейшие преобразования
        Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:
          -Объект преобразуется в примитив (с использованием правил, описанных выше).
          -Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.
  +Symbol
    The Symbol object is a built-in object in JavaScript that represents a unique identifier. It's a constructor function that creates new symbol values.
      The Symbol object has several static properties and methods that you can use to work with symbols. These include:
        -Symbol.iterator: A symbol that represents the default iterator for an object.
        -Symbol.asyncIterator: A symbol that represents the default async iterator for an object.
        -Symbol.hasInstance: A symbol that represents a method that determines if an object is an instance of a constructor.
        -Symbol.toPrimitive: A symbol that represents a method that converts an object to a primitive value.
        -Symbol.toStringTag: A symbol that represents a string that is used as the default description for an object when it's converted to a string.
      In addition to these static properties and methods, the Symbol object also has prototype methods that can be used with symbol values. These include:
        -Symbol.prototype.toString(): A method that returns a string representation of the symbol.
        -Symbol.prototype.valueOf(): A method that returns the primitive value of the symbol.
      When you create a new symbol using the Symbol() constructor, you get a new symbol value that represents a unique identifier. Each symbol value is immutable and unique, meaning that it can't be changed or compared to any other symbol value.
      You can use symbols as keys in object properties, as we saw earlier, to avoid naming collisions and create private properties. You can also use symbols to define custom iterators, as we saw with Symbol.iterator, and to define other custom behavior in your JavaScript code.
    
      -Символы - это уникальные идентификаторы. Они создаются с помощью функции Symbol(), которая может принимать необязательное описание (имя) символа.
      let id = Symbol("id");
      let id2 = Symbol("id");
      alert(id == id2); // false

    const forId = Symbol.for("id"); // если символа не существует, он будет создан
    const forIdAgain = Symbol.for("id"); // возвращается уже существующий символ
    alert(forId === forIdAgain); // true

    keyfor - возвращает имя символа по глобальному реестру
      let globalSymbol = Symbol.keyFor(forId);
      alert(globalSymbol); // id, глобальный символ

      let localSymbol = Symbol("name");
      let localSymbolName = Symbol.keyFor(localSymbol); // undefined, так как символ не в глобальном реестре

    getOwnPropertySymbols - возвращает массив всех символов, доступных непосредственно из объекта 

  +Function
    -Функции - ключевая концепция в JavaScript. Важнейшей особенностью языка является первоклассная поддержка функций​ (functions as first-class citizen). Любая функция это объект, и следовательно ею можно манипулировать как объектом, в частности:
      -передавать как аргумент и возвращать в качестве результата при вызове других функций (функций высшего порядка);
      -создавать анонимно и присваивать в качестве значений переменных или свойств объектов.
      Это определяет высокую выразительную мощность JavaScript и позволяет относить его к числу языков, реализующих функциональную парадигму программирования
    Локальные переменные: Переменные, объявленные внутри функции, видны только внутри этой функции. 
    Внешние переменные: У функции есть доступ к внешним переменным, например. Внешняя переменная используется, только если внутри функции нет такой локальной. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
    Параметры: Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции). Когда функция вызывается в строках (*) и (**), переданные значения копируются в локальные переменные from и text. Затем они используются в теле функции.
    Возврат значения: Функция может вернуть результат, который будет передан в вызвавший её код.
    ?arrow func/ func expression/ func declaration
      func expression / func declaration
        Оба способа объявления функции эквивалентны, но есть существенная разница: функции, объявленные как Function Declaration, будут доступны, даже если обратится к ним до того, как они были объявлены.
        Интерпретатор вначале пробегается по всему документу с кодом и ищет все функции, объявленные как Function Declaration, и только потом начинает выполнять код документа построчно.
      5 отличий между обычными и стрелочными функциями:
        1. this
          -Внутри обыкновенной функции значение this динамическое (в зависимости от контекста исполнения). 
            В JS существует 4е способа как мы можем вызвать функцию:
              1. Во время обычного выполнения значение this эквивалентно глобальному объекту
              2. Во время выполнения функции объекта значением this является объект, у которого был вызван метод
              3. Косвенный вызов используя myFunc.call(thisVal, arg1, ..., argN) или myFunc.apply(thisVal, [arg1, ..., argN]), значение this эквивалентно первому аргументу
              4. Вызов с помощью конструктора используя ключевое слово new, значение this эквивалентно новосозданной сущности
          -Стрелочные функции: 
            Поведение this внутри стрелочной функции отличается от поведения this внутри обычной функции.Не имеет значения как она была вызвана, 
            значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции.
            Другими словами функция не создает собственный контекст исполнения, она использует внешний.
            Когда мы используем колбек внутри метода, мы можем быть уверенны, что стрелочная функция не создаст собственный this
        2. Конструкторы
          -Обычная функция может легко создавать объекты.
          -Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.
        3. Объект arguments
          -Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.
          -С другой стороны, в стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.
            Если мы хотим все таки получить доступ напрямую к аргументам стрелочной функции, мы можем использовать фичу деструктуризации: Параметр ...args собирает все аргументы преданные при вызове стрелочной функции: { 0: 'c', 1: 'd' }.
        4. Неявный return
          -Только использование выражения return возвращает результат выполнения функции
          -Если стрелочная функция содержит в теле одну инструкцию, и мы опустили фигурные скобки, тогда выражение будет возвращено автоматически.
        5. Методы 
          -Обычные
            Чаще всего, обыкновенная функция используется для создания методов класса. Иногда нам будет нужно применить метод в качестве колбека, например для setTimeout() или для event listener`а.
            Иногда нам будет нужно применить метод в качестве колбека, например для setTimeout() или для event listener`а. Например, попробуем использовать logName() метод как колбек для setTimeout():
            logName() {console.log(this.heroName); } setTimeout(batman.logName, 1000); => after 1 second logs "undefined" В данном случае метод отделен от объекта.
            Вручную привязать контекст: setTimeout(batman.logName.bind(batman), 1000); => after 1 second logs "Batman"
          -Стрелочные
            Мы можем использовать стрелочные функции как методы, внутри класса.
            Сейчас, на контрасте с обыкновенной функцией, метод определенный с использованием стрелочной функции привязывает thisк объекту класса.
            Значение this внутри метода logName() всегда объект класса
  +Functional Scope
    Область видимости или Scope
      -Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области кода.
    Глобальная область видимости или Global Scope
      -В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.
    Локальная область видимости или Local Scope
      -Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.
      -Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.
      */
      // Глобальная область
        function foo1(){
       // Локальная область 1
          function foo2(){
           // Локальная область 2
          }
        }
      /*
    Область видимости функции
      -Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.
    Область видимости блока
      -Область видимости блока - это область в условиях if и switch или циклов for, и while. Вообще говоря, всякий раз, когда мы видим фигурные скобки {} - это блок. В ES6 ключевые слова const и let позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.
    Лексическая область видимости
      -Ещё один момент, о котором стоит упомянуть - это лексическая область. Лексическая область означает, что дочерняя область имеет доступ к переменным, определенным в родительской области. Дочерние функции лексически связаны с контекстом исполнения их родителей.
    Динамическая область видимости
      -Лексическая область видимости - это набор правил о том, как и где движок JavaScript может найти переменную. Ключевой характеристикой лексического контекста является то, что он определяется во время написания кода (при условии, что мы не используем eval () или with).
      -Динамическая область видимости, по понятным причинам, подразумевает, что существует модель, в которой область видимости может определяться динамически во время выполнения, а не статически во время создания. 
      */
      function foo(){
        console.log(a); // 5 В лексической области видимости указывается, что ссылка на a в foo() будет преобразована в глобальную переменную a, что приведет к выводу значения 5.
      }

      function bar(){
        var a = 10;
        foo();
      }
      
      var a = 5;
      
      bar();
      /*
      Динамическая область видимости, напротив, не связана с тем, как и где объявляются функции и области, а связана с тем, откуда они вызываются. Другими словами, цепочка областей видимости основана на стеке вызовов, а не на вложении областей видимости в коде.
      Таким образом, если бы JavaScript имел динамическую область видимости, то, когда выполняется foo(), теоретически приведенный ниже код, вместо 5 вернул бы 10 в качестве вывода.
      Когда foo() не может найти ссылку на переменную для a, вместо просмотра вложенной (лексической) цепочки областей видимости, он идет вверх по стеку вызовов, чтобы найти, откуда вызывалась функция foo(). Поскольку foo() была вызвана из bar(), он проверяет переменные в области видимости bar() и находит там a со значением 10.
      Но JavaScript, на самом деле, не имеет динамической области видимости. Он имеет только лексическую область. А вот механизм this подобен динамической области видимости.
      Вывод
        -Лексическая область - определяется во время написания кода, тогда как динамическая область (и this) - во время выполнения. Лексическая область заботится о том, где была объявлена функция, а динамическая область - о том, откуда была вызвана функция.
        -И наконец: this заботится о том, как была вызвана функция. Это показывает нам, насколько тесно механизм this связан с идеей динамической области видимости.
    ?Know global scope and functional scope
    ?Know variables visibility areas
    ?let var const - differences
    ?Understand nested scopes and able work with them

  +Functions Parameters / Arguments
    ?Know how to define Function parameters
    ?Know difference between parameters passing by value and by reference
      Передача параметров по значению
        Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.
        При вызове функции change ей передается число n. Однако после вызова функции мы видим, что число n не изменилось, хотя в самой функции произошло увеличение значения параметра. 
        Потому что при вызове функция change получает копию значения переменной n. И любые изменения с этой копией никак не затрагивают саму переменную n.
      Передача по ссылке
        Объекты и массивы передаются по ссылке. То есть функция получает сам объект или массив, а не их копию.
    ?Know how to handle dynamic amount of Function parameters
      Spread syntax Остаточные параметры (...)
        Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена. Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.
        Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».
        */
        function sumAll(...args) { // args — имя массива
          let sum = 0;
        
          for (let arg of args) sum += arg;
        
          return sum;
        }

        function showName(firstName, lastName, ...titles) {
          alert( firstName + ' ' + lastName ); // Юлий Цезарь
        
          // Оставшиеся параметры пойдут в массив
          // titles = ["Консул", "Император"]
          alert( titles[0] ); // Консул
          alert( titles[1] ); // Император
          alert( titles.length ); // 2
        }
        /*
        Остаточные параметры должны располагаться в конце! ...rest должен всегда быть последним.
      Объект arguments можно использовать при вызове функции с бо́льшим количеством аргументов, чем было предусмотрено в её объявлении. Такой способ удобен для функций, в которые допустимо передавать переменное количество аргументов. 
        Можно воспользоваться arguments.length, чтобы определить количество переданных в функцию аргументов, а затем обработать каждый из них с помощью объекта arguments. Чтобы определить количество параметров функции, описанных в её сигнатуре, можно использовать свойство Function.length.
        Использование оператора расширения для объекта arguments
          Как и с обычными массива-подобными объектами, для преобразования объекта arguments в обычный массив можно использовать метод Array.from() или оператор расширения: var args = Array.from(arguments); var args = [...arguments];
          Свойства:
            -arguments.callee Ссылка на функцию, которая выполняется в текущий момент.
            -arguments.caller Ссылка на функцию, которая вызвала функцию, выполняющуюся в текущий момент.
            -arguments.length Количество переданных в функцию аргументов.
            -arguments[@@iterator]  Возвращает новый объект Array Iterator, содержащий значения для каждого индекса в массиве.
      
    ?Function default parameters
      Параметры по умолчанию (Default parameters)
        В JavaScript параметры функции по умолчанию имеют значение undefined. Однако в некоторых ситуация может быть полезным поменять значение по умолчанию. В таких случаях default parameters могут быть весьма кстати.
        В прошлом для этого было необходимо в теле функции проверять значения параметров на undefined и в положительном случае менять это значение на дефолтное (default).
        С параметрами по умолчанию проверка наличия значения параметра в теле функции не нужна. Теперь вы можете просто указать значение по умолчанию для параметра b в объявлении функции:
        */
        function multiply(a, b = 1) {
          return a * b;
        }
        /*
    +ECMA script modules
      По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». Модуль обычно содержит класс или библиотеку с функциями.
      -AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
      -CommonJS – модульная система, созданная для сервера Node.js.
      -UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.
      Система модулей на уровне языка появилась в стандарте JavaScript в 2015 году и постепенно эволюционировала.
        1. Что такое модуль? 
          Модуль – это просто файл. Один скрипт – это один модуль. Чтобы работал import/export, нужно для браузеров указывать атрибут <script type="module">.
          Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
            -export отмечает переменные и функции, которые должны быть доступны вне текущего модуля. export function sayHi(user) {}
            -import позволяет импортировать функциональность из других модулей. import {sayHi} from './sayHi.js';
          У модулей есть ряд особенностей:
            -Отложенное (deferred) выполнение по умолчанию.
              Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer (описан в главе Скрипты: async, defer). Это верно и для внешних и встроенных скриптов-модулей.
                Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.
                -загрузка внешних модулей, таких как <script type="module" src="...">, не блокирует обработку HTML.
                -модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.
                -сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
            -Атрибут async работает во встроенных скриптах.
            -Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
            -Дублирующиеся внешние скрипты игнорируются.
        2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
          Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
          Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.
          Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.
        3. В модулях всегда включена директива use strict.
        4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.
          Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
          📁 alert.js
          alert("Модуль выполнен!");

          Импорт одного и того же модуля в разных файлах
          📁 1.js
          import `./alert.js`; // Модуль выполнен!
          📁 2.js
          import `./alert.js`; // (ничего не покажет)
          На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.
          Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте admin, то другие модули тоже увидят эти изменения.
          Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.
        В модуле «this» не определён
        Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.
      Экспорт
        -Экспорт до объявления
          export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        -Экспорт отдельно от объявления 
          Также можно написать export отдельно. export {sayHi, sayBye}; // список экспортируемых переменных
        -Экспортировать «как» export {sayHi as hi, sayBye as bye}; Теперь hi и bye – официальные имена для внешнего кода, их нужно использовать при импорте:
        -Экспорт по умолчанию
          На практике модули встречаются в основном одного из двух типов:
            -Модуль, содержащий библиотеку или набор функций, как say.js выше.
            -Модуль, который объявляет что-то одно, например модуль user.js экспортирует только class User. (default export)
          export default class User {} Заметим, в файле может быть не более одного export default. …И потом импортируем без фигурных скобок: import User from './user.js'; // не {User}, просто User
          Так как в файле может быть максимум один export default, то экспортируемая сущность не обязана иметь имя.
            экспортируем значение, не создавая переменную export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; Это нормально, потому что может быть только один export default на файл, так что import без фигурных скобок всегда знает, что импортировать.
          Имя «default»
            чтобы экспортировать функцию отдельно от её объявления: export {sayHi as default};
      Импорт
        Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так: import {sayHi, sayBye} from './say.js';
        Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например: import * as say from './say.js'; 
          1. Предположим, мы добавили в наш проект стороннюю библиотеку say.js с множеством функций: Теперь, если из этой библиотеки в проекте мы используем только одну функцию:
            …Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
          2. Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: sayHi() вместо say.sayHi().
          3. Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.
        Импорт «как» 
          Мы также можем использовать as, чтобы импортировать под другими именами. import {sayHi as hi, sayBye as bye} from './say.js';
  +Spread rest operator
    ?Know how to use spread operator for Function arguments
      Остаточные параметры (Rest parameters)
        Остаточные параметры предоставляют нам массив неопределённых аргументов. В примере мы используем остаточные параметры, чтобы собрать аргументы с индексами со 2-го до последнего. 
        Затем мы умножим каждый из них на значение первого аргумента. 
        */
        function multiply(multiplier, ...theArgs) {
          return theArgs.map(x => multiplier * x);
        }
        
        var arr = multiply(2, 1, 2, 3);
        console.log(arr); // [2, 4, 6]
        /*
    ?Be able to compare arguments and rest parameters
      Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments. Этот способ всё ещё работает, мы можем найти его в старом коде.
      Но у него есть один недостаток. Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).
      К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.
      Соответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.
      Стрелочные функции не имеют "arguments"
    ?Spread operator for Array
      Оператор расширения
        Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное. Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.
        Для Math.max:
        */
        let arr = [3, 5, 1];
        alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
        // Мы даже можем комбинировать оператор расширения с обычными значениями:
        let arr1 = [1, -2, 3, 4];
        let arr2 = [8, 3, -8, 1];
              
        alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
        /*
    ?Understand and able to use spread operator for Array concatenation Destructuring assignment
      Оператор расширения можно использовать и для слияния массивов:
      */
      let arr = [3, 5, 1];
      let arr3 = [8, 9, 15];
      let merged = [0, ...arr, 2, ...arr3]; // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
      /*
      В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.
      Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:
      */
      let str = "Привет";
      alert( [...str] ); // П,р,и,в,е,т
      /*
      Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, чтобы перебирать элементы. Так же, как это делает for..of.
      Цикл for..of перебирает строку как последовательность символов, поэтому из ...str получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи стандартного объявления массива: [...str].
      Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив: Array.from(str)
        Но между Array.from(obj) и [...obj] есть разница: 
          -Array.from работает как с псевдомассивами, так и с итерируемыми объектами 
          -Оператор расширения работает только с итерируемыми объектами
      Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.
        Как отличить их друг от друга:
          Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
          Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
    ?Be able to discover destructuring assignment concept
      Деструктурирующее присваивание
          Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.
          Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
        Деструктуризация массива
          у нас есть массив с именем и фамилией let arr = ["Ilya", "Kantor"] деструктурирующее присваивание записывает firstName = arr[0]  и surname = arr[1] let [firstName, surname] = arr;
          Отлично смотрится в сочетании со split или другими методами, возвращающими массив: let [firstName, surname] = "Ilya Kantor".split(' ');
          -Деструктуризация» не означает «разрушение».
            «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.
            Это просто короткий вариант записи: let firstName = arr[0]; let surname = arr[1];
          -Пропускайте элементы, используя запятые: 
            Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой: let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
          -Работает с любым перебираемым объектом с правой стороны
            На самом деле мы можем использовать любой перебираемый объект, не только массивы: let [a, b, c] = "abc";  let [one, two, three] = new Set([1, 2, 3]);
          -Присваивайте чему угодно с левой стороны
            Мы можем использовать что угодно «присваивающее» с левой стороны. Например, можно присвоить свойству объекта: let user = {}; [user.name, user.surname] = "Ilya Kantor".split(' ');
          -Цикл с .entries()
            Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:
            */
            let user = {
              name: "John",
              age: 30
            };
            
            // цикл по ключам и значениям
            for (let [key, value] of Object.entries(user)) {
              alert(`${key}:${value}`); // name:John, затем age:30
            }
            /*
          -Трюк обмена переменных
            Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего присваивания: 
              let guest = "Jane"; let admin = "Pete"; [guest, admin] = [admin, guest];
              Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.Таким образом, мы можем поменять местами даже более двух переменных.
          -Остаточные параметры «…»
            Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):
            let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]; Переменная rest является массивом из оставшихся элементов.
          -Значения по умолчанию
            Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:
            Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =: let [name = "Guest", surname = "Anonymous"] = ["Julius"];
            Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют. let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
        Деструктуризация объекта
          let {var1, var2} = {var1:…, var2:…} У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}. 
              let {title, width, height} = options; Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения.
            -Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
              Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие: let {width: w, height: h, title} = options; // width -> w // height -> h // title -> title
              Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.
            -Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь: let {width = 100, height = 200, title} = options;
              Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.
            -Мы также можем совмещать : и =:
              let {width: w = 100, height: h = 200, title} = options;
          -Остаток объекта «…»
            Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
            let options = {
              title: "Menu",
              height: 200,
              width: 100
            };
            let {title, ...rest} = options;
            сейчас title="Menu", rest={height: 200, width: 100}
              В примерах выше переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох.
                Вот так не будет работать:
                  let title, width, height;
                  {title, width, height} = {title: "Menu", width: 200, height: 100};
                  Проблема в том, что JavaScript обрабатывает {...} в основном потоке кода (не внутри другого выражения) как блок кода. Такие блоки кода могут быть использованы для группировки операторов.
                  Так что здесь JavaScript считает, что видит блок кода, отсюда и ошибка. На самом-то деле у нас деструктуризация.  Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки (...):
                  ({title, width, height} = {title: "Menu", width: 200, height: 100});
          -Вложенная деструктуризация
            Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.
        Умные параметры функций
          Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов.  На помощь приходит деструктуризация!
          Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
            */
              // мы передаём объект в функцию
              let options = {
                title: "My menu",
                items: ["Item1", "Item2"]
              };

              // ...и она немедленно извлекает свойства в переменные
              function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
                // title, items – взято из options,
                // width, height – используются значения по умолчанию
                alert( `${title} ${width} ${height}` ); // My Menu 200 100
                alert( items ); // Item1, Item2
              }

              showMenu(options);
            /*
            Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
            showMenu({}); // ок, все значения - по умолчанию  showMenu(); // так была бы ошибка
            Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {}
            В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.
    ?Understand variables and Function arguments destructuring assignment
      См выше
  +String templates
      Шаблонные строки
        Шаблонные строки — это ещё один способ создания строк, наравне с одинарными или двойными кавычками. Шаблонные строки объявляются с помощью обратных кавычек.
        Шаблонная строка может быть многострочной, все переносы строк в ней будут сохранены. В шаблонной строке с помощью синтаксиса ${ } можно использовать любые выражения JavaScript. Любой нестроковый результат (например, объект) будет приведён к строке.
        `строка текста ${выражение} строка текста`
      Экранирование символов
        const doubleQuotes = "\"Я вам запрещаю!\" – Джейсон Стэтхем." => const doubleQuotes = `"Я вам запрещаю!" – Джейсон Стэтхем.`
      Переносы строк Секция статьи "Переносы строк"
        const str = 'Я первая строка\n' + 'А я вторая строка\n' + 'Ну и так далее'
        Выглядит не очень удобно, даже если записать их на отдельных строках в редакторе. В шаблонных строках можно делать переносы строк, как в обычном тексте, и все они сохранятся.
        В этой строке будут так же сохранены все пробелы и табуляции в начале строк. Это может быть удобно для написания html-разметки в строке.
      Динамические строки
        В обычных строках, чтобы подставить значение в строку, необходимо использовать конкатенацию через оператор +. const url = 'https://' + host + '/?search=' + query
        В итоге получается нужная нам строка, но для каждого такого динамического значения необходимо явно добавлять оператор сложения + и дробить строку на части, если между динамическими частями есть статические.
        const url = `https://${host}/?search=${query}`
      Будьте осторожны при написании HTML внутри шаблонных строк. Шаблонные строки, так же как и обычные, не экранируют спецсимволы. Это значит что использование ненадёжного HTML из шаблонной строки может привести к различным атакам.
  +Know how for..of loop works (optional)
      Оператор for...of относится к типу оператора for, который циклически повторяет итерируемые объекты ( iterable objects)), пока не достигнет конца строки. for(let a of arr) {log(a)}
        Цикл for...of через массив arr выполнен с меньшим количеством кода, чем при использовании цикла for.
      Итерируемые объекты и итераторы
        По словам разработчика Mozilla, “Благодаря итерируемому протоколу объекты JavaScript могут определять или настраивать поведение итерации, например, какие значения повторяются циклически в конструкции for..of.” и “чтобы быть итерируемым, 
        объект реализует метод @@iterator, означающий, что объект (или один из объектов в цепочке прототипов) должен иметь свойство с ключом @@iterator, которое доступно через константу Symbol.iterator.”
        Протокол Iterator определяет способ, с помощью которого поток значений возвращается из объекта. Итератор реализует метод next. Метод next обладает следующим рядом правил:
          -Он должен возвращать объект со свойствами done, value {done, value}
          -done относится к типу Boolean и указывает на достижение конца потока.
          -value содержит значение текущего цикла.
      Примеры итерируемых объектов:  (String Map TypedArray Array Set Generator) Объект не является итерируемым. Чтобы сделать его итерируемым, необходимо реализовать метод Symbol.iterator.
  +Advanced Functions
    +this scope
      В JavaScript this — это текущий контекст исполнения функции. Поскольку функцию можно вызвать четырьмя способами:
        -вызов функции: alert('Hello World!'),
        -вызов метода: console.log('Hello World!'),
        -вызов конструктора: new RegExp('\\d'),
        -непрямой вызов: alert.call(undefined, 'Hello World!'),
        и каждый из них определяет свой контекст. Кроме того, strict mode также влияет на контекст исполнения.
      Прежде чем мы начнём, давайте познакомимся с несколькими терминами:
        -Вызов — это исполнение кода тела функции. Например, вызовом функции parseInt будет parseInt('15').
        -Контекстом вызова является значение this в теле функции.
        -Область видимости функции — это набор переменных, объектов и функций, к которым можно получить доступ из тела функции.
      Вызов функции
        Вызов функции совершается, когда за выражением, являющимся объектом функции, следуют открывающая скобка (, разделённый запятыми список аргументов и закрывающая скобка ), например, parseInt('18').
        Выражение не может быть аксессором myObject.myFunction, который совершает вызов метода. Например, [1,5].join(',') — это вызов не функции, а метода.
        this при вызове функции
          this — это глобальный объект при вызове функции. Глобальный объект определяется средой исполнения. В веб-браузере это объект window. В вызове функции контекстом исполнения является глобальный объект.
          Когда this используется вне области видимости какой-либо функции (самая внешняя область видимости: контекст глобального исполнения), он также относится к глобальному объекту: console.log(this === window); // => true
        this при вызове функции в strict mode
          Strict mode был введён в ECMAScript 5.1 и представляет собой более надёжную систему защиты и проверки ошибок. Этот режим влияет на контекст исполнения, заставляя this быть undefined. Контекст исполнения перестаёт быть глобальным объектом, в отличие от предыдущего случая.
          Strict mode активен не только в текущей области видимости, но и во всех вложенных: 
          Один файл JavaScript может содержать как «строгие», так и «нестрогие» функции. Поэтому возможно иметь в одном скрипте разные контексты исполнения для одного типа вызова:
        Ловушка: this во внутренней функции
          Обычной ошибкой при работе с вызовом функции является уверенность в том, что this во внутренней функции такой же, как и во внешней. Вообще-то контекст внутренней функции зависит только от вызова, а не от контекста внешней функции.
          Чтобы получить ожидаемый this, модифицируйте контекст внутренней функции при помощи непрямого вызова (используя .call() или .apply(), об этом позже) или создайте связанную функцию (используя .bind(), об этом тоже поговорим позже).
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                // this is window or undefined in strict mode
                console.log(this === numbers); // => false
                return this.numberA + this.numberB;
              }
              return calculate();
            }
          };
         console.log(numbers.sum()); // => NaN or throws TypeError in strict mode
          /*
          numbers.sum() — это вызов метода объекта, поэтому контекстом sum является объект numbers. Функция calculate определена внутри sum, поэтому вы можете ожидать, что this — это объект numbers и в calculate(). 
          Тем не менее, calculate() — это вызов функции, а не метода, и поэтому его this — это глобальный объект window или undefined в strict mode. Даже если контекстом внешней функции sum является объект numbers, у него здесь нет власти.
          Для решения проблемы функция calculate должна быть исполнена в том же контексте, что и метод sum, чтобы получить доступ к значениям numberA и numberB. Это можно сделать при помощи метода .call():
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                console.log(this === numbers); // => true
                return this.numberA + this.numberB;
              }
              // use .call() method to modify the context
              return calculate.call(this);
            }
          };
         console.log(numbers.sum()); // => 15
          /* calculate.call(this) исполняет функцию calculate, но дополнительно модифицирует контекст в соответствии с первым параметром.
        Вызов метода
          Метод — это функция, хранящаяся в объекте. helloFunction — это метод в myObject. Для доступа к методу нужно использовать аксессор: myObject.helloFunction.
          Вызов метода совершается, когда за выражением в виде аксессора, расценивающемся как объект функции, следует пара скобок и разделенный запятыми список аргументов между ними.
          В прошлом примере myObject.helloFunction() — это вызов метода helloFunction объекта myObject. Также вызовами метода являются: [1, 2].join(',') или /\s/.test('beautiful world').
          Важно отличать вызов функции от вызова метода. Главным отличием является то, что для вызова метода необходим аксессор (<expression>.functionProperty() или <expression>['functionProperty']()), а для вызова функции — нет (<expression>()).
          this при вызове метода
            this — это объект, которому принадлежит метод. При вызове метода, принадлежащего объекту, this становится этим объектом.
            Вызов calc.increment() сделает контекстом функции increment объект calc. Поэтому можно спокойно использовать this.num.
            Объект JavaScript наследует метод своего прототипа. Когда вызывается метод, унаследованный от объекта, контекстом всё равно является сам объект:
            */
            var myDog = Object.create({
              sayName: function() {
                 console.log(this === myDog); // => true
                  return this.name;
              }
            });
            myDog.name = 'Milo';
            // method invocation. this is myDog
            console.log(myDog.sayName()); // => 'Milo'
            /*
            Object.create() создаёт новый объект myDog и создаёт прототип. Объект myDog наследует метод sayName. Когда исполняется myDog.sayName(), myDog является контекстом исполнения.
            В синтаксисе ECMAScript 6 class контекст вызова метода — тоже сам объект:
           */
            class Planet {
              constructor(name) {
                this.name = name;
              }
              getName() {
                console.log(this === earth); // => true
                return this.name;
              }
            }
            var earth = new Planet('Earth');
            // method invocation. the context is earth
            console.log(earth.getName()); // => 'Earth'
            /*
          Ловушка: отделение метода от его объекта
            Метод объекта можно переместить в отдельную переменную. При вызове метода с использованием этой переменной вы можете подумать, что this — это объект, в котором определён метод.
            На самом деле, если метод вызван без объекта, происходит вызов функции, и this становится глобальным объектом window или undefined. Создание связанной функции исправляет контекст — им становится объект, в котором содержится метод.
            Следующий пример создаёт конструктор Animal и его экземпляр — myCat. Затем через 1 секунду setTimeout() логирует информацию об объекте myCat:
            */
            function Animal(type, legs) {
              this.type = type;
              this.legs = legs;
              this.logInfo = function() {
                console.log(this === myCat); // => false
                console.log('The ' + this.type + ' has ' + this.legs + ' legs');
              };
            }
            var myCat = new Animal('Cat', 4);
            // logs "The undefined has undefined legs"
            // or throws a TypeError, in strict mode
            setTimeout(myCat.logInfo, 1000); // setTimeout(myCat.logInfo.bind(myCat), 1000);
            /*
            Вы можете подумать, что setTimeout вызовет myCat.logInfo(), которая запишет информацию об объекте myCat. Но метод отделяется от объекта, когда передаётся в качестве параметра: setTimout(myCat.logInfo), и через секунду происходит вызов функции.
            Когда logInfo вызывается как функция, this становится глобальным объектом или undefined (но не объектом myCat), поэтому информация об объекте выводится некорректно. 
            myCat.logInfo.bind(myCat) возвращает новую функцию, исполняемую в точности как logInfo, но this которой остаётся myCat даже в случае вызова функции.
          Вызов конструктора
            Вызов конструктора совершается, когда за ключевым словом new следует выражение, расцениваемое как объект функции, и пара скобок с разделённым запятыми списком аргументов. Пример: new RegExp('\\d').
            В этом примере объявляется функция Country, которая затем вызывается в качестве конструктора:
            */
            function Country(name, traveled) {
              this.name = name ? name : 'United Kingdom';
              this.traveled = Boolean(traveled); // transform to a boolean
            }
            Country.prototype.travel = function() {
              this.traveled = true;
            };
           // Constructor invocation
            var france = new Country('France', false);
           // Constructor invocation
            var unitedKingdom = new Country;
            
           france.travel(); // Travel to France
            /*
            new Country('France', false) — это вызов конструктора функции Country. Результатом исполнения является новые объект, чьё поле name равняется 'France'. Если конструктор вызван без аргументов, скобки можно опустить: new Country.
            Начиная с ECMAScript 6, JavaScript позволяет определять конструкторы ключевым словом class.
            */
            class City {
              constructor(name, traveled) {
                this.name = name;
                this.traveled = false;
              }
              travel() {
                this.traveled = true;
              }
            }
            // Constructor invocation
            var paris = new City('Paris', false);
            paris.travel();
            /*
            new City('Paris') — это вызов конструктора. Инициализация объекта управляется специальным методом класса: constructor, this которого является только что созданным объектом.
            Вызов конструктора создаёт новый пустой объект, наследующий свойства от прототипа конструктора. Ролью функции-конструктора является инициализация объекта. Как вы уже знаете, контекст этого типа вызова называется экземпляром.
            Когда перед аксессором myObject.myFunction идёт ключевое слово new, JavaScript совершит вызов конструктора, а не метода. Возьмём в качестве примера new myObject.myFunction(): 
            сперва при помощи аксессора extractedFunction = myObject.myFunction функция извлекается, а затем вызывается как конструктор для создания нового объекта: new extractedFunction().
            this в вызове конструктора
              this — это только что созданный объект. Контекстом вызова конструктора является только что созданный объект. Он используется для инициализации объекта данными из аргументом функции-конструктора.
              Когда исполняется new Dog(), JavaScript создаёт пустой объект и делает его контекстом метода constructor. Теперь вы можете добавлять свойства, используя this: this.property = 'Default Value'.
          Непрямой вызов
            Непрямой вызов производится, когда функция вызывается методами .call() или .apply(). Функции в JavaScript — объекты первого класса, то есть функция — это объект типа Function.
            Из списка методов этой функции два, .call() и .apply(), используются для вызова функции с настраиваемым контекстом:
              -Метод .call(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова, а список аргументов arg1, arg2, ... передаётся вызываемой функции.
              -Метод .apply(thisArg, [args]) принимает в качестве первого аргумента thisArg контекст вызова, а array-like объект [args] передаётся вызываемой функции в качестве аргумента.
              */
              function increment(number) {
                return ++number;
              }
              console.log(increment.call(undefined, 10));    // => 11
              console.log(increment.apply(undefined, [10])); // => 11
              /*
              increment.call() и increment.apply() оба вызывают функцию-инкремент с аргументом 10. Главным отличием между ними является то, что .call() принимает список аргументов, 
              например, myFunction.call(thisValue, 'value1', 'value2'), а .apply() принимает эти значения в виде array-like объекта: myFunction.apply(thisValue, ['value1', 'value2']).
              this при непрямом вызове
                this — это первый аргумент .call() или .apply()
              Непрямой вызов может пригодиться, когда функцию нужно вызвать в особом контексте, например, решить проблему при вызове функции, где this — всегда window или undefined. Его также можно использовать для симуляции вызова метода объекта.
          Связанная функция
            Связанная функция — это функция, связанная с объектом. Обычно она создаётся из обычной функции при помощи метода .bind(). У двух функций совпадают тела и области видимости, но различаются контексты.
            Метод .bind(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова связанной функции, а необязательный список аргументов arg1, arg2, ... передаётся вызываемой функции. Он возвращает новую функцию, связанную с thisArg.
            Следующий код создаёт связанную функцию и вызывает её:
            */ 
            function multiply(number) {
              'use strict';
              return this * number;
            }
            // create a bound function with context
            var double = multiply.bind(2);
            // invoke the bound function
            console.log(double(3));  // => 6
            console.log(double(10)); // => 20
            /*
            multiply.bind(2) возвращает новый объект функции double, который связан с числом 2. Код и область видимости у multiply и double совпадают. В отличие от методов .apply() и .call(), сразу вызывающих функцию, метод .bind() возвращает новую функцию, которую впоследствии нужно будет вызвать с уже заданным this.
            this в связанной функции
              this — это первый аргумент .bind() Ролью .bind() является создание новой функции, чей вызов будет иметь контекст, заданный в первом аргументе .bind(). Это — мощный инструмент, позволяющий создавать функции с заранее определённым значением this.
              */
              var numbers = {
                array: [3, 5, 10],
                getNumbers: function() {
                  return this.array;
                }
              };
              // Create a bound function
              var boundGetNumbers = numbers.getNumbers.bind(numbers);
              console.log(boundGetNumbers()); // => [3, 5, 10]
              // Extract method from object
              var simpleGetNumbers = numbers.getNumbers;
              console.log(simpleGetNumbers()); // => undefined or throws an error in strict mode
              /*
              numbers.getNumbers.bind(numbers) возвращает функцию boundGetNumbers, которая связана с объектом numbers. Затем boundGetNumbers() вызывается с this, равным numbers, и возвращает корректный объект.
          Стрелочная функция
            Стрелочная функция не создаёт свой контекст исполнения, а заимствует this из внешней функции, в которой она определена. 
            */
            class Point {
              constructor(x, y) {
                this.x = x;
                this.y = y;
              }
              log() {
                console.log(this === myPoint);
                setTimeout(()=> {
                  console.log(this === myPoint);      // => true
                  console.log(this.x + ':' + this.y); // => '95:165'
                }, 1000);
              }
            }
            var myPoint = new Point(95, 165);
            myPoint.log();
            /*
            setTimeout вызывает стрелочную функцию в том же контексте (метод myPoint), что и метод log(). Как мы видим, стрелочная функция «наследует» контекст той функции, в которой определена.
            Если попробовать использовать в этом примере обычную функцию, она создаст свой контекст (window или undefined). Поэтому для того, чтобы код работал корректно, нужно вручную привязать контекст: setTimeout(function() {...}.bind(this)). Это громоздко, поэтому проще использовать стрелочную функцию.
            Если стрелочная функция определена вне всех функций, её контекст — глобальный объект. Стрелочная функция связывается с лексическим контекстом раз и навсегда. this нельзя изменить даже при помощи метод смены контекста:
            Ловушка: определение метода стрелочной функцией
              Вы можете захотеть использовать стрелочную функцию для объявления метода. Справедливо: их объявления гораздо короче по сравнению с обычным выражением: (param) => {...} вместо function(param) {..}.
              Так как format — стрелочная функция, определённая в глобальном контексте, её this — это объект window. Даже если format исполняется в качестве метода объекта walkPeriod.format(), window остаётся контекстом вызова. Так происходит, потому что стрелочная функция имеет статический контекст, не изменяемый другими типами вызовов.
              this — это window, поэтому this.hours и this.minutes становятся undefined. Метод возвращает строку 'undefined hours and undefined minutes', что не является желаемым результатом.
          Заключение 
            Поскольку вызов функции имеет наибольшее влияние на this, отныне не спрашивайте: Откуда берется this?  а спрашивайте: Как функция вызывается? А в случае со стрелочной функцией спросите: Каков this там, где объявлена стрелочная функция?
    ?Reference Type & losing this
    ?Understand difference between function and method
    ?Understand how this works, realize this possible issues
    ?Manage this scope
    ?Be able to replace this scope
    ?Be able to use call and apply Function built-in methods

  +Functional Patterns
    ?Immediately invoked functional expression (IIFE) (optional)
      В прошлом в JavaScript не было лексического окружения на уровне блоков кода.
        Function Expression обёрнуто в скобки (function {...}), потому что, когда JavaScript встречает "function" в основном потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, так что такой код вызовет ошибку:
        Даже если мы скажем: «хорошо, давайте добавим имя», – это не сработает, потому что JavaScript не позволяет вызывать Function Declaration немедленно.
        Так что скобки вокруг функции – это трюк, который позволяет показать JavaScript, что функция была создана в контексте другого выражения, и, таким образом, это функциональное выражение: ей не нужно имя и её можно вызвать немедленно.
        */
        // Пути создания IIFE
        (function() {
          console.log("Скобки вокруг функции");
        })();

        (function() {
          console.log("Скобки вокруг всего");
        }());

        !function() {
          console.log("Выражение начинается с логического оператора NOT");
        }();

        +function() {
          console.log("Выражение начинается с унарного плюса");
        }();
        /*
      IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.
        const r = (function () {
        statements
        })();
        Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. 
        Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
        Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.
      Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.
      Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.
      */
      var result = (function () {
        var name = "Barry";
        return name;
      })();
      // Immediately creates the output:
      result; // "Barry"
      /*
    ?Know IIFE pattern (optional)
      Управлять областью видимости переменных в JavaScript можно, пользуясь паттерном «Модуль». Для того чтобы создать приватную область видимости, можно воспользоваться замыканием. Как известно, функции создают собственные области видимости, содержимое которых отделено от глобальной области видимости:
        (function () {
         // здесь находится приватная область видимости
        })();
        Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции (как, впрочем, и внутри других функций) создаётся приватная область видимости, недоступная извне. 
        То есть, если объявить внутри этой области видимости другую функцию, то, после того, как IIFE выполнится, доступ к ней получить не удастся.
      Как сделать так, чтобы к функции, объявленной внутри другой функции, всё же, можно было бы обратиться? Собственно говоря, то, о чём мы сейчас будем говорить, и есть паттерн «Модуль». Рассмотрим следующий пример.
      Объект, возвращаемый из IIFE — это обычный объект, у которого может быть множество методов и свойств. Они формируют общедоступный интерфейс или API модуля.
      */
      // Объявим модуль
      var Module = (function () {
        return {
          myMethod: function () {
          
          },
          someOtherMethod: function () {
          
          }
        };
      })();
      
      // Вызовем функцию как метод объекта
      Module.myMethod();
      Module.someOtherMethod();
      /*
    ?Callback (Function as argument)
      Фу́нкция вы́сшего поря́дка — в программировании функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. 
      Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных. Использование функций высшего порядка приводит к абстрактным и компактным программам, принимая во внимание сложность производимых ими вычислений.[1]
      Функции — это объекты
        Чтобы понимать callback-функции, нужно понимать обычные функции. Это может показаться банальностью, но функции в Javascript'е — немного странные штуки.
        Функции в Javascript'е — на самом деле объекты. А именно, объекты класса Function, создаваемые конструктором Function. В объекте Function содержится строка с JS-кодом данной функции. 
        Если вы перешли с языка C или Java, это может показаться странным (как код может быть строкой?!), но, вообще говоря, в Javascript'е такое сплошь и рядом. Различие между кодом и данными иногда размывается.
        Преимущество концепции «функция-как-объект» заключается в том, что код можно передавать в другую функцию точно так же, как обычную переменную или объект (потому что в буквальном понимании код — всего лишь объект).
        Вместо того чтобы дожидаться, пока функция закончит выполняться и вернёт значение, мы можем использовать callback-функции, чтобы получить его асинхронно. Это полезно для случаев, когда требуется много времени для завершения, например, при AJAX-запросах, ведь мы не можем приостановить браузер.
    ?Know callback pattern
    ?Understand callback limitations (callback hell) (optional)
      Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо ... у нас код, содержащий другие цепочки вызовов, условия и т.д. Иногда это называют «адом колбэков» или «адской пирамидой колбэков».
    ?Binding, binding one function twice
      bind returns a new function which keeps the context of the original function intact when called. In essence it does this:
      */
      function bind(originalFunction, context) {
        return function () {
            originalFunction.call(context);
        };
      }
      /*
    ?Know how to bind this scope to function
      */
    let user55 = {
      firstName: "Вася"
    };
    
    function func() {
      alert(this.firstName);
    }
    
    let funcUser = func.bind(user55);
    funcUser(); // Вася
    /*
    Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user. Все аргументы передаются исходному методу func как есть
    ?Carrying and partial functions
      Каррирование – продвинутая техника для работы с функциями. Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
        Каррирование не вызывает функцию. Оно просто трансформирует её.
        */
        function curry(fn) {
          return function rememberFirstArg(a) {
            return function rememberSecondArg(b) {
              return fn(a, b)
            }
          }
        }
        
        const curriedMultiply = curry(multiply)
        
        // multiply(2, 10)
        // curriedMultiply(2)(10)
        /*
        Как вы видите, реализация довольна проста: это две обёртки.
        Результат curry(func) – обёртка function(a).
        Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
        Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.
      Вроде просто, но если аргументов будет больше 2, то придётся добавлять ещё одну обёртку. Поэтому лучше посчитать количество аргументов и автоматизировать создание обёрток:
        */function curry(func) {
          return function curried(...args) {
            if (args.length >= func.length) {
              return func.apply(this, args)
            }
          
            return function continueCurrying(...args2) {
              return curried.apply(this, args.concat(args2))
            }
          }
        }
        const curriedMultiply1 = curry(multiply)

        const double = curriedMultiply1(2)
        // [Function: continueCurrying]

        const result = curriedMultiply1(2, 10)
        // 20
        /*
        В примере выше мы проверяем, закончились ли аргументы. Если закончились, то передаём их все в оригинальную функцию и вызываем её. Если аргументы ещё есть, то используем рекурсию, чтобы каррировать ещё раз.
      Что такое каррирование? 
        Каррированная функция - это функция, которая может принимать несколько аргументов, но по одному за раз. Способность принимать по одному аргументу за раз, называется унарностью. Унарность, это обязательное свойство каррированных функций.
      Что такое частичное применение?
        Частичное применение - это функция, которая принимает за раз столько аргументов, сколько пожелает, но не все. Все каррированные функции возвращают частичное применение, для хранения введенных аргументов.
        */
        const add = x => y => x + y;
        const inc10 = add(10);
        const inc20 = add(20);

        inc10(3); // => 13
        inc20(3); // => 23
        /*
  +Closures Advanced
    https://learn.javascript.ru/closure#leksicheskoe-okruzhenie
    ?Context (lexical environment) 
    Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript, все функции изначально являются замыканиями.
      То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным. Рассказать как работает лексическое окружение
    «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую
          */
          function makeWorker() {
            let name = "Pete";

            return function() {
              alert(name);
            };
          }
          
          let name = "John";
          
          // create a function
          let work = makeWorker();
          
          // call it
          work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)
          /* ответ - "Pete" 
          Лексическое Окружение
            Чтобы понять, что происходит, давайте для начала обсудим, что такое «переменная» на самом деле.
            В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
            Объект лексического окружения состоит из двух частей:
              -Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
              -Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
            "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».
          Один вызов – одно лексическое окружение 
            Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. 
            И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
        Окружение в деталях
          */
        function makeCounter() {
          let count = 0;
          return function() {
            return count++;
          };
        }
        
        let counter1 = makeCounter();
        let counter2 = makeCounter();
        
        alert( counter1() ); // 0
        alert( counter1() ); // 1
        
        alert( counter2() ); // 0 (независимо)
        /*
        1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение: В этот начальный момент есть только функция makeCounter, потому что это Function Declaration. Она ещё не выполняется.
          Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
          В данном случае, makeCounter создан в глобальном лексическом окружении, так что [[Environment]] содержит ссылку на него.
        2. Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается результат вызова makeCounter.
          В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов.
          Как и все лексические окружения, оно содержит две вещи:
            -Environment Record с локальными переменными. В нашем случае count – единственная локальная переменная (появляющаяся, когда выполняется строчка с let count).
            -Ссылка на внешнее окружение, которая устанавливается в значение [[Environment]] функции. В данном случае, [[Environment]] функции makeCounter ссылается на глобальное лексическое окружение.
          Итак, теперь у нас есть два лексических окружения: первое – глобальное, второе – для текущего вызова makeCounter, с внешней ссылкой на глобальный объект.
        3. В процессе выполнения makeCounter() создаётся небольшая вложенная функция.  Для нашей новой вложенной функции значением [[Environment]] будет текущее лексическое окружение makeCounter() (где она была создана):
            Пожалуйста, обратите внимание, что на этом шаге внутренняя функция была создана, но ещё не вызвана. Код внутри function() { return count++ } не выполняется.
        4. Выполнение продолжается, вызов makeCounter() завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной counter:
        5. При вызове counter() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом counter локальных переменных нет.
            Но [[Environment]] counter используется, как ссылка на внешнее лексическое окружение outer, которое даёт доступ к переменным предшествующего вызова makeCounter, где counter был создан.
            Теперь, когда вызов ищет переменную count, он сначала ищет в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова makeCounter(), где и находит её.
            Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя makeCounter() закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с [[Environment]], который ссылается на него.
        Предыдущие примеры сосредоточены на функциях. Но лексическое окружение существует для любых блоков кода {...}.
          Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.
    ?Understand function creation context (lexical environment)
      Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.  это то, каким образом функции знают, где они были созданы.
    ?Be able to explain difference between scope and context
      Scope – область видимости. Область видимости определяет, есть ли у вас доступ к переменной. До введения let и const область видимости в JavaScript определялась функцией (у var функциональная область видимости). Переменные объявленные вне функции записывались в глобальную область видимости.
      Context – контекст выполнения (this) Контекст описывает окружение в котором выполняется код (любой код имеет контекст выполнения). В каждый момент времени только один контекст выполнения выполняет код. Несколько популярных видов контекста:
        -Global контекст 
        -Function контекст
        -Стрелочные функции
        -В методе объекта
        -В конструкторе
        -В методах call, apply и bind
        В браузере:
        -Как обработчик событий DOM 
        -В инлайновом обработчике событий
      Одна и та же функция может быть вызвана с разным контекстом. Контекстом еще часто называют значение переменной this внутри функции.  Значение переменной this чаще всего определяется тем, как вызывается функция. 
    ?Inner/outer lexical environment
      У внутреннего лексического окружения есть ссылка outer на внешнее. Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального. 
      Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
    ?Understand lexical environment traversing mechanism
    ?Understand connection between function and lexical environment

  +Date & time (optional)
    ?Date object
    ?Date methods, props
      Дата - Создаёт экземпляр объекта Date, представляющего собой момент времени. Объект Дата содержит число миллисекунд прошедших с 1 января 1970 г. UTC. Он содержит дату и время, а также предоставляет методы управления ими.
      Создание:
        Для создания нового объекта Date нужно вызвать конструктор new Date() с одним из следующих аргументов:
          -new Date() - Без аргументов – создать объект Date с текущими датой и временем.
          -new Date(milliseconds) - Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0. Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp). 
            Датам до 1 января 1970 будут соответствовать отрицательные таймстампы //* let Dec31_1969 = new Date(-24 * 3600 * 1000); 31 декабря 1969 года
          -new Date(datestring) - Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в Date.parse //* let date = new Date("2017-01-26");
          -new Date(year, month, date, hours, minutes, seconds, ms) - Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента. //* new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
            --year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
            --month начинается с 0 (январь) по 11 (декабрь).
            --Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
            --Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
      Получение компонентов даты: Существуют методы получения года, месяца и т.д. из объекта Date
        -getFullYear() Получить год (4 цифры)
        -getMonth() Получить месяц (0-11)
        -getDate() Получить день месяца (1-31)
        -getHours(), getMinutes(), getSeconds(), getMilliseconds() - Получить, соответственно, часы, минуты, секунды или миллисекунды.
        -getDay() Получить день недели (0-6, в зависимости от начала недели)
          Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом. Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".
            let date = new Date(); getUTCHours() 7:00 UTC+0  getHours() 10:00 UTC+3
        -getTime() Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
        -getTimezoneOffset() Возвращает разницу между местным и UTC часовым поясом в минутах. 
      Установка компонентов даты:
        -setFullYear(year [, month, date]) Установить год (4 цифры)
        -setMonth(month [, date]) Установить месяц (0-11)
        -setDate(date) Установить день месяца (1-31)
        -setHours(hours [, minutes, seconds, ms]) Установить часы (0-23)
        -setMinutes(minutes [, seconds, ms]) Установить минуты (0-59)
        -setSeconds(seconds [, ms]) Установить секунды (0-59)
        -setMilliseconds(ms) Установить миллисекунды (0-999)
        -setTime(time) Установить дату и время в миллисекундах от 1 января 1970 года UTC+0.
        У всех этих методов, кроме setTime(), есть UTC-вариант
      Автоисправление даты:
        Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит. //* let date = new Date(2013, 0, 32); 1 Mar 2016
      Преобразование к числу, разность дат:
        Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime() console.log(+date):
          Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах. Этот приём можно использовать для измерения времени.
      Date.now()
        Если нужно просто измерить время, объект Date нам не нужен. Существует особый метод Date.now(), возвращающий текущую метку времени. Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.
          Вероятно, предыдущий пример лучше переписать так: let start = Date.now(); let end = Date.now(); console.log(end - start);
      Разбор строки с датой
        Метод Date.parse(str) считывает дату из строки. Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ. Пример: "2016-03-01T12:00:00.000Z". Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.
        Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.
        Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN.

    +Advanced Expressions
    ?Hoisting
      Смысл поднятия в том, что переменные переносятся из места объявления в коде в верх их области видимости. Это механизм относится только к объявлению функций и переменных.
        -Одним из преимуществ помещения в память объявлений функций до выполнения кода то, что можно использовать функцию до её объявления. Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.
        -JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после её использования, то значение будет undefined. неявно происходит так: var a = 5; => var a; a = 5;
    ?Temporal dead zone
      TDZ: термин для описания состояния, когда переменные недоступны. Они находятся в области видимости, но не объявлены.
        -Переменные let и const существуют в TDZ с начала их объемлющей области видимости до момента их объявления.
        -Можно также сказать, что переменные существуют в TDZ с момента их привязки (когда переменная привязывается к области видимости, внутри которой она находится) до момента ее объявления (когда для этой переменной в памяти резервируется имя).
          Если бы мы обратились к переменной в блоке раньше, чем она была объявлена, это вызвало бы ошибку ReferenceError. Из-за TDZ.
      Это связано с hoisting. JS-движок, который разбирает и выполняет код, должен сделать 2 шага:
        1. Парсинг кода в абстрактное синтаксическое дерево/исполняемый байт-код, и
        2. выполнение во время исполнения.
        На шаге 1 происходит подъем, который выполняется движком JS. По сути, он перемещает все объявления переменных в верхнюю часть их области видимости.
        Единственное различие между const и let заключается в том, что когда они поднимаются, их значения не становятся по умолчанию undefiend. console.log(typeof name); => cannot acces name before initialization let name = 'test'; 
        Он знает, что имя существует (оно объявлено), но мы не можем получить к нему доступ до его инициализации.
      Почему у нас есть TDZ?
        -Она помогает нам отлавливать ошибки.
        -Пытаться получить доступ к переменной до ее объявления – это неправильный путь, и он не должен быть возможным.

  + Серилизация и десерилизация
    Сериализация объектов - это процесс преобразования объектов в строковую форму представления, которая позднее может использоваться для их восстановления. Для сериализации и восстановления объектов JavaScript стандартом ЕСМА-Script 5 предоставляются встроенные функции.
      JSON.stringify() - преобразует значение JavaScript в строку JSON, возможно с заменой значений, если указана функция замены, или с включением только определенных свойств, если указан массив замены.
      JSON.parse() - разбирает строку JSON, возможно с преобразованием получаемого в процессе разбора значения.
      Эти функции используют формат обмена данными JSON. Название JSON происходит от «JavaScript Object Notation» (форма записи объектов JavaScript), а синтаксис этой формы записи напоминает синтаксис литералов объектов и массивов в языке JavaScript:
      
    ?Property flags & descriptors (student is able to set property via Object. defineProperty)
    ?Know how to create iterable objects, Symbol.iterator usage (optional)
      Перебираемые объекты
        Объекты, которые можно использовать в цикле for..of, называются итерируемыми.
          -Технически итерируемые объекты должны иметь метод Symbol.iterator.
            -Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации.
            -Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any}, где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение.
          -Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
          -Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
          -Строковый итератор знает про суррогатные пары.
        Объекты, имеющие индексированные свойства и length, называются псевдомассивами. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.
        Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо «настоящих» массивов, потому что эти объекты более абстрактны.
        Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта или псевдомассива obj, и затем мы можем применять к нему методы массивов. Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым контекстом к каждому элементу.
        */
        let range = {
          from: 1,
          to: 5
        };
        
        // 1. вызов for..of сначала вызывает эту функцию
        range[Symbol.iterator] = function() {
        
          // ...она возвращает объект итератора:
          // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
          return {
            current: this.from,
            last: this.to,
        
            // 3. next() вызывается на каждой итерации цикла for..of
            next() {
              // 4. он должен вернуть значение в виде объекта {done:.., value :...}
              if (this.current <= this.last) {
                return { done: false, value: this.current++ };
              } else {
                return { done: true };
              }
            }
          };
        };
        
        // теперь работает!
        for (let num of range) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        // Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код.
        let range2 = {
          from: 1,
          to: 5,
        
          [Symbol.iterator]() {
            this.current = this.from;
            return this;
          },
        
          next() {
            if (this.current <= this.to) {
              return { done: false, value: this.current++ };
            } else {
              return { done: true };
            }
          }
        };
        
        for (let num of range2) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        /*

    +Object Oriented Programming
    ?new keyword
      Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее. Это можно сделать при помощи функции-конструктора и оператора "new".
    ?Understand how new keyword works
    ?Function constructor
      Функция-конструктор
        Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
          -Имя функции-конструктора должно начинаться с большой буквы.
          -Функция-конструктор должна выполняться только с помощью оператора "new".
      Когда функция вызывается как new User(...), происходит следующее: 
        1. Создаётся новый пустой объект, и он присваивается this.
        2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
        3. Возвращается значение this.
    ?Know function constructor concept
    ?Able to create constructor functions
    */
    function User(name) {
      // this = {};  (неявно)
    
      // добавляет свойства к this
      this.name = name;
      this.isAdmin = false;
    
      // return this;  (неявно)
    }
    /*
    Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.
    ?Public, private, static members
      Публичные поля классов
        Публичные поля классов предназначены для задания свойств экземпляра объекта и статических свойств изнутри тела класса.
        И статические, и публичные поля являются изменяемыми, перечисляемыми, настраиваемыми свойствами. Таким образом, в отличие от приватных полей, они участвуют в прототипном наследовании.
        Новый синтаксис для публичных полей позволяет упростить определение класса:
        */
       // classic instance property
        class MyClass {
          constructor() {
            this.counter = 0;
          }
        }
        // public field
        class MyClass {
          counter = 0;
        }
        // ------------------------
        class IncreasingCounter {
          _count = 0;
          get value() {
            console.log('Getting the current value!');
            return this._count;
          }
          increment() {
            this._count++;
          }
        }
        /*
        Свойство _count теперь лаконично объявлено в начале класса. Нам больше не нужен конструктор только для того, чтобы определить некоторые поля. Отлично!
        Тем не менее, _count — все еще публичное свойство. А в этом конкретном примере мы хотим предотвратить обращение к этому полю напрямую.
      Приватные поля классов
        Именно здесь на помощь приходят приватные поля. Новый синтаксис для приватных полей схож с синтаксисом публичных полей, за исключением того, что Вы помечаете их как приватные, используя символ #. Вы можете думать, что # — это просто часть имени поля:
        */
        class IncreasingCounter {
          #count = 0;
          get value() {
            console.log('Getting the current value!');
            return this.#count;
          }
          increment() {
            this.#count++;
          }
        }
        // Приватные поля недоступны вне тела класса:
        const counter = new IncreasingCounter();
        counter.#count;
        // → SyntaxError
        counter.#count = 42;
        // → SyntaxError
        /*
      Статические свойства
        Синтаксис полей классов может быть использован для создания публичных и приватных статических свойств и методов, как показано ниже:
        Статические методы и свойства класса доступны только внутри самого класса, но не в его экземплярах.
        */
        class FakeMath {
          // `PI` is a static public property.
          static PI = 22 / 7; // Close enough.
        
          // `#totallyRandomNumber` is a static private property.
          static #totallyRandomNumber = 4;
        
          // `#computeRandomNumber` is a static private method.
          static #computeRandomNumber() {
            return FakeMath.#totallyRandomNumber;
          }
        
          // `random` is a static public method (ES2015 syntax)
          // that consumes `#computeRandomNumber`.
          static random() {
            console.log('I heard you like random numbers…')
            return FakeMath.#computeRandomNumber();
          }
        }
        
        FakeMath.PI;
        // → 3.142857142857143
        FakeMath.random();
        // logs 'I heard you like random numbers…'
        // → 4
        //FakeMath.#totallyRandomNumber;
        // → SyntaxError
        //FakeMath.#computeRandomNumber();
        // → SyntaxError
        /*
    ?Know how to create public members
    ?Know how to create private members
    ?Know how to create static members
    ?Understand OOP emulation patterns and conventions

  +Prototypal Inheritance Basics
    ?__proto__ property
      __proto__ это ссылка на прототип функции конструктора который ее создал!!!!
      а prototype есть только у функции или class в момент объявления!!!!!
      __proto__ устанавливает prototype либо явно rabbit.__proto__ = animal; но нельзя. Либо при new Object() или Object.create(null)
      XXX.__proto__ есть у всех объектов и почти всегда это объект Object.prototype 
      Разные по типу объекты могут иметь разные __proto__. а одинаковые объекты могут иметь одинаковый __proto__. 
        let obj = {};
        let obj2 = {};
        obj.__proto__ === obj2.__proto__; // true

        let users =[];
        let users2 =[];
        users.__proto__ === users2.__proto__; // true

        let age = 18;
        let age2 = 18;
        age.__proto__ === age2.__proto__; // true

        function someFunc() {};
        let someFunc2 = function() {};
        let someFunc3 = () => {};
        class someClass {};
        и эти __proto__ равны.

        Любой объект в JS создается с помощью class или function
    ?Understand __proto__ object property
    ?Able to use [Object.create] and define __proto__ explicitly
      let clone = Object.create(Object.getPrototypeOf(rabbit), Object.getOwnPropertyDescriptors(rabbit)); //  клон obj c тем же прототипом (с поверхностным копированием свойств)
      let clear = Object.create(null); чистый объект без прототипа (словари)

      let promise = new Promise(() => {}); // создается явно

        let man = {} // new Object(...) за кадром создается так
        let users = [] // new Array(...) за кадром создается так
        let age = 18; // когда обращаемся через точку временно создается new Number(...)
        let youtube = "youtube"; // когда обращаемся через точку временно создается new String(...)
        function someFunc() {}; // за кадром создается так new Function(...)
        let someFunc2 = function() {}; // за кадром создается так new Function(...)
        let someFunc3 = () => {}; // за кадром создается так new Function(...)
        class someClass {}; // за кадром создается так new Function(...)

        let channel = new someClass() // когда с помощью класса создается объект мы его создаем явно!

        let areYouOkAfterThat = "true"; // только если обращаемся как к объекту то временно создается new Boolean(...)

        1. Любой объект создается с помощъю функции конструктора либо же класса и у него есть свойство __proto__
        2. Что бы понимать, что за __proto__, нужно ТОЧНО знать с помощью какой функции-конструктора (класса) создан данный объект. За кадром или явно
        class SomeClass {}
        function SomeFunc() {} // с большой буквы и стрелочная функция не может быть конструктором
        const API = function() {} // главное ключевое слово function
        Object, Promise, Function, Boolean, Number, String, Array, Date, RegExp, Error, Symbol, Map, Set, WeakMap, WeakSet, Proxy, etc

        И у любого объекта который одновременно является классом или функцией с помощю function есть свойство prototype Каждый prototype - это независимый объект, сам по себе с определенным набором свойств и методов.
        И соответственно console.log(Object.prototype) не будет равен console.log(Promise.prototype)
        __proto__ -  у любого объекта (равно прототипу того класса с помощью которого он был создан)                              prototype - у class либо function
        __proto__ любого объекта всегда ссылается на prototype класса(функции-конструктора), с помощью которой этот объект был создан!
        Пример: let man = {} man.__proto__ === Object.prototype

        ЗАЧЕМ КЛАССУ НУЖЕН ОБЪЕКТ prototype?
        И зачем объектам созданным с помощъю этого класса, св-во __proto__, которое ссылается на этот объект prototype
        Если мы пытаемся прочитать свойство объекта, либо вызвать его метод, а его нет, то объект полезет искать его через ссылку __proto__ в prototype класса, с помощью которого он был создан.
        class это просто синаксический сахар над function SomeFunc
    ?Able to set / get object prototype (optional)
      example: Object.setPrototypeOf(obj, prototype)
      example: Object.getPrototypeOf(obj) 
    ?prototype property
    ?Know function prototype property
    ?Understand dependency between function constructor prototype and instance __proto__
    ?Able to create 'class' methods using function prototype property
      */
      // constructor function
      function MyClass () {
        var privateVariable; // private member only available within the constructor fn
      
        this.privilegedMethod = function () { // it can access private members
          //..
        };
      }
      
      // A 'static method', it's just like a normal function 
      // it has no relation with any 'MyClass' object instance
      MyClass.staticMethod = function () {};
      
      MyClass.prototype.publicMethod = function () {
        // the 'this' keyword refers to the object instance
        // you can access only 'privileged' and 'public' members
      };
      
      var myObj = new MyClass(); // new object instance
      
      myObj.publicMethod();
      MyClass.staticMethod();
    /*

  +ECMAScript Classes
    ?Class declaration
      Базовый синтаксис для классов выглядит так:
      */
      class MyClass {
        prop = value; // публичное поле
        constructor(...) { // конструктор
          // ...
        }
        method(...) {} // метод
        get something(...) {} // геттер
        set something(...) {} // сеттер
        [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
        // ...
      }
      /*
      MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.
    ?Know class declaration syntax
    ?Understand difference between class and constructor function
      1. Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.
        В отличие от обычных функций, конструктор класса не может быть вызван без new: //  Error: Class constructor User cannot be invoked without 'new'
      2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype". И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.
      3. Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

      -Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции 
        совершает подъём (hoisted), в то время как объявление класса — нет. Поэтому вначале необходимо объявить ваш класс и только затем работать с ним. (Источник: Classes)
      -Классы имеют специальный конструктор ключевых слов - может быть только один из них, или выдается ошибка. Функции могут иметь несколько определений переменной функции с именем "конструктор"
    ?Getter/setter
      Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.
      При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
      */
      Object.defineProperties(User.prototype, {
        name: {
          get() {
            return this._name
          },
          set(name) {
            // ...
          }
        }
      });
      /*
    ?What does super() do and where we have to use it?
      в классах-потомках конструктор обязан вызывать super(...), и (!) делать это перед использованием this.
      В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:"derived".
      Разница в следующем:
        -Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
        -Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
        Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.

  +ECMAScript Data Types & Expressions
    ?Object keys/values
    ?Object calculated props
      let user = new Object(); // синтаксис "конструктор объекта" let user = {};  // синтаксис "литерал объекта" 
    Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
      Они хранят свойства (пары ключ-значение), где:
        -Ключи свойств должны быть строками или символами (обычно строками).
        -Значения могут быть любого типа.
      Чтобы получить доступ к свойству, мы можем использовать:
        -Запись через точку: obj.property.
        -Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
      Дополнительные операторы:
        -Удаление свойства: delete obj.prop.
        -Проверка существования свойства: "key" in obj. Если вы хотите рассматривать только свойства самого объекта, а не его прототипов, используйте getOwnPropertyNames(), hasOwnProperty() или propertyIsEnumerable. if( obj.hasOwnProperty( prop ) ) { ... }
        -Перебор свойств объекта: цикл for for (let key in obj).
    Упорядочение свойств объекта - Если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать? 
      Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
    ?Set/Map data types
      Map – коллекция пар ключ-значение.
        в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.
        Хотя map[key] также работает, например, мы можем установить map[key] = 2, в этом случаеmap рассматривался бы как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).
        Map может использовать объекты в качестве ключей.
        Использование объектов в качестве ключей – одна из наиболее заметных и важных функций Map. Это то что невозможно для Object.
        Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку: map.set('1', 'str1').set(1, 'num1').set(true, 'bool1');
        Методы и свойства:
          -new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
          -map.set(key, value) – записывает по ключу key значение value.
          -map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
          -map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
          -map.delete(key) – удаляет элемент по ключу key.
          -map.clear() – очищает коллекцию от всех элементов.
          -map.size – возвращает текущее количество элементов.
          -Отличия от обычного объекта Object:
            Что угодно может быть ключом, в том числе и объекты.
            Есть дополнительные методы, свойство size.
      Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
        let set = new Set(["апельсин", "яблоко", "банан"]); for (let value of set) alert(value);
        Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.
        Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.
        Методы и свойства:
          -new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
          -set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
          -set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
          -set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
          -set.clear() – удаляет все имеющиеся значения.
          -set.size – возвращает количество элементов в множестве.
          -Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
    ?WeakSet/WeakMap data types
      Only objects can be keys.
      Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор, пока эта структура данных содержится в памяти.
      Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок на него нет.
      -WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
        Есть только методы get, set, delete и has. Если сборщик мусора удалил объект, то и значения, связанные с ним, автоматически удаляются из WeakMap. 
        Например, если мы используем объект в качестве ключа, то как только он становится недостижимым, он будет удалён из памяти (и из WeakMap) автоматически.
      -WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.
      -Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.
      -WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

  +JavaScript Errors
    ?try..catch statement
      Конструкция try..catch позволяет обрабатывать ошибки во время исполнения кода. Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.
      Синтаксис:
      */
      try {
        // исполняем код
      } catch(err) {
        // если случилась ошибка, прыгаем сюда
        // err - это объект ошибки
      } finally {
        // выполняется всегда после try/catch
      }
      /*
      Секций catch или finally может не быть, то есть более короткие конструкции try..catch и try..finally также корректны.
      Объекты ошибок содержат следующие свойства:
        -message – понятное человеку сообщение.
        -name – строка с именем ошибки (имя конструктора ошибки).
        -stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.
      Если объект ошибки не нужен, мы можем пропустить его, используя catch { вместо catch(err) {.
      Мы можем также генерировать собственные ошибки, используя оператор throw. Аргументом throw может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса Error.
      Даже если у нас нет try..catch, большинство сред позволяют настроить «глобальный» обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.
    ?Know how to handle errors
    ?Проброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.
      catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e.
      При этом ошибка «выпадает» из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо «повалит» скрипт.
      */
      if (e.name == "SyntaxError") {
        alert( "Извините, в данных ошибка" );
      } else {
        throw e;
      }
      /* Без внешнего проброшенная ошибка «вывалилась» бы в консоль с остановкой скрипта.
    ?Custom errors (optional)
      Оператор throw генерирует ошибку. throw <объект ошибки>
        Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).
        В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.
        let error = new Error(message);
        // или
        let error = new SyntaxError(message);
        let error = new ReferenceError(message);
        // ...
    ? Последняя надежда: window.onerror
      Допустим, ошибка произошла вне блока try..catch или выпала из try..catch наружу, во внешний код. Скрипт упал.
      В браузере существует специальное свойство window.onerror, если в него записать функцию, то она выполнится и получит в аргументах сообщение ошибки, текущий URL и номер строки, откуда «выпала» ошибка.
      */window.onerror = function(message, url, lineNumber) {
        alert("Поймана ошибка, выпавшая в глобальную область!\n" +
        "Сообщение: " + message + "\n(" + url + ":" + lineNumber + ")");
      };
      /* Как правило, роль window.onerror заключается не в том, чтобы оживить скрипт – скорее всего, это уже невозможно, а в том, чтобы отослать сообщение об ошибке на сервер, где разработчики о ней узнают.
  +ECMAScript Advanced
    ?Garbage collector (concept) (optional)
      Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.
      Достижимость
        Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.
        1. Существует базовое множество достижимых значений, которые не могут быть удалены. Например:
          -Выполняемая в данный момент функция, её локальные переменные и параметры.
          -Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры. Глобальные переменные.
          -(некоторые другие внутренние значения)
        2. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
          -Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы.
      Главное, что нужно знать:
        -Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
        -Объекты сохраняются в памяти, пока они достижимы.
        -Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.
    ?Promises
      -Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и колбэки.
      -При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.
      -Аргумент resolve/reject (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.
      -Обработчики назначаются вызовом .then/catch.
      -Для передачи результата от одного обработчика к другому используется чейнинг.
        Синтаксис
          new Promise(executor);
          new Promise(function(resolve, reject) { ... });
            executor
              Объект функции с двумя аргументами resolve и reject. Функция executor получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект.
              Первый аргумент (resolve) вызывает успешное исполнение промиса, второй (reject) отклоняет его.
              Обычно функция executor описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию resolve или reject. Обратите внимание, что возвращаемое значение функции executor игнорируется.
        Promise может находиться в трёх состояниях:
          -ожидание (pending): начальное состояние, не исполнен и не отклонён.
          -исполнено (fulfilled): операция завершена успешно.
          -отклонено (rejected): операция завершена с ошибкой.
        Так как методы Promise.prototype.then() и Promise.prototype.catch() сами возвращают промис, их можно вызывать цепочкой, создавая соединения.
          Примечание: говорят, что промис находится в состоянии завершён (settled) когда он или исполнен или отклонён, т.е. в любом состоянии, кроме ожидания (это лишь форма речи, не являющаяся настоящим состоянием промиса).
        Свойства
          Promise.length Значение свойства всегда равно 1 (количество аргументов конструктора).
        Методы
          -Promise.all(iterable) => result - array of fulfield promises or first rejected promise.
            Резолвится когда все промисы из arr выполнены Результат - массив результатов каждого промиса, но если один выполлнился с ошибкой => результат - ошибка этого промиса и остальные промисы игнорируются
          -Promise.allSettled(iterable) => result - array of all promises(does not matter fullfield or reject)
            Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.
          -Promise.race(iterable) => result - fullfield or reject first settled promise. 
            Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable. , остальные игнорируются
          -Promise.reject(reason) Returns a new Promise object that is rejected with the given reason.
          -Promise.resolve(value) Returns a new Promise object that is resolved with the given value.
        Создание промиса
          Объект Promise создаётся при помощи ключевого слова new и своего конструктора. Конструктор Promise принимает в качестве аргумента функцию, называемую "исполнитель" (executor function). Эта функция должна принимать две функции-колбэка в качестве параметров. 
            Первый из них (resolve) вызывается, когда асинхронная операция завершилась успешно и вернула результат своего исполнения в виде значения. Второй колбэк (reject) вызывается, когда операция не удалась, и возвращает значение, указывающее на причину неудачи, чаще всего объект ошибки.
            */
            const myFirstPromise = new Promise((resolve, reject) => {
              // выполняется асинхронная операция, которая в итоге вызовет:
              //
              //   resolve(someValue); // успешное завершение
              // или
              //   reject("failure reason"); // неудача
            });
            /*
            Чтобы снабдить функцию функциональностью промисов, нужно просто вернуть в ней объект Promise:
    ?Promise states
    ?Promise Chaining
      Цепочки промисов
        «Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.
        Например, мы хотим по очереди:
          -Загрузить данные посетителя с сервера (асинхронно).
          -Затем отправить запрос о нём на github (асинхронно).
          -Когда это будет готово, вывести его github-аватар на экран (асинхронно).
          -…И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
        При чейнинге, то есть последовательных вызовах .then…then…then, в каждый следующий then переходит результат от предыдущего.
        Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
        То есть, логика довольно проста:
          В каждом then мы получаем текущий результат работы.
          Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.
    ?Promise static methods
    ?Be able to compare promise and callback patterns (optional)
    ?Be able to handle errors in promises
      Перехват ошибок
        При возникновении ошибки – она отправляется в ближайший обработчик onRejected.
        Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец нашей цепочки:
        .catch(error => {
          alert(error); // Error: Not Found
        });
      Обработчик .catch(onRejected) получает ошибку и должен обработать её.
        Есть два варианта развития событий:
          1. Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).
          2. Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).
      Это также похоже на обычный try..catch – в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. 
        Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не «вываливается» в консоль и не «убивает» скрипт.
    ?event loop
      «Как JavaScript может быть асинхронным и однопоточным?» Если кратко, то JavaScript однопоточный, а асинхронное поведение не является частью самого языка; вместо этого оно построено на основе него в браузере (или среде программирования) и доступно через браузерные API.
        В браузере:
          1. В начале выполняется весь синхронный код
          2. Чекаем и выполняем все Microtask Queue! (все промисы) (через попадание в call stack.)
            Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.
          3. далее Macrotask Queue выполняет 1 задачу из очереди и переходит к чеку микрозадач и если есть, то выполняет их => render 
            Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
          4. Фаза рендеринга и по новой (подождать, пока появится макрозадача, т.к. в microtask они не могут сами попасть).
        Макро-задачи и микро-задачи
          И микрозадачи, и макрозадачи являются асинхронными задачами, но они будут входить в две разные асинхронные очереди, и приоритет очереди микрозадач выше приоритета макрозадачи.
            -Макрозадача (setTimeout, setInterval, setImmediate, requestAnimationFrame)
            -Микрозадача (Promise.then, Promise.catch, Promise.finally, process.nextTick)
          Код JavaScript делится на синхронный код и асинхронный код, а асинхронный код делится на макро-задачи и микро-задачи. Макро-задачи и микро-задачи - это две разные асинхронные очереди, и приоритет микро-задач выше, чем у макро-задач.
        -Stack (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода. Вызовы функций помещаются в стек (об этом ниже).
        -Heap (куча) — объекты собраны в кучу, которая есть ни что иное, как название для наименее структурированной части памяти.
    ?async/await
    Существует специальный синтаксис для работы с промисами, который называется «async/await».
      Ключевое слово async перед объявлением функции:
        -Обязывает её всегда возвращать промис.
        -Позволяет использовать await в теле этой функции.
      Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:
        -Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
        -Иначе вернётся результат промиса.
      Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.
      Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). 
        Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

  +Web components
    ?Web components, shadow DOM (concept) (optional)
      Веб-компоненты
        Веб-компоненты - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях.
        Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
        Модель веб-компонентов подразумевает инкапсуляцию и совместимость отдельных HTML-элементов.
        На данный момент частичная поддержка существует в браузерах Chrome, Firefox, Opera и Safari. Для браузеров не поддерживающих веб-компоненты реализованы полифилы.
          -Веб-компоненты включают три технологии, каждая из которых может использоваться отдельно от других:
          -Custom Elements — API для создания собственных HTML элементов.
          -HTML Templates — тег <template> позволяет реализовывать изолированные DOM-элементы.
          -Shadow DOM — изолирует DOM и стили в разных элементах.
  


!JavaScript in Browser:

  +Global object window
    Глобальный объект
      Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.
      Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы. Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight – высота окна браузера.
      Глобальный объект имеет универсальное имя – globalThis. …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js). 
      В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами глобального объекта. Но не let и const, которые объявляются в блоке кода, не станут свойствами глобального объекта.
      Корневой объект window, который выступает в 2 ролях:
        -Во-первых, это глобальный объект для JavaScript-кода как было сказано выше. (Object, Array, String, Number, Boolean, Math, Date, RegExp, Error, JSON, …)
        -Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.
          -DOM (Document Object Model) – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
          -BOM (Browser Object Model) - это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа. (navigator, screen, history, location …)
          -CSSOM (CSS Object Model) – объектная модель CSS, которая представляет все содержимое CSS в виде объектов, которые можно менять. Объект CSSStyleDeclaration – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
    ?Document
      ?DOM-дерево:
        -В соответствии с объектной моделью документа (DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
          Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, document.body – объект для тега <body>.
        -Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
        -Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
        -Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM.
          Существует всего два исключения из этого правила: 1. По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются. 2. Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body.
        -Автоисправление - Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM. Например, в начале документа всегда должен быть тег <html>.  То же самое касается и тега <head> и <body>.
        -Другие типы узлов: Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:
          1. document – «входная точка» в DOM.
          2. узлы-элементы – HTML-теги, основные строительные блоки.
          3. текстовые узлы – содержат текст.
          4. комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
      ?Навигация по DOM документу: 
        Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки. Есть два основных набора ссылок:
          -Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
          -Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
      ?Поиск: getElement*, querySelector*
        Есть 6 основных методов поиска элементов в DOM:
          Метод	                      Ищет по...	       Ищет внутри элемента?        	Возвращает живую коллекцию?
          -querySelector         	   CSS-selector	                ✔	                               -
          -querySelectorAll        	CSS-selector	                ✔	                               -
          -getElementById         	   id	                        -	                                -
          -getElementsByName         	name	                      -	                                ✔
          -getElementsByTagName      tag or '*'                  	✔                                	✔
          -getElementsByClassName      class	                    ✔	                                ✔
        Методы другие:
          -elem.matches(css)  проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.  Когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют. elem.matches('a[href$="zip"]')
          -elem.closest(css) Метод ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск. 
            Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.
          -elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
      ?Свойства узлов: тип, тег и содержимое:
        Классы DOM-узлов:
          У разных DOM-узлов могут быть разные свойства(<a>, <img>, <input>). Каждый узел имеет свои свойства. Каждый DOM-узел принадлежит соответствующему встроенному классу. Например, <a> принадлежит классу HTMLAnchorElement. 
          Корнем иерархии является EventTarget => Node и остальные DOM-узлы.
          -EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают «события»
          -Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
            Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.
          -Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. 
            Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.
          -HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы: HTMLAnchorElement, HTMLButtonElement, HTMLDivElement, HTMLImageElement, HTMLInputElement, HTMLSpanElement, HTMLTableElement и т.д.
            каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы. Таким образом, полный набор свойств и методов данного узла собирается в результате наследования.
          //* document.body.constructor.name => HTMLBodyElement
          Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.
        Свойства:
          -innerHTML Внутреннее HTML-содержимое узла-элемента. Можно изменять. Пример: document.body.innerHTML = '<p>Привет мир!</p>';
          -outerHTML Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.  Это как innerHTML плюс сам элемент.
          -nodeValue/data Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.
          -textContent Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
          -hidden Когда значение установлено в true, делает то же самое, что и CSS display:none.
      ?Атрибуты и свойства:
          Но преобразование атрибута в свойство происходит не один-в-один!
        DOM-свойства:
          DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять. Например, создадим новое свойство для document.body: document.body.myProperty = 'Привет мир!'; и проверим: document.body.myProperty; // Привет мир!
            Мы можем добавить и метод: Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам
            Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript: 1) Им можно присвоить любое значение. 2) Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).
            DOM-свойства типизированы - например, свойство input.checked (для чекбоксов) имеет логический тип.
            Есть и другие примеры. Атрибут style – строка, но свойство style является объектом: div.style => [object CSSStyleDeclaration]
        HTML-атрибуты
          Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов. <body id="page"> => body.id = "page".
          Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный. Cтандартный атрибут для одного тега может быть нестандартным для другого.
          Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?
            Все атрибуты доступны с помощью следующих методов:
              -elem.hasAttribute(name) – проверяет наличие атрибута.
              -elem.getAttribute(name) – получает значение атрибута.
              -elem.setAttribute(name, value) – устанавливает значение атрибута.
              -elem.removeAttribute(name) – удаляет атрибут.
              Эти методы работают именно с тем, что написано в HTML.
              -Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes: коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами name и value.
          Синхронизация между атрибутами и свойствами:
            Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями). todo разобраться.
          Нестандартные атрибуты, dataset:
            Иногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript, или чтобы «помечать» HTML-элементы для JavaScript. Но с пользовательскими атрибутами могут возникнуть проблемы. Что если мы используем нестандартный атрибут для наших целей, а позже он появится в стандарте и будет выполнять какую-то функцию?
            Чтобы избежать конфликтов, существуют атрибуты вида data-*. Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset. //* <body data-about="Elephants"> document.body.dataset.about => "Elephants"
            Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState. Использование data-* атрибутов – валидный, безопасный способ передачи пользовательских данных.
        В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда, когда DOM-свойства не подходят, когда нужны именно атрибуты, например:
          -Нужен нестандартный атрибут. Но если он начинается с data-, тогда нужно использовать dataset.
          -Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например, свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.
      ?Изменение документа
        Методы для создания узлов:
          -document.createElement(tag) – создаёт элемент с заданным тегом,
          -document.createTextNode(value) – создаёт текстовый узел (редко используется),
          -elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.
        Вставка и удаление:
          -node.append(...nodes or strings) – вставляет в node в конец,
          -node.prepend(...nodes or strings) – вставляет в node в начало,
          -node.before(...nodes or strings) – вставляет прямо перед node,
          -node.after(...nodes or strings) – вставляет сразу после node,
          -node.replaceWith(...nodes or strings) – заменяет node.
          -node.remove() – удаляет node.
        Устаревшие методы:
          -parent.appendChild(node)
          -parent.insertBefore(node, nextSibling)
          -parent.removeChild(node)
          -parent.replaceChild(newElem, node)
          Все эти методы возвращают node.
        Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(position, html) вставляет в зависимости от position:
          -"beforebegin" – вставляет html прямо перед elem,
          -"afterbegin" – вставляет html в elem в начало,
          -"beforeend" – вставляет html в elem в конец,
          -"afterend" – вставляет html сразу после elem.
          Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы, но они редко используются.
        Чтобы добавить HTML на страницу до завершения её загрузки:
          -document.write(html) После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.
      ? Стили и классы
        Как правило, существует два способа задания стилей для элемента:
          -Создать класс в CSS и использовать его: <div class="some">
          -Писать стили непосредственно в атрибуте style: <div style="...">.
        JavaScript может менять и классы, и свойство style. Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством style только в том случае, если классы «не могут справиться».
        Для управления классами существуют два DOM-свойства:
          -className – строковое значение, удобно для управления всем набором классов. Перезапишет все классы, которые были до этого.
          -classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.
        Чтобы изменить стили:
          -elem.style – это объект, который соответствует тому, что написано в атрибуте "style". Установка стиля elem.style.width="100px" работает так же, как наличие в атрибуте style строки width:100px. background-color  => elem.style.backgroundColor
          -style.cssText - Обычно мы используем style.* для присвоения индивидуальных свойств стиля. Нельзя установить список стилей как, например, div.style="color: red; width: 100px", потому что div.style – это объект, и он доступен только для чтения.
            Для задания нескольких стилей в одной строке используется специальное свойство style.cssText: Это свойство редко используется, потому что такое присваивание удаляет все существующие стили
      ? Размеры и прокрутка элементов
        У элементов есть следующие геометрические свойства (метрики):
          -offsetParent – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
          -offsetLeft/offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent.
          -offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки.
          -clientLeft/clientTop – расстояние от верхнего левого внешнего угла до внутренного. Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
          -clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
          -scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
          -scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
          Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.
      ? Размеры и прокрутка окна
        Размеры:
          -Ширина/высота видимой части документа (ширина/высота области содержимого): document.documentElement.clientWidth/Height
          -Ширина/высота всего документа со всей прокручиваемой областью страницы:
            let scrollHeight = Math.max(
              document.body.scrollHeight, document.documentElement.scrollHeight,
              document.body.offsetHeight, document.documentElement.offsetHeight,
              document.body.clientHeight, document.documentElement.clientHeight
            );
        Прокрутка:
          -Прокрутку окна можно получить так: window.pageYOffset/pageXOffset.
          -Изменить текущую прокрутку:
            -window.scrollTo(pageX,pageY) – абсолютные координаты,
            -window.scrollBy(x,y) – прокрутка относительно текущего места,
            -elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).
      ? Координаты
        Любая точка на странице имеет координаты:
          1. Относительно окна браузера – elem.getBoundingClientRect().
          2. Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы.
        Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute.
        Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между absolute и fixed.
  ?Location
      Window.location -  возвращает объект Location с информацией о текущем расположении документа.
        В большинстве случаев вы можете работать с location как со строкой: location = 'http://www.example.com' это синоним для location.href = 'http://www.example.com'.
      Объект window.location можно использовать для получения адреса текущей страницы (URL) и для перенаправления браузера на новую страницу.
      Свойства
        -window.location.href содержащий URL целиком. При изменении, соответствующий документ переходит на новую страницу.
        -window.location.hostname возвращает доменное имя веб хостинга (например, "www.example.com").
        -window.location.pathname возвращает путь и имя файла текущей страницы (например, "/index.html").
        -window.location.protocol возвращает используемый веб протокол (http: или https:) (например, "http:").
        -window.location.port содержащий номер порта текущего URL. Если номер порта не указан в URL, то свойство возвращает пустую строку. (например, "8080").
        -window.location.search содержащий '?' с последующими параметрами URL. Если параметры отсутствуют, то свойство возвращает пустую строку. (например, "?q=javascript").
      Методы 
        -window.location.reload() Перезагружает ресурс по текущему URL. Единственный опциональный параметр Boolean (en-US) при значении true указывает, что страница должна быть заново загружена с сервера, при значении false страница может быть загружена из кеша.
        -window.location.replace() Заменяет текущий ресурс на новый по URL, указанному в качестве параметра. Отличие от assign() в том, что при использовании replace() текущая страница не будет сохранена в History, и пользователь не сможет использовать кнопку назад, чтобы вернуться к ней.
        -window.location.assign() Загружает ресурс по URL, указанному в качестве параметра.
    ?Know browser location structure
    ?History API (Global object window)
      DOM-объект Window предоставляет доступ к истории текущей сессии браузера (не путать с историей браузерных расширений) через объект history. Он предоставляет полезные методы и свойства, которые позволяют переходить назад и вперёд по истории пользователя и манипулировать её содержимым.
      Основные методы объекта History:
        -window.history.length: Количество записей в текущей сессии истории
        -window.history.state: Возвращает текущий объект истории examp: {page: 1}
        -window.history.go(n): Метод, позволяющий гулять по истории. В качестве аргумента передается смещение, относительно текущей позиции. Если передан 0, то будет обновлена текущая страница. Если индекс выходит за пределы истории, то ничего не произойдет.
        -window.history.back(): Метод, идентичный вызову go(-1)
        -window.history.forward(): Метод, идентичный вызову go(1)
        -window.history.pushState(data, title [, url]): Добавляет элемент истории.
        -window.history.replaceState(data, title [, url]): Обновляет текущий элемент истории
    ?Know browser History APIconcept
    ?Be able to navigate within browser history
    ?Be able to use history state (optional)
    ?Navigator (optional)
      Объект navigator предназначен для предоставления подробной информации о браузере, который пользователь использует для доступа к сайту или веб-приложению. Кроме данных о браузере, в нём ещё содержится сведения о операционной системе, сетевом соединении и др.
        const navigatorObj = window.navigator;
          Объект navigator имеет свойства и методы. Очень часто они используется для того чтобы узнать, какие функции поддерживаются браузером, а какие нет.
            Свойства объекта navigator:
              -appCodeName – кодовое имя браузера; examp: Mozilla
              -appName – имя браузера; examp: Netscape
              -appVersion — версия браузера; examp: 5.0 (Windows)
              -cookieEnabled - позволяет определить включены ли cookie в браузере;  examp: true
              -geolocation - используется для определения местоположения пользователя; examp: Geolocation
              -language - язык браузера; examp: ru-RU
              -online - имеет значение true или false в зависимости от того находиться ли браузер в сети или нет;   examp: true
              -platform - название платформы, для которой скомпилирован браузер; examp: Win32
              -product - имя движка браузера; examp: Gecko
              -userAgent - возвращает заголовок user agent, который браузер посылает на сервер. Это позволяет серверу определить, какой браузер использует пользователь; examp: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36
            Методы объекта navigator:
              -javaEnabled – позволяет узнать, включён ли в браузере Java;
              -sendBeacon - предназначен для отправки небольшого количества информации на веб-сервер без ожидания ответа.
    ?Know how to parse user agent (optional)
      Обнаружение браузера с помощью userAgent
        userAgent - это строка, содержащая информацию о браузере, которую он посылает в составе заголовка запроса на сервер.
        Пример содержания строки userAgent в браузере Google Chrome:
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36"
          Эти данные можно использовать, например, для обнаружения браузера.
            if (navigator.userAgent.indexOf('Chrome') !== -1 ) {}
    ?Know how to discover client platform, browser
    ?Cookies
      document.cookie предоставляет доступ к куки.
        -Операция записи изменяет только то куки, которое было указано.
        -Имя и значение куки должны быть закодированы.
        -Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).
      Настройки куки:
        -path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
        -domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
        -expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
        -secure делает куки доступным только при использовании HTTPS.
        -samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.
      Дополнительно:
        -Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
        -Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.

  +Events Basics
    Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).
      События мыши:
        -click – клик по кнопке мыши.
        -contextmenu – клик правой кнопкой мыши.
        -dblclick – двойной клик по кнопке мыши.
        -mouseover / mouseout – когда мышь наводится на / покидает элемент.
        -mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
      События на элементах управления:
        -submit – пользователь отправил форму <form>.
        -focus – пользователь фокусируется на элементе, например нажимает на <input>.
      Клавиатурные события:
        -keydown и keyup – когда пользователь нажимает / отпускает клавишу.
      События документа:
        -DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
      CSS events:
        transitionend – когда CSS-анимация завершена.
    Обработчики событий:
      Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
    Есть три способа назначения обработчиков событий:
      1. Атрибут HTML: onclick="...".
      2. Свойство объекта: elem.onclick = function() {...}.
      3. Метод объекта: elem.addEventListener("click", function() {...}).
      Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.
      Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.
    ?Event Phases
      Стандарт DOM Events описывает 3 фазы прохода события:
        -Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
        -Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
        -Фаза всплытия (bubbling stage) – событие начинает всплывать.
      Всплытие:
        Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
        Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:
        Клик по внутреннему <p> вызовет обработчик onclick:
          1. Сначала на самом <p>.
          2. Потом на внешнем <div>.
          3. Затем на внешнем <form>.
          4. И так далее вверх по цепочке до самого document.
        При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).
          -Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
          -Далее обработчики вызываются на целевом элементе.
          -Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.
        Каждый обработчик имеет доступ к свойствам события event:
          -event.target – самый глубокий элемент, на котором произошло событие.
          -event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
          -event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
        Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
        В разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.
        Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий.
    ? Делегирование событий
      Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.
      Алгоритм делегирования событий:
        -Вешаем обработчик на контейнер.
        -В обработчике проверяем исходный элемент event.target.
        -Если событие произошло внутри нужного нам элемента, то обрабатываем его.
        Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
        Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
        Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
    ? Действия браузера по умолчанию
      Действий браузера по умолчанию достаточно много:
        -mousedown – начинает выделять текст (если двигать мышкой).
        -click на <input type="checkbox"> – ставит или убирает галочку в input.
        -submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
        -keydown – при нажатии клавиши в поле ввода появляется символ.
        -contextmenu – при правом клике показывается контекстное меню браузера.
      Отмена действия браузера
        -Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault(). <a href="/" onclick="event.preventDefault()">здесь</a>
        -Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика. <a href="/" onclick="return false">Нажми здесь</a>
    ?Event Listeners
      -EventTarget.addEventListener() - регистрирует определённый обработчик события, вызванного на EventTarget.
          EventTarget может быть Element, Document, Window, или любым другим объектом, поддерживающим события (таким как XMLHttpRequest (en-US)).
        Синтаксис:
          target.addEventListener(type, listener[, options]);
          target.addEventListener(type, listener[, useCapture]);
        Параметры: 
          type - Чувствительная к регистру строка, представляющая тип обрабатываемого события.
          listener - Объект, который принимает уведомление, когда событие указанного типа произошло. Это должен быть объект, реализующий интерфейс EventListener или просто функция JavaScript.
          options - Объект options, который определяет характеристики объекта, прослушивающего событие. Доступны следующие варианты:
            -capture:  Boolean указывает, что события этого типа будут отправлены зарегистрированному обработчику listener перед отправкой на EventTarget, расположенный ниже в дереве DOM.
            -once: Boolean указывает, что обработчик должен быть вызван не более одного раза после добавления. Если true, обработчик автоматически удаляется при вызове.
            -passive:  Boolean указывает, что обработчик никогда не вызовет preventDefault(). Если всё же вызов будет произведён, браузер должен игнорировать его и генерировать консольное предупреждение. Пример Улучшение производительности прокрутки с помощью passive true
          useCapture - Если равно true, useCapture указывает, что пользователь желает начать захват.
        Зачем использовать addEventListener?
          -Позволяет добавлять множество обработчиков для одного события.
          -Предоставляет точный контроль фазы срабатывания(вызова) обработчика (захват или всплытие)
          -Срабатывает на любом DOM-элементе, а не только на HTML-элементах.
      -EventTarget.removeEventListener() - Удаляет обработчик события, который был зарегистрирован при помощи EventTarget.addEventListener(). Обработчик определяется типом события, самой функцией обработки события, и дополнительными параметрами, переданными при регистрации обработчика.
    ?DOM Events
      События загрузки страницы:
        -DOMContentLoaded генерируется на document, когда DOM готов. Мы можем применить JavaScript к элементам на данном этапе.
          -Скрипты, вроде <script>...</script> или <script src="..."></script> блокируют DOMContentLoaded, браузер ждёт, пока они выполнятся.
          -Изображения и другие ресурсы тоже всё ещё могут продолжать загружаться.
        -Событие load на window генерируется, когда страница и все ресурсы загружены. Мы редко его используем, потому что обычно нет нужды ждать так долго.
        -Событие beforeunload на window генерируется, когда пользователь покидает страницу. Если мы отменим событие, браузер спросит, на самом ли деле пользователь хочет уйти (например, у нас есть несохранённые изменения).
        -Событие unload на window генерируется, когда пользователь окончательно уходит, в обработчике мы можем делать только простые вещи, которые ни о чём не спрашивают пользователя и не заставляют его ждать. Из-за этих ограничений оно редко используется. Мы можем послать сетевой запрос с помощью navigator.sendBeacon.
        -document.readyState – текущее состояние документа, изменения можно отследить с помощью события readystatechange:
          -loading – документ грузится.
          -interactive – документ прочитан, происходит примерно в то же время, что и DOMContentLoaded, но до него.
          -complete – документ и ресурсы загружены, происходит примерно в то же время, что и window.onload, но до него.
    ?Know basic Event types
      User Interface events: load unload error resize scroll
      Focus and blur events: focus blur focusin focusout
      Mouse events: click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave
      Keyboard events: input keydown keyup keypress
      Form events: submit change input
      HTML5 events: DOMContentLoaded  hashchange  beforeunload
      CSS events: transitionend animationstart animationiteration animationend
    ?Mouse Events
      Основы событий мыши
          Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.
        Порядок событий
          Например, клик мышью вначале вызывает mousedown, когда кнопка нажата, затем mouseup и click, когда она отпущена. В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: mousedown → mouseup → click.
        Кнопки мыши
          События, связанные с кликом, всегда имеют свойство button, которое позволяет получить конкретную кнопку мыши. Обычно мы не используем его для событий click и contextmenu, потому что первое происходит только при щелчке левой кнопкой мыши, а второе – только при щелчке правой кнопкой мыши.
          С другой стороны, обработчикам mousedown и mouseup может потребоваться event.button, потому что эти события срабатывают на любую кнопку, таким образом button позволяет различать «нажатие правой кнопки» и «нажатие левой кнопки».
          Значеня: 0 – левая кнопка мыши, 1 – средняя кнопка мыши, 2 – правая кнопка мыши. 3 - Кнопка X1 (назад) мыши. 4 - Кнопка X2 (вперед) мыши.
        Модификаторы: shift, alt, ctrl и meta. Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.
          Свойства события:
            -shiftKey: Shift
            -altKey: Alt (или Opt для Mac)
            -ctrlKey: Ctrl
            -metaKey: Cmd для Mac
            Они равны true, если во время события была нажата соответствующая клавиша. Внимание: обычно на Mac используется клавиша Cmd вместо Ctrl
        Координаты: clientX/Y, pageX/Y
          Все события мыши имеют координаты двух видов:
            -Относительно окна: clientX и clientY.
            -Относительно документа: pageX и pageY.
        Отключаем выделение:
          Двойной клик мыши имеет побочный эффект, который может быть неудобен в некоторых интерфейсах: он выделяет текст.
      Движение мыши: mouseover/out, mouseenter/leave
        Особенности, на которые стоит обратить внимание:
          -При быстром движении мыши события не будут возникать на промежуточных элементах.
          -События mouseover/out и mouseenter/leave имеют дополнительное свойство: relatedTarget. Оно дополняет свойство target и содержит ссылку на элемент, с/на который мы переходим.
        События mouseover/out возникают, даже когда происходит переход с родительского элемента на потомка. С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.
        События mouseenter/leave в этом отличаются. Они генерируются, когда курсор переходит на элемент в целом или уходит с него. Также они не всплывают.
    ?Keyboard Events
      Клавиатура: keydown и keyup
        Нажатие клавиши всегда генерирует клавиатурное событие, будь то буквенно-цифровая клавиша или специальная типа Shift или Ctrl и т.д. Единственным исключением является клавиша Fn, которая присутствует на клавиатуре некоторых ноутбуков. 
          События на клавиатуре для неё нет, потому что она обычно работает на уровне более низком, чем даже ОС.
        События клавиатуры:
          -keydown – при нажатии на клавишу (если клавиша остаётся нажатой, происходит автоповтор),
          -keyup – при отпускании клавиши.
        Главные свойства для работы с клавиатурными событиями:
          -code – «код клавиши» ("KeyA", "ArrowLeft" и так далее), особый код, привязанный к физическому расположению клавиши на клавиатуре.
          -key – символ ("A", "a" и так далее), для не буквенно-цифровых групп клавиш (таких как Esc) обычно имеет то же значение, что и code.
          Клавиша          	event.key        	event.code
          F1	                 F1	                F1
          Backspace        	Backspace	         Backspace
          Shift	              Shift	     ShiftRight или ShiftLeft
    ?Form / Input Events
      Свойства и методы формы
        Навигация: формы и элементы
          Формы в документе входят в специальную коллекцию document.forms Это так называемая «именованная» коллекция: мы можем использовать для получения формы как её имя, так и порядковый номер в документе.
        Обратная ссылка: element.form
          Для любого элемента форма доступна через element.form. Так что форма ссылается на все элементы, а эти элементы ссылаются на форму.
        Элементы формы
          Значения элементов формы доступны через input.value, textarea.value, select.value и т.д. либо input.checked для чекбоксов и переключателей.
        Для элемента <select> мы также можем получить индекс выбранного пункта через select.selectedIndex, либо используя коллекцию пунктов select.options.
      Фокусировка: focus/blur
        События focus и blur срабатывают на фокусировке/потере фокуса элемента.
          Их особенности:
            -Они не всплывают. Но можно использовать фазу перехвата или focusin/focusout.
            -Большинство элементов не поддерживают фокусировку по умолчанию. Используйте tabindex, чтобы сделать фокусируемым любой элемент.
      События: change, input, cut, copy, paste
        Событие                                                     	Описание	                                                       Особенности
        change	                                             Значение было изменено.                          	  Для текстовых полей срабатывает при потере фокуса.
        input                                     	Срабатывает при каждом изменении значения.	                  Запускается немедленно, в отличие от change.
        cut/copy/paste                            	Действия по вырезанию/копированию/вставке.	                  Действие можно предотвратить. Свойство event.clipboardData предоставляет доступ на чтение/запись в буфер обмена…
      Отправка формы: событие и метод submit
        При отправке формы срабатывает событие submit, оно обычно используется для проверки (валидации) формы перед её отправкой на сервер или для предотвращения отправки и обработки её с помощью JavaScript.
          Метод submit() отправляет форму на сервер.
        Событие: submit
          Есть два основных способа отправить форму:
            -Первый – нажать кнопку <input type="submit"> или <input type="image">.
            -Второй – нажать Enter, находясь на каком-нибудь поле.
            Оба действия сгенерируют событие submit на форме. Обработчик может проверить данные, и если есть ошибки, показать их и вызвать event.preventDefault(), тогда форма не будет отправлена на сервер.
        Метод: submit
          Чтобы отправить форму на сервер вручную, мы можем вызвать метод form.submit().
          При этом событие submit не генерируется. Предполагается, что если программист вызывает метод form.submit(), то он уже выполнил всю соответствующую обработку.
  +Timers
    Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».
      Для этого существуют два метода:
        -setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
        -setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
        Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.
    ?setTimeout
      let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...) Аргументы, передаваемые в функцию
        Если первый аргумент является строкой, то JavaScript создаст из неё функцию. Это также будет работать:  setTimeout("alert('Привет')", 1000);
        Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так: setTimeout(() => alert('Привет'), 1000);
        Передавайте функцию, но не запускайте её!
      Отмена через clearTimeout
        Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.
        let timerId = setTimeout(...); clearTimeout(timerId);
    ?setInterval
      let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
        Все аргументы имеют такое же значение. Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.
        Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).
        Во время показа alert время тоже идёт
    Вложенный setTimeout
      let timerId = setTimeout(function tick() {
        alert('tick');
        timerId = setTimeout(tick, 2000); // (*)
      }, 2000);
      Вложенный setTimeout – более гибкий метод, чем setInterval. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.
      Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд…
      А если функции, которые мы планируем, ресурсоёмкие и требуют времени, то мы можем измерить время, затраченное на выполнение, и спланировать следующий вызов раньше или позже.
      ВложенныйsetTimeout гарантирует фиксированную задержку (здесь 100 мс). Это потому, что новый вызов планируется в конце предыдущего. 
    Сборка мусора и колбэк setTimeout/setInterval
      Когда функция передаётся в setInterval/setTimeout, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на неё нет других ссылок.
      Для setInterval функция остаётся в памяти до тех пор, пока не будет вызван clearInterval. Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, 
      внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.
    setTimeout с нулевой задержкой
  +Web Storage API & cookies
    ?LocalStorage
    ?SessionStorage
    './LS_SS_cookie.js'

    +Page Lifecycle
    Навигация
      Навигация - это первый этап при загрузке приложения. Он происходит каждый раз, когда пользователь запрашивает страницу, вводя URL в адресную строку браузера, нажимает на ссылку, отправляет заполненные поля формы и выполняет некоторые другие действия.
    DNS запрос
      Первый шаг навигации к странице - это поиск места, откуда нужно запрашивать данные. Если вы переходите на https://example.com, браузер грузит HTML-код страницы с IP-адреса 93.184.216.34. Если вы никогда ранее не были на этом сайте, произойдёт поиск DNS записи.
    TCP Рукопожатие (Handshake)
      В тот момент, когда IP адрес становится известен, браузер начинает установку соединения к серверу с помощью рукопожатия TCP three-way handshake (en-US). Этот механизм спроектирован так, чтобы два устройства, пытающиеся установить связь, могли обменяться параметрами соединения, прежде чем приступать к передаче данных. Чаще всего - через защищённое соединение HTTPS.
    TLS Переговоры (Negotiation)
      Для установки безопасных соединений с использованием HTTPS требуется ещё одно рукопожатие. На этот раз - TLS переговоры. На этом шаге определяется, какой шифр будет использоваться для шифрования соединения, удостоверяется надёжность сервера и устанавливается безопасное соединение. 
        Этот шаг также требует несколько дополнительных сообщений, которыми должны обменяться сервер и браузер, прежде чем данные будут посланы.
    Ответ на запрос
      Как только мы установили соединение с веб-сервером, браузер отправляет инициирующий HTTP GET запрос от имени пользователя. Чаще всего запрашивается HTML файл. В момент, когда сервер получает запрос, он начинает ответ с посылки заголовков ответа и содержимым HTML-файла.
      Этот ответ содержит в себе первый байт полученных данных. Время до первого байта (Time to First Byte, TTFB) - это время между моментом когда пользователь отправил запрос, скажем, нажав на ссылку, и моментом получения первого пакета данных HTML. Первый пакет обычно содержит 14КБ данных.
    TCP медленный старт / правило 14kb
      Объём первого пакета данных - всегда 14KB. Это часть спецификации TCP slow start (en-US) - алгоритма, который балансирует скорость соединения. Такое правило позволяет постепенно, по мере необходимости, увеличивать размеры передаваемых данных, пока не будет определена максимальная ширина канала.
        В алгоритме TCP slow start (en-US) каждый следующий отправленный сервером пакет увеличивается в размере в два раза.
    Парсинг
      Как только браузер получает первый кусочек данных, он сразу начинает обрабатывать получаемую информацию. Эта обработка называется "Парсинг" (Parsing). Во время парсинга получаемые данные преобразуются в DOM и CSSOM (en-US), которые напрямую участвуют в отрисовке.
    ?Parsing
        1. Из полученного от сервера HTML-документа путем парсинга формируется DOM (Document Object Model). Это дерево объектов, которое представляет HTML-документ в виде узлов и элементов. DOM-дерево используется для доступа к элементам страницы и их изменения.
        2. Загружаются и парсятся стили, формируется CSSOM (CSS Object Model).  
        3. На основе DOM и CSSOM формируется дерево рендеринга, или render tree — набор объектов рендеринга (Webkit использует термин «renderer», или «render object», а Gecko — «frame»). Render tree дублирует структуру DOM, но сюда не попадают невидимые 
          элементы (например — <head>, или элементы со стилем display:none;). Также, каждая строка текста представлена в дереве рендеринга как отдельный renderer. Каждый объект рендеринга содержит соответствующий ему объект DOM (или блок текста), и 
          рассчитанный для этого объекта стиль. Проще говоря, render tree описывает визуальное представление DOM.
    ?Layout / Reflow Правильнее будет сказать Layout для первой операции, а все дальнейшие повторные операции, будет правильнее называть Reflow. Иногда этот процесс называется просто Layout, во всех случаях.
        4. Вычисление позиции и размеров, Layout Для каждого элемента render tree рассчитывается положение на странице — происходит layout. Браузеры используют поточный метод (flow), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов 
          требуется больше).
            -Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.
            -Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход. 
              Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.
          Глобальный и инкрементальный Layout 
            -Глобальный Layout — это процесс просчёта всего дерева полностью, то есть каждого элемента. Инкрементальный — просчитывает только часть.
              Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это очень дорогой процесс.
            -Инкрементальный Layout запускает пересчёт только «грязных» элементов.
              Грязные элементы
              -Это те элементы, которые были изменены, и их дочерние элементы. Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.
      ?5. Непосредственно отрисовка, Paint Paint или Repaint для последующих повторных операций.
          Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.
          Отрисовка тоже бывает глобальной и инкрементальной.
            Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.
              Отрисовка — это самый дорогой процесс из всех, что мы уже перечислили.
    ?Reflow
      Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.
        Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.
        Один цикл обновления — это animation frame.
      Если же изменения затрагивают содержимое, структуру документа, положение элементов — происходит reflow (или relayout). Причинами таких изменений обычно являются:
        -Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
        -Изменение содержимого, в т.ч. текста в полях форм;
        -Расчёт или изменение CSS-свойств;
        -Добавление, удаление таблиц стилей;
        -Манипуляции с атрибутом «class»;
        -Манипуляции с окном браузера — изменения размеров, прокрутка;
        -Активация псевдо-классов (например, :hover).
    ?Repaint
      Repaint
        Вызвать Repaint могут изменения свойств color, background, visibility и подобных, в общем свойств которые не изменяют размеров и положения элемента, более полный список можно просмотреть в этой таблице http://goo.gl/lPVJY6 . 
        Если какие либо из этих свойств изменяются при анимации, тогда происходит Repaint элементов которые были затронуты и слои (об этом подробнее в разделе о Composite) к которым принадлежат эти элементы обрабатываются GPU.


  +Timers
    ?clearTimeout
      Отмена через clearTimeout
        Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.
        let timerId = setTimeout(...); clearTimeout(timerId);
    ?requestAnimationFrame (optional)
      window.requestAnimationFrame указывает браузеру на то, что вы хотите произвести анимацию, и просит его запланировать перерисовку на следующем кадре анимации. В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
      Примечание: Ваш callback метод сам должен вызвать requestAnimationFrame() иначе анимация остановится.
      Вы должны вызывать этот метод всякий раз, когда готовы обновить анимацию на экране, чтобы запросить планирование анимации. Обычно запросы происходят 60 раз в секунду, но чаще всего совпадают с частотой обновления экрана. 
      В большинстве браузеров в фоновых вкладках или скрытых <iframe>, вызовы requestAnimationFrame() приостанавливаются, для того, чтобы повысить производительность и время работы батареи.
      window.requestAnimationFrame(callback);  callback - Функция, которая будет вызвана, когда придёт время обновить вашу анимацию на следующей перерисовке.
      Возвращаемое значение
        requestID — длинное целое, являющееся уникальным идентификатором для записи, содержащей callback. Оно не равно нулю, но других предположений о его значении делать не следует. Вы можете передать его в window.cancelAnimationFrame() для отмены вызова.
      */
       // Анимируем
      function animate(highResTimestamp) {
        requestAnimationFrame(animate);
        // Анимируем что-нибудь…
        }
        // Запускаем анимацию.
        requestAnimationFrame(animate);
      /*
    ?Be able to explain difference between setTimeout and requestAnimationFrame (optional)
      requestAnimationFrame и setTimeout немного похожи. Разница в том, что setTimeout вызывается после ожидания указанного количества миллисекунд, а requestAnimationFrame вызывается каждый раз при обновлении экрана. 
        Обратите внимание, что обновление экрана здесь не означает, что страница обновляется. Метод requestAnimationFrame имеет только один параметр. Переданный метод будет вызываться при следующем обновлении экрана 
        Группирует несколько вызовов в один, что позволяет браузеру оптимизировать перерисовку.
        (на самом деле он помещается в очередь вызовов, а не выполняется немедленно). 
  +Web Storage API & cookies
    ?Cookies (concept)
      Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.
      Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.
        Один из наиболее частых случаев использования куки – это аутентификация:
          1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
          2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
          3. Таким образом, сервер понимает, кто сделал запрос.
    ?Difference between localStorage, sessionStorage, session and cookies
      Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.
      Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage).
      Но ведь у нас уже есть куки. Зачем тогда эти объекты?
        *В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Поэтому мы можем хранить гораздо больше данных. Большинство браузеров могут сохранить как минимум 2 мегабайта данных (или больше), и этот размер можно поменять в настройках.
        *Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
        *Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
        localStorage - Совместно используется между всеми вкладками и окнами с одинаковым источником. «Переживает» перезапуск браузера
        sessionStorage - Разделяется в рамках вкладки браузера, среди ифреймов из того же источника. «Переживает» перезагрузку страницы (но не закрытие вкладки)

    !Web Communication Protocols: (optional)
  +HTTP core
    HTTP был разработан как протокол обмена данными между веб-сервером и веб-браузером. Это протокол прикладного уровня модели OSI, который используется для передачи между клиентом и сервером файлов HTML, CSS, JS, API, картинок, аудио, видео, введённых пользователем данных и прочего. 
      HTTP-сообщения: запросы и ответы
        Данные между клиентом и сервером в рамках работы протокола передаются с помощью HTTP-сообщений. Они бывают двух видов:
          - Запросы (HTTP Requests) — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.
          - Ответы (HTTP Responses) — сообщения, которые сервер отправляет в ответ на клиентский запрос.
        В целом, как запросы HTTP, так и ответы имеют следующую структуру:
          - Стартовая строка (Start Line) — содержит информацию о типе сообщения и его параметрах. //? Запрос: GET /index.html HTTP/1.1. | Ответ: HTTP/1.1 200 OK.
              1. Метод (Method) — Методы позволяют указать конкретное действие, которое мы хотим, чтобы сервер выполнил, получив наш запрос.
              2. Цель запроса. Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.
                  URL (Uniform Resource Locator) представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров. //? Пример: https://www.google.com/search?q=javascript.
                    -Поле Scheme используется для указания используемого протокола, всегда сопровождается двоеточием и двумя косыми чертами (://).
                    -Host содержит доменное имя или IP-адрес сервера, на котором расположен запрашиваемый ресурс.
                    -Port Port, как можно догадаться, позволяет указать номер порта, по которому следует обратиться к серверу. Оно начинается с двоеточия (:), за которым следует номер порта. При отсутствии данного элемента номер порта будет выбран по умолчанию в соответствии с указанным значением Scheme (например, для http:// это будет порт 80).
                    -Path Далее следует поле Path. Оно указывает на ресурс, к которому производится обращение. Если данное поле не указано, то сервер в большинстве случаев вернет указатель по умолчанию (например index.html).
                    -Query String начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа амперсанд (&) в качестве разделителя.
              3. Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.
          - Заголовки (Headers) — содержат дополнительную информацию о сообщении. //? Запрос: Host: developer.mozilla.org. | Ответ: Content-Type: text/html.
          - Тело сообщения (Message Body) — Опциональное тело сообщения, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе. //? Запрос: <html>...</html>. | Ответ: <html>...</html>.
              Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. 
              Некоторые виды запросов  могут отправлять данные на сервер в теле запроса: самый распространенный из таких методов — POST.
    +Заголовки HTTP 
      HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы.
      В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:
        -Общего назначения, которые применяются ко всему сообщению целиком.
        -Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.
        -Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.
      Самые частые заголовки запроса:
        -Cookie — Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value.
        -Authorization — Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. 
                          В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера.
        -Accept — Заголовок, который сообщает серверу, какие типы данных клиент может обработать.
        -Refer - Заголовок, который сообщает серверу, с какой страницы был сделан запрос.
        -User-Agent — Заголовок, который сообщает серверу, какой браузер и операционная система используются клиентом.
        -Host — Заголовок, который сообщает серверу, какой домен был указан в адресной строке браузера.
      Заголовки ответа
        -Server — Содержит информацию о сервере, который обработал запрос.
        -Content-Type — Тип данных, которые содержатся в теле ответа. Content-Type: text/html; charset=utf-8 Content-Type: multipart/form-data;
        -Content-Length — Длина тела ответа в байтах.
        -Set-Cookie — Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов.
        -WWW-Authenticate — Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.
  +HTTP methods
    Методы запроса описывают тип обработки данных, который клиент хочет осуществить. Доступны следующие методы:
      -POST — Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. 
              Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.
      -GET — Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value).
      -PUT — служит для изменения (или вставки) ресурса. Указывем ID ресурса, который хотим изменить, и передаем новые данные.
      -PATCH — Позволяет внести частичные изменения в указанный ресурс по указанному расположению.
      -DELETE — Позволяет удалить существующие ресурсы на сервере. 
      -OPTIONS — 	Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.
      -HEAD — то же, что и GET, но не содержит тело в сообщении ответа. Обычно HTTP метод HEAD используется для получения метаинформации об объекте без пересылки тела HTTP сообщения. 
      -TRACE — HTTP метод TRACE применяется для диагностики, он позволяет видеть клиенту, что происходит в каждом звене цепочки между компьютером клиента и конечным получателем, для этого существует специальное поле Via.
      -CONNECT — переводит текущее соединение в TCP/IP-туннель. Обычно этот метод используется для установления защищённого SSL-соединения.
  +HTTP status codes groups
        Код состояния в ответе сервера содержит информацию о результате обработки данных. Существует пять классов кодов состояний:
      1xx — информационные;
        100 — Continue — сервер получил первую часть данных и готов принять остальную часть;
        101 — Switching Protocols — сервер согласен на переключение протоколов;
      2xx — успешная обработка данных;
        200 — OK — данные успешно обработаны;
        201 — Created — данные успешно созданы;
        202 — Accepted — данные успешно приняты;
      3xx — перенаправление запросов;
        300 — Multiple Choices — несколько вариантов ответа;
        301 — Moved Permanently — данные перемещены навсегда(возможно в заголовках ответа будет указан новый адрес);
      4xx — ошибка по вине клиента;
        400 — Bad Request — неверный запрос;
        401 — Unauthorized — неавторизованный запрос;
        403 — Forbidden — запрещено;
        404 — Not Found — данные не найдены;
      5xx — ошибка по вине сервера.
        500 — Internal Server Error — внутренняя ошибка сервера;
        501 — Not Implemented — сервер не поддерживает возможность обработки запроса;
        502 — Bad Gateway — неверный шлюз;
        503 — Service Unavailable — сервис недоступен;
  +RESTful API
    REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса. REST сейчас — один из самых распространённых стилей API в интернете.
      Отличительная особенность этого стиля — это стиль построения адресов и выбор метода. Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
        -созданию чего-либо, например, объекта пользователя (create, C); POST для создания;
        -чтению (read, R); GET для чтения;
        -обновлению (update, U); PUT, PATCH для обновления; Разница между PUT и PATCH в том, что PUT обновляет объект целиком, а PATCH — только указанное поле.
        -удалению (delete, D). DELETE для удаления.
      Адрес, как правило, остаётся почти одинаковым, а детали запроса указываются в HTTP-методе и параметрах или теле запроса. 
  +HTTP vs HTTPS vs HTTP/2
    ?HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. 
      Проблема протокола HTTP в том, что данные передаются по сети в открытом незашифрованном виде. Это позволяет злоумышленнику слушать передаваемые пакеты и извлекать любую информацию из параметров, заголовков и тела сообщения. 
      Для устранения уязвимости был разработан HTTPS - он, хоть не является отдельным протоколом, всего лишь HTTP поверх SSL (а позже TLS), позволяет безопасно обмениваться данными. 
      Перед тем как установить защищённое соединение, браузер запрашивает этот документ и обращается к центру сертификации, чтобы подтвердить легальность документа. Если он действителен, то браузер считает этот сайт безопасным и начинает обмен данными.
      Как работает шифрование
        У ресурса/сайта, поддерживающего HTTPS, есть SSL/TLS-сертификат, который выдается центром сертификации. Посмотреть информацию о сертификате и его подлинности можно, нажав на значок.
        Как правило, SSL/TLS-сертификат — это подтверждение, что ресурс настоящий.
        Перед тем как запустить HTTP-соединение, браузер обращается к серверу, чтобы наладить защищенное соединение. Сервер отправляет копию сертификата безопасности в ответ. 
        Браузер проверяет данные по своим спискам доверенных центров (список есть в каждом браузере), проверяет совпадение CN с доменным именем, даты выпуска и срока окончания сертификата, отсутствие в CRL, 
          поддерживаемые алгоритмы, наличие издателя в списке доверенных корневых сертификатов и в списке доверенных издателей. В случае проблем на любой из этих проверок сертификат считается невалидным.
        Если все хорошо, то браузер считает ресурс безопасным: они выбирают алгоритм шифрования, обмениваются ключом шифрования и потом данными по протоколу HTTP.
      Типы SSL/TLS-сертификатов и кто их выдает
        Сертификаты бывают разные: групповые, многодоменные, подтверждающие организацию.
      Как подключить SSL/TLS-сертификат
        Эту услугу предлагают хостинг-провайдеры и платформы для создания веб-сайтов. Самостоятельное подключение производится через панель администратора.
      Optional (SSL/TLS)
        Secure Sockets Layer (SSL) - это криптографический протокол, обеспечивающий безопасное общение пользователя и сервера по небезопасной сети. Располагается между транспортным уровнем и уровнем программы-клиента (FTP, HTTP и т.п.)
        TLS Transport Layer Security - это развитие идей, заложенных в протоколе SSL. 
          Протокол обеспечивает услуги: приватности (сокрытие передаваемой информации), целостности (обнаружение изменений), аутентификации (проверка авторства). 
          Достигаются они за счет гибридного шифрования, то есть совместного использования ассиметричного и симметричного шифрования.
            -Симметричное шифрование предполагает наличие общего ключа одновременно у отправителя и получателя, с помощью которого происходит шифровка и дешифровка данных. Данный тип не требователен к ресурсам,
              однако существенно страдает безопасность из-за опасности кражи ключа злоумышленником.
            -При использовании ассиметричного шифрования существует открытый ключ, который можно свободно распространять, и закрытый ключ, который держится в секрете у одной из сторон. Этот тип работает медленно, 
              относительно симметричного шифрования, однако скомпрометировать закрытый ключ сложнее. 
            -Чтобы решить проблему производительности (шифровать ассиметрично абсолютно все - сложно), в TLS используется гибридное шифрование: общий ключ для симметричного шифрования данных передается от клиента серверу 
              зашифрованным открытым ключом сервера, после этого сервер может его расшифровать своим закрытым ключом и использовать для обмена данными с клиентом.
    ?HTTP/2 (изначально HTTP/2.0) — вторая крупная версия сетевого протокола HTTP. Браузерная поддержка HTTP/2 включает в себя HTTPS-шифрование
      HTTP/2 является первой новой версией HTTP с версии HTTP 1.1, которая была стандартизирована RFC 2616 в 1999. 
        -Протокол HTTP/2 является бинарным. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом.
        -В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, 
          без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.
        -Также часть улучшений получена (в первом черновике HTTP/2, который представлял собой копию спецификации SPDY) за счёт мультиплексирования запросов и ответов (для преодоления проблемы «head-of-line blocking» 
          протоколов HTTP/1.x), а также за счёт сжатия передаваемых заголовков и введения явной приоритизации запросов.
  +OSI model
        Чтобы описать архитектуру и принципы работы сетей передачи данных. Процесс, когда информация отправляется и переходит из данных в биты, называется инкапсуляцией, а обратно декапсуляцией.
      Уровни группы Media Layers (L1, L2, L3) занимаются передачей информации (по кабелю или беспроводной сети), используются сетевыми устройствами, такими как коммутаторы, маршрутизаторы и т.п. 
      Уровни группы Host Layers (L4, L5, L6, L7) используются непосредственно на устройствах, будь то стационарные компьютеры или портативные мобильные устройства.
      7. Прикладной уровень -  это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму.
          Все услуги, получаемые седьмым уровнем от других, используются для доставки данных до пользователя. Протоколам седьмого уровня не требуется обеспечивать маршрутизацию или гарантировать доставку данных, когда об этом уже позаботились предыдущие шесть. 
          Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.
          Протоколы здесь используют UDP (например, DHCP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS).
      6. Уровень представления - Шестой уровень занимается тем, что представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. 
          Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне.
          Шестой уровень также занимается представлением картинок (в JPEG, GIF и т.д.), а также видео-аудио (в MPEG, QuickTime). Помимо перечисленного, шестой уровень занимается шифрованием данных, когда при передаче их необходимо защитить.
      5. Сеансовый уровень - Сеансовый уровень отвечает за поддержку сеанса или сессии связи.
          Примером работы пятого уровня может служить видеозвонок по сети. Во время видеосвязи необходимо, чтобы два потока данных (аудио и видео) шли синхронно. Когда к разговору двоих человек прибавится третий — получится уже конференция. Задача пятого уровня — сделать так, чтобы собеседники могли понять, кто сейчас говорит.
      4. Транспортный уровень - Четвертый уровень — это посредник между Host Layers и Media Layers, относящийся скорее к первым, чем к последним, его главной задачей является транспортировка пакетов. Естественно, при транспортировке возможны потери, но некоторые типы данных более чувствительны к потерям, чем другие. 
          При передаче данных, наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации. 
          Для передачи наиболее чувствительных к задержкам, используется протокол UDP,
      3. Сетевой уровень - Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.
          На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот, тем самым обеспечивается инкапсуляция и декапсуляция данных.
      2. Канальный уровень - Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). Задача здесь — сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети. У канального уровня есть два подуровня — это MAC и LLC. 
      1. Физический уровень -  обмен физическими сигналами между физическими устройствами, «железом». Устройства физического уровня оперируют битами. (оптоволокно, кабель, радиоволна, 4G)
+Network requests
    ?Fetch (with usage)
      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
        -Promise возвращаемый вызовом fetch() не перейдёт в состояние "отклонено" из-за ответа HTTP, который считается ошибкой, даже если ответ HTTP 404 или 500. Вместо этого, он будет выполнен нормально (с значением false в статусе ok ) 
          и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
        -По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в результате чего запросы будут осуществляться без проверки подлинности, что приведёт к неаутентифицированным запросам, 
          для отправки cookie файлов в аргументе init options должно быть задано значение свойства credentials отличное от значения по умолчанию omit.
        Типичный запрос с помощью fetch состоит из двух операторов await:
        Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.
        Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
          */
        let response = await fetch(url, options); // завершается с заголовками ответа
        let result = await response.json(); // читать тело ответа в формате JSON
        /*
        Или, без await:
        */
        fetch(url, options)
          .then(response => response.json())
          .then(result => {/* обрабатываем результат */});
        /*
        Параметры ответа:
          response.status – HTTP-код ответа,
          response.ok – true, если статус ответа в диапазоне 200-299.
          response.headers – похожий на Map объект с HTTP-заголовками.
        Методы для получения тела ответа:
          response.text() – возвращает ответ как обычный текст,
          response.json() – преобразовывает ответ в JSON-объект,
          response.formData() – возвращает ответ как объект FormData (кодировка form/multipart),
          response.blob() – возвращает объект как Blob (бинарные данные с типом),
          response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
        Опции fetch, которые мы изучили на данный момент:
          method – HTTP-метод,
          headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
          body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
        Установка параметров запроса
          Метод fetch() может принимать второй параметр - объект init, который позволяет вам контролировать различные настройки:
          */
           // Default options are marked with *
          const response = await fetch(url, {
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
              'Content-Type': 'application/json'
              // 'Content-Type': 'application/x-www-form-urlencoded',
            },
            redirect: 'follow', // manual, *follow, error
            referrerPolicy: 'no-referrer', // no-referrer, *client
            body: JSON.stringify(data) // body data type must match "Content-Type" header
          });
          /*
    ?XMLHTTPRequest (concept) (optional)
      XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
      В современной веб-разработке XMLHttpRequest используется по трём причинам:
        -По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.
        -Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).
        -Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.
      Типичный код GET-запроса с использованием XMLHttpRequest:
      */
      let xhr = new XMLHttpRequest();

      xhr.open('GET', '/my/url');
      
      xhr.send();
      
      xhr.onload = function() {
        if (xhr.status != 200) { // HTTP ошибка?
          // обработаем ошибку
          alert( 'Ошибка: ' + xhr.status);
          return;
        }
      
        // получим ответ из xhr.response
      };
      
      xhr.onprogress = function(event) {
        // выведем прогресс
        alert(`Загружено ${event.loaded} из ${event.total}`);
      };
      
      xhr.onerror = function() {
        // обработаем ошибку, не связанную с HTTP (например, нет соединения)
      };
      /*
    ?WebSocket (concept) (optional)
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. 
        Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
      WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws: //? let socket = new WebSocket("ws://javascript.info");
      Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь Websocket?» и если сервер отвечает «да», они начинают работать по протоколу WebSocket, который уже не является HTTP.
      Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
        -open – соединение установлено,
        -message – получены данные,
        -error – ошибка,
        -close – соединение закрыто.
      Методы:
        -socket.send(data),
        -socket.close([code], [reason]).
      Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.
      WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.
        -Нет ограничений, связанных с кросс-доменными запросами.
        -Имеют хорошую поддержку браузерами.
        -Могут отправлять/получать как строки, так и бинарные данные.
!Common web-security knowledge (optional)
  +Basic understanding of most common security terms (CORS, XSS) (optional)
    Веб-приложения, как и любые другие, можно «взломать». Если в приложении есть место, куда можно ввести текст, загрузить изображение, передать какую-то информацию, злоумышленники могут использовать это место для атаки.
      Уязвимостей у веб-приложений много.
    ?XSS
      Cross Site Scripting — это внедрение вредоносного кода на страницы атакуемого сервиса.
        Злоумышленник вводит <script>alert('XSS!');</script> в поле поиска;
        В нашем случае <script>alert('XSS!');</script> встраивается на страницу, и срабатывает alert().
        Конечно, вместо alert() злоумышленники могут написать более изощрённый скрипт, который будет, например, рассылать спам от имени пользователя.
        Атака выше — это пример отражённого XSS (reflected XSS). Отражённого, потому что его действие сразу же отражается на поведении страницы. Кроме него есть хранимый (stored) XSS, о нём поговорим чуть дальше.
      Как защититься
        Экранировать любой пользовательский ввод! Каким бы маленьким и незначительным ни казалось поле ввода, всё, что пользователь пишет, следует экранировать.
        Экранирование (escaping) — это замена специальных символов (например, которые браузер может принять за теги) другими, безопасными.
        При экранировании запись <script>alert('XSS!');</script> превратится в &lt;script&gt;alert('XSS!');&lt/script&gt;. Такую запись браузер не распознает как тег или скрипт.
        Для экранирования пользовательского ввода в JS следует использовать:
          -encodeURI() — чтобы кодировать URI-адрес
          -encodeURIComponent() — кодировать часть URI-адреса, например, searchQuery
          -специальные библиотеки для замены <, >, ', " и других специальных символов.
          Также на сервере следует проверять и при необходимости экранировать все данные, приходящие от клиента.
    ?CORS
      Cross-Origin Resource Sharing (CORS) — это механизм, который позволяет предоставить доступ к ресурсам с другого домена.
        Например, наш сайт находится по адресу https://example.com, а наш API — https://api.example.com. Если мы хотим получить данные с API, то нам нужно будет пройти через CORS.
      Как работает CORS
        Как настроить CORS:
          -Access-Control-Allow-Origin: * — разрешить запросы с любого домена (на стороне сервера) либо с указанных доменов (например, https://example.com)
          -Access-Control-Allow-Credentials: true — разрешить куки
          -Access-Control-Allow-Methods: GET, POST, PUT, DELETE — разрешить запросы с указанными методами
          -Access-Control-Allow-Headers: Content-Type — разрешить заголовки с указанными полями
        Типы запросов:
          -Simple request — это запрос, который не содержит в себе никаких специальных заголовков, например, Content-Type. Такие запросы можно отправлять без предварительного запроса OPTIONS. GET POST HEAD
          -Preflight request — это запрос, который содержит в себе специальные заголовки, например, Content-Type. Такие запросы нужно отправлять с предварительным запросом OPTIONS.
        При отправке запроса с помощью fetch() браузер автоматически отправляет предварительный запрос OPTIONS. Если сервер разрешает такие запросы, то fetch() отправит основной запрос.
      Cross-Site Request Forgery
        Межсайтовая подделка запроса (Cross-Site Request Forgery, CSRF) — атака, при которой злоумышленники могут совершать действия как бы от лица пользователя.
        Злоумышленники знают, что после логина в Switter у пользователя остаются куки, которые потом используются для аутентификации. Они могут:
          -Заманить пользователя, который был аутентифицирован в Switter, на вредоносную страницу;
          -Используя его или её куки отправить запрос к Switter с «просьбой» переслать денег на конкретный аккаунт;
          -Так как пользователь «аутентифицирован» запрос считается «валидным», пользователь теряет деньги.
        Проблемы здесь две:
          -Злоумышленники могли увидеть куки пользователя и таким образом выдать себя за него.
          -Сервису Switter достаточно аутентификации для перевода денег, он не требует авторизации запроса.
          Авторизацию не следует путать с аутентификацией.
            Аутентификация — подтверждение личности (Вася — это действительно Вася).
            Авторизация — подтверждение, что у пользователя хватает прав, чтобы выполнить какое-то действие (Марина действительно хочет перевести деньги, вот подтверждение).
      Как защититься Секция статьи "Как защититься"
        В первую очередь куки следует выставлять так, чтобы они были видны лишь для сервиса, который их выставил. Для этого можно использовать SameSite Cookie: Set-Cookie: key=value; SameSite=Strict
        Также, если с куками не должны работать клиентские скрипты, их можно спрятать: Set-Cookie: key=value; HttpOnly Это сделает куку видимой только для сервера и самого браузера (но в клиентском JS её использовать будет нельзя).
        Также можно использовать CSRF-токены для подписи каждого запроса, который необходимо авторизовать. Такой токен гарантирует, что запрос был отправлен пользователем не случайно.
        Для AJAX-запросов следует указывать CSP и CORS-политику. Cross-Origin Resource Sharing, CORS — определяет, доступ к каким ресурсам есть у запросов с другого домена (origin).
    ?OWASP Top 10 (Open Web Application Security Project)
      Отчет об уязвимостях OWASP формируется на основе консенсуса мнений экспертов по безопасности со всего мира. Он ранжирует риски на основе частоты дефектов, серьезности уязвимостей и их потенциального воздействия. 
        Это дает разработчикам и специалистам по безопасности понимание наиболее серьезных рисков и позволяет им минимизировать возможные последствия эксплуатации уязвимостей злоумышленниками.
        В последнем отчете OWASP перечислены 10 основных уязвимостей:
          -Инъекции (Injections).
            Инъекционные атаки происходят, когда ненадежные данные передаются интерпретатору кода через ввод формы или с помощью другого способа отправки информации в веб-приложение.
          -Нарушенная аутентификация (Broken Authentication).
            Уязвимости аутентификации могут позволить злоумышленникам получить доступ к учетным записям пользователей, включая привилегированные, которые затем можно использовать для получения контроля над корпоративными информационными системами.
          -Раскрытие критически важных данных (Sensitive Data Exposure).
            Основная причина риска раскрытия критически важных данных связана с отсутствием шифрования или с использованием ненадежных методов генерации и управления ключами, слабых алгоритмов шифрования, ненадежных способов хранения паролей и т.д.
          -Внешние объекты XML (XXE) (XML External Entities (XXE)).
            Атаки XXE нацелены на веб-приложения, которые анализируют расширяемый язык разметки (XML). Они возникают, когда ввод содержащего ссылку на внешний объект кода XML обрабатывается синтаксическим анализатором со слабой конфигурацией.
          -Нарушенный контроль доступа (Broken Access control).
            Проблемы с контролем доступа позволяют злоумышленникам обойти заданные ограничения и получить несанкционированный доступ к системам и конфиденциальным данным, а также потенциально получить доступ к учетным записям администраторов и привилегированных пользователей.
          -Неправильная конфигурация безопасности (Security misconfigurations).
            Ошибки настройки безопасности считаются наиболее распространенной уязвимостью в рейтинге OWASP Top 10. Чаще всего они связаны с использованием стандартных настроек веб-сайтов или системы управления контентом (CMS).
          -Межсайтовый скриптинг (XSS) (Cross Site Scripting (XSS)).
            Уязвимости XSS позволяют киберпреступникам внедрять скрипты на веб-сайт и использовать его для распространения выполняющегося в браузере пользователя вредоносного кода. Как правило это нужно для перехвата пользовательских сеансов, кражи конфиденциальных данных или перенаправления пользователя на вредоносные сайты.
          -Небезопасная десериализация (Insecure Deserialization).
            В терминах хранения данных и информатики сериализация означает преобразование объектов или структур данных в байтовые строки. Десериализация означает преобразование этих байтовых строк в объекты. Небезопасная десериализация предполагает, что злоумышленники изменяют данные до того, как они будут десериализованы.
          -Использование компонентов с известными уязвимостями (Using Components with known vulnerabilities).
            Программные компоненты, такие как фреймворки и библиотеки, часто используются в веб-приложениях для обеспечения определенных функций. Однако эти компоненты могут содержать уязвимости, позволяющие злоумышленнику начать кибератаку.
          -Недостаточно подробные журналы и слабый мониторинг (Insufficient logging and monitoring).
            Успешную хакерскую атаку или утечку данных удается обнаружить далеко не всегда. Часто злоумышленники не только получают несанкционированный доступ к информационным системам, но хозяйничают в них месяцами или годами, оставаясь невидимыми. 
              Чтобы этого не произошло, необходимо регистрировать и отслеживать поведение веб-приложения, чтобы своевременно распознать подозрительную активность и либо предотвратить атаку, любо минимизировать ее последствия.
    ?Auth (JWT, OAuth, Basic, etc.)
      ?HTTP Basic Auth
        HTTP Basic Auth HTTP базовая аутентификация - это метод проверки входа в систему, который позволяет веб-браузерам или другим клиентским программам предоставлять учетные данные в виде имен пользователей и паролей по запросу. Обычно имена пользователей и чистые коды передаются через заголовки HTTP.
        Перед отправкой к имени пользователя добавляется двоеточие, затем пароль соединяется, и результирующая строка символов затем кодируется с помощью алгоритма Base64. 
        Например, если предоставленное имя пользователя - Aladdin, а пароль - «открытый кунжут», то результат после объединения - «Aladdin: открыть кунжут», а затем использовать его.Кодировка Base64Чтобы получить QWxhZGRpbjpvcGVuIHNlc2FtZQ ==. 
        Наконец, строка в кодировке Base64 отправляется, и получатель декодирует ее, чтобы получить строку имен пользователей и паролей, разделенных двоеточиями.
          Преимущество
            базовой аутентификации состоит в том, что в основном все популярные веб-браузеры поддерживают базовую аутентификацию.
          недостаток
            Поскольку имя пользователя и пароль кодируются как Base64, а кодирование Base64 является обратимым, имя пользователя и пароль можно рассматривать как обычный текст. Поэтому его можно использовать только в том случае, если соединение между клиентом и хостом сервера является безопасным и надежным.
      ?OAuth
        OAuth - это открытый сетевой стандарт для авторизации. Разрешить пользователям предоставлять токен вместо имени пользователя и пароля для доступа к данным, которые они передали конкретному поставщику услуг. Текущая версия - версия 2.0.
        Строго говоря, OAuth2 - это не стандартный протокол, а безопасная структура авторизации. Подробно описывается, как разные роли, пользователи, интерфейсные приложения служб (например, API-интерфейсы) и клиенты (например, веб-сайты или мобильные приложения) реализуют взаимную аутентификацию.
      ?Сертификация JWT
        Json web token (JWT)Согласно определению официального сайта, это открытый стандарт на основе JSON (RFC 7519), который реализован для передачи операторов между средами сетевых приложений. 
          Токен спроектирован так, чтобы быть компактным и безопасным, и особенно подходит для одной точки распределенных сайтов. Сценарий входа в систему (SSO).
        Особенности JWT
          -Малый размер, высокая скорость передачи
          -Различные способы передачи, могут быть переданы через URL / параметры POST / HTTP-заголовок и другие методы
          -Строго структурированный Само по себе (в полезной нагрузке) содержит все относящиеся к пользователю сообщения аутентификации, такие как доступная пользователю маршрутизация, период действия доступа и т. Д. Серверу не нужно подключаться к базе данных для проверки достоверности информации, а полезная нагрузка поддерживает настройку для вашего приложения. из.
          -Поддержка междоменной аутентификации, может применяться для единого входа.
        Принцип JWT
          Токен JWT состоит из трех частей: заголовка (header), полезной нагрузки (payload) и подписи или данных шифрования. Первые два элемента — это JSON объекты определенной структуры. 
          Третий элемент вычисляется на основании первых и зависит от выбранного алгоритма (в случае использования неподписанного JWT может быть опущен). 
          Токены могут быть перекодированы в компактное представление (JWS/JWE Compact Serialization): к заголовку и полезной нагрузке применяется алгоритм кодирования Base64-URL, после чего добавляется подпись и все три элемента разделяются точками («.»).
          JWT - это схема, предложенная Auth0 для реализации проверки авторизации путем шифрования и подписывания JSON. Закодированный JWT выглядит следующим образом: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ  
          К.Он разделен на три раздела, которые можно получить путем декодирования:
            1. Заголовок jwt содержит две части информации:
              -Тип объявления, вот JWT
              -Заявленные алгоритмы шифрования обычно используют HMAC SHA256 напрямую
              Заголовок затем шифруется с помощью base64 (шифрование может быть расшифровано симметрично) для формирования первой части. eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
              */
              {
                "alg": "HS512",
                "typ": "JWT"
              }
              /*
            2. В данной секции указывается пользовательская информация (например, имя пользователя и уровень его доступа), а также могут быть использованы некоторые служебные ключи. Все они являются необязательными:
              */
              // Включая информацию о пользователе для передачи;
              { "iss": "Online JWT Builder", 
              "iat": 1416797419, 
              "exp": 1448333419, 
              "aud": "www.gusibi.com", 
              "sub": "uid", 
              "nickname": "goodspeed", 
              "username": "goodspeed", 
              "scopes": [ "admin", "user" ] 
              }
              /*
              -iss: используется ли эмитент этого JWT, необязательно;
              -sub: используется ли пользователь, на который нацелен этот JWT, или нет;
              -aud: используется ли сторона, получающая JWT, или нет;
              -exp (expires): когда он истекает, здесь есть метка времени Unix, использовать ли ее необязательно;
              -iat (выдан в): когда он был выпущен (время UNIX), использовать его необязательно;
            3. Третья часть jwt - это подпись, которая используется для проверки того, что JWT не был изменен в пути. Это создается с помощью следующего алгоритма:
              -Сначала заголовок и тело объединяются в одну строку, разделенную точкой;
              -Затем эта строка шифруется с помощью секретного ключа, который затем шифруется с помощью base64 для формирования третьей части. Вот как это выглядит:
              */
              // Подпись
              HMACSHA256(
                base64UrlEncode(header) + "." +
                base64UrlEncode(payload),
                secret
              )
              /*
          Access и refresh токены
            -Access-токен — это токен, который предоставляет доступ его владельцу к защищенным ресурсам сервера. Обычно он имеет короткий срок жизни и может нести в себе дополнительную информацию, такую как IP-адрес стороны, запрашивающей данный токен.
            -Refresh-токен — это токен, позволяющий клиентам запрашивать новые access-токены по истечении их времени жизни. Данные токены обычно выдаются на длительный срок.

!Coding tasks:

  +Function.prototype.bind implement polyfill
    */
  if (!Function.prototype.bind) {
    Function.prototype.bind = function(context, ...args) {
      let object = {...context}; // создаем объект и копируем в него контекст
      let symbol = Symbol('target'); // создаем символ уникальный
      object[symbol] = this; // добавляем в объект свойство с ключом символ и значением this
      return function(...rest) {  // возвращаем функцию 
        return object[symbol](...args, ...rest); // вызываем функцию с контекстом и аргументами
      };
    };
  }

  function bind (context, fn) {
    return function (...args) {
      return fn.apply(context, args);
    }
  }
  /*
  +Object.create implement polyfill
    */
  if (!Object.create) {
    Object.create = function(base) {
      function F() {}; // создаем функцию
      F.prototype = base; // прототип функции равен базовому объекту
      return new F(); // возвращаем новый объект
    }
  }
  /*
  +Array.flat implement polyfill
    */
  if (!Array.prototype.flat)
  Array.prototype.flat = function (depth = 1) {
    depth = isNaN(depth) ? 0 : Math.floor(depth); // если глубина не число, то присваиваем 0, иначе округляем в меньшую сторону
  if (depth < 1) return this.slice(); // если глубина меньше 1 возвращаем копию массива
  return [].concat( 
        ...(depth < 2) // если глубина меньше 2
          ? this // возвращаем массив
          : this.map(v => Array.isArray(v) ? v.flat(depth - 1) : v) // иначе рекурсивно вызываем flat
    )
  };
  /*
  +Array.reduce implement polyfill
  */
  Array.prototype.myReduce= function(callbackFn, initialValue) {
    let accumulator = initialValue;
  for (let i = 0; i < this.length; i++) {
      if (accumulator !== undefined) {
        accumulator = callbackFn.call(undefined, accumulator, this[i],   i, this); // вызываем функцию с аргументами и контекстом undefined
      } else {
        accumulator = this[i]; // если аккумулятор не определен, то присваиваем значение первого элемента
      }
    }
    return accumulator;
  }
  /*
  +'hello world'.repeating(3) -> 'hello world hello world hello world'. How to implement?
    */
  String.prototype.repeating = function (count) {
    let res = '';
    for (let i = 0; i < count; i++) {
      res += this;
    }
    return res;
  }
    /*
  +myFunc('!', 4, -10, 34, 0) -> '4!-10!34!0`. How to implement?
  */
  function myFunc (separator, ...arg) {
    return arg.join(separator);
  }
  /*
  +five(plus(seven(minus(three())))) -> 9. How to implement?
   */
    const five = (func) => func ? func(5) : 5;
    const seven = (func) => func ? func(7) : 7;
    const three = (func) => func ? func(3) : 3;
    const minus = (num) => (num2) => num2 - num;
    const plus = (num) => (num2) => num2 + num;
    five(plus(seven(minus(three()))))
    /*
  +add(5)(9)(-4)(1) -> 11. How to implement?
    */
  function add(num) { // 
    let sum = num;  // создаем переменную и присваиваем ей значение аргумента
    function f(num2) { // создаем функцию
      sum = sum + num2; // прибавляем к сумме значение аргумента
      return f; // возвращаем функцию
    }
    f.toString = function () { // переопределяем метод toString
      return sum; // возвращаем сумму
    }
    return f; // возвращаем функцию
  }
  /*
  +periodOutput(period) method should output in the console once per every period how mach time has passed since the first function call. Example: periodOutput(100) -> 100(after 100 ms), 200(after 100 ms), 300(after 100 ms), ...
  */
  function periodOutput(period) {
    let count = 0;
    let timer = setInterval(() => {
      count = count + period;
      console.log(count);
    }, period);
    return timer;
  }
  
  // periodOutput(100);//? 
  /*
  +extendedPeriodOutput(period) method should output in the console once per period how mach time has passed since the first function call and then increase the period. Example: // extendedPeriodOutput(100) -> 100(after 100 ms), 200(after 200 ms), 300(after 300 ms)
  */
  function extendedPeriodOutput(period) {
    let count = 0;
    const tick = () => {
      let timer = setTimeout(() => {
        count = count + period;
        console.log(count);
        tick();
      }, period);
    }
    tick();
  }
  /*
  !Typescript:

  +Ability to write concise TypeScript code using its constructs
    ?understanding TS(ES6) module system
      Модули предоставляют способ организации и классификации кода, позволяя группировать связанный код вместе. Кроме того, когда код находится внутри модуля, он извлекается из глобальной области в область модуля. 
        Это может помочь избежать конфликтов именования компонентов в глобальном пространстве имен.
        -!-Модули были реализованы в JavaScript начиная с ES6, поэтому они также поддерживаются TypeScript. До ES6 предыдущие версии TypeScript назывались "внешними модулями".
        Можно экспортировать любое объявление (например, переменную, функцию, класс, псевдоним типа или интерфейс), добавив ключевое слово export или импортировав его с помощью ключевого слова import. 
        Любой файл, содержащий import верхнего уровня или оператор export, считается модулем. 
        Оператор export явным образом делает компонент в одном модуле доступным для других модулей, а оператор import позволяет использовать этот компонент из другого модуля. 
        Модули являются декларативными; операторы import и export на уровне файлов описывают связи между ними.
    ?describing variables with primitive data types.
      Объявление переменных let и const:
        Типы с переменными можно связывать с помощью явных аннотаций типов или путем неявного определения типа. Явные аннотации типов — рекомендуемый, хотя и необязательный метод в TypeScript. 
        let x: number;   // Explicitly declares x as a number type
        let y = 1;       // Implicitly declares y as a number type
        let z;           // Declares z without initializing it как any type
      +Types and subtypes in TypeScript
        -Базовый Тип Any
          Это единственный тип, который может представлять любое значение JavaScript без ограничений. Все остальные типы делятся на примитивные, типы объектов или параметры типов.
          Поскольку тип any позволяет работать со значением динамически, это не вызывает ошибок при обращении к неописанным в типе членам, что сводит пользу от типизации к нулю.
        -Примитивные типы Number, String, Boolean, Symbol, BigInt
        -Примитивные типы Null, Undefined, Void, Never, Unknown
          void - void нужен лишь для того, чтобы указывать на отсутствие значения, например в функции без возвращаемого значения.
          never - Тип данных Never служит для указания того, что какие-либо операции никогда не будут выполнены. Такой сценарий может выражаться в виде функции, вызов которой приведет к однозначному исключению или тело функции будет включать бесконечный цикл.
          unknown - Тип unknown похож на тип any тем, что типу unknown можно присваивать любое значение. Однако вы не можете получить доступ к свойствам типа unknown, а также вызывать или создавать их.
                    Основное различие между any и unknown заключается в том, что вы не можете взаимодействовать с переменной типа unknown. Это вызывает ошибку компилятора. any обходит любые проверки во время компиляции. 
        -Примитивный тип Enum - (перечисление) enum представляет собой набор логически связанных констант, в качестве значений которых могут выступать как числа, так и строки.
                                Компилятор рассчитывает значение автоматически только на основе значения предыдущего члена перечисления.
                                */enum Keys {
                                  A = 10,
                                  B, // 11
                                  C = 20,
                                  D, // 21
                                }
                                // Перечисления со строковым значением
                                enum FruitColors {
                                  Red = '#ff0000',
                                  Green = '#00ff00',
                                  Blue = '#0000ff',
                                }
                                /*
        -Типы Union, Intersection
          Union (Объединение) - позволяющий создавать из множества существующих типов логическое условие, по которому данные могут принадлежать только к одному из указанных типов. let v1: T1 | T2 | T3;
          Intersection Type (Пересечение) - позволяет рассматривать множество типов данных как единое целое. Пересечение указывается с помощью оператора амперсанда & let v1: T1 & T2 & T3; значение должно принадлежать ко всем типам одновременно
        -Type Queries (запросы типа)
          позволяет получить тип, связанный со значением по его идентификатору и в дальнейшим использовать его как обычный тип.
          Запрос типа осуществляется оператором typeof, после которого идет идентификатор, ссылающийся на значение.
          */
          const STANDART_NORMAL = { x: 0, y: 0 };
          const example: typeof STANDART_NORMAL = {
            x: 0, 
            y: 0
          }
          /*
          С помощью данного механизма можно получить тип любой конструкции, будь то переменная, параметр функции или метода, а также член объекта и класса.
        -Alias (type) (псевдонимы типа) Псевдоним типа объявляется при помощи ключевого слова type, после которого следует идентификатор (имя) псевдонима, а за ним идет оператор присваивания =, справа от которого находится тип, ассоциирующийся с псевдонимом.
          Псевдонимы типов можно создавать как для типов объединений, так и для типов пересечений.
            type SomeType = number | string | boolean; // union type
            type OtheType = number & string & boolean; // intersection type
          Псевдонимы типов можно выносить в отдельные модули, а затем импортировать их в места назначения.
        -Object Помимо того, что в TypeScript существует объектный тип Object, представляющий одноименный конструктор из JavaScript, также существует тип object, представляющий любое объектное значение. 
          Поведение типа указанного с помощью ключевого слова object и интерфейса Object различаются. Переменные, которым указан тип с помощью ключевого слова object, не могут хранить значения примитивных типов, 
          чьи идентификаторы (имена) начинаются со строчной буквы (number, string и т.д.).
        -Array Тип данных Array указывается с помощью литерала массива, перед которым указывается тип данных type[]
          Если при объявлении массива указать тип string[], то он сможет хранить только элементы принадлежащие или совместимые с типом string (например null, undefined, literal type string).
          var animalAll: string[] = ['Elephant', 'Rhino', 'Gorilla'];
        -Tuple ([T0, T1, …, Tn]) Задает уникальный тип для каждого элемента массива. Перечисляемые типы обрамляются в квадратные скобки, а их индексация, так же как у массива начинается с нуля - [T1, T2, T3].
          let v0: [string, number] = ['Dambo', 1]; // Ok 
          Длина массива-значения должна соответствовать количеству типов, указанных в Tuple.
          Но это правило не мешает добавить новые элементы после того, как массив был присвоен ссылке (ассоциирован со ссылкой). Но элементы, чьи индексы выходят за пределы установленные кортежем, обязаны иметь тип, совместимый с одним из перечисленных в этом кортеже.
          let elephantData: [string, number] = ['Dambo', 1];
          elephantData.push(1941); // Ok
          elephantData.push(true); // Error, тип boolean, в то время, как допустимы только типы совместимые с типами string и number
        -Functional Types - Помимо того, что в TypeScript существует объектный тип Function, также существует функциональный тип, с помощью которого осуществляется описание сигнатур функциональных выражений.
          Функциональный тип обозначается с помощью пары круглых скобок (), после которых располагается стрелка, а после неё обязательно указывается тип возвращаемого значения () => type. 
          При наличии у функционально выражения параметров, их декларация заключается между круглых скобок (p1: type, p2: type) => type.
        -Interface — это синтаксическая конструкция предназначенная для описания открытой (public) части объекта без реализации (api).
          Класс, реализующий интерфейс, обязан реализовать все описанные в нём члены. Поэтому интерфейс является гарантией наличия описанных в нем характеристик у реализующего его объекта. Все члены описанные в интерфейсе неявно имеют модификатор доступа public.
          Реализация интерфейса (implements)
            Как уже было сказано в самом начале, все члены интерфейса являются открытыми (public) и их объявление не может содержать модификатор static. Кроме того, в TypeScript интерфейсы не могут содержать реализацию.
            Класс реализующий интерфейс обязан реализовывать его в полной мере. Любой класс, который хочет реализовать интерфейс должен указать это с помощью ключевого слова implements, после которого следует идентификатор реализуемого интерфейса.
            */
            interface IAnimal {
              nickname: string;
            
              execute(command: string): void;
            }
            
            class Bird implements IAnimal {
              nickname: string;
            
              execute(command: string): void {}
            }
            /*
            Один класс может реализовывать сколько угодно интерфейсов. В этом случае реализуемые интерфейсы должны быть перечислены через запятую. class Bird implements IAnimal, IOviparous {}
          Декларация свойств get и set (accessors)
            Несмотря на то, что в интерфейсе можно декларировать поля и методы, в нем нельзя декларировать свойства get и set (аксессоры). 
          Указание интерфейса в качестве типа (interface types)
        -Объектные типы с индексными членами
          Индексная сигнатура (index signature) состоит из двух частей. В первой части расположен имеющий собственную аннотацию типа идентификатор привязки (binding identifier) заключенный в квадратные скобки []. 
            Во второй части расположена аннотация типа (type annotation) представляющего значение ассоциируемое с динамическим ключом.
            type A = { [identifier: Type]: Type }
    ?using interfaces with optional properties, read-only properties, etc...
        В TypeScript интерфейсы можно использовать так же, как в традиционном объектно-ориентированном программировании. Можно также использовать интерфейсы для определения типов объектов.
        Интерфейсы можно использовать для описания объекта, именования и параметризации типов объектов, а также для составления существующих типов именованных объектов в новые.
      интерфейс не инициализирует и не реализует свойства, объявленные внутри него. Это обусловлено тем, что единственным заданием интерфейса является описание типа. Он определяет, что требует контракт кода, 
        а переменная, функция или класс, реализующие интерфейс, удовлетворяют контракту, предоставляя необходимые сведения о реализации.
      Этот простой интерфейс определяет два свойства и метод объекта Employee.
        */
      interface Employee1 {// Интерфейсы не имеют представления во время выполнения; они существуют только во время компиляции.
        firstName: string;
        lastName: string;
        fullName(): string;
      }
      let employee1: Employee1 = { // интерфейс реализуется путем объявления переменной типа Employee. Он выполняет контракт.
        firstName: "Emil",
        lastName: "Andersson",
        fullName(): string {
          return this.firstName + " " + this.lastName;
        }
      }
      //employee.firstName = 10;  //* Error - Type 'number' is not assignable to type 'string'
      /*
      +How is an interface different from a type alias( Как разница между интерфейсом и псевдонимом типа)?
        Приведенный выше интерфейс Employee можно также выразить как псевдоним типа с помощью ключевого слова type:
          */
          type Employee2 = {
            firstName: string;
            lastName: string;
            fullName(): string;
          }
          /*
        Псевдоним типа(alias) - это определение типа данных, например объединения, примитива, пересечения, кортежа или любого другого типа. 
        С другой стороны, интерфейсы - это способ описания форм данных, например, объекта. Псевдонимы типов(alias) могут действовать как интерфейсы; однако есть некоторые тонкие различия.
        Ключевое различие заключается в том, что псевдоним типа(alias) нельзя повторно открыть для добавления новых свойств, в то время как интерфейс всегда можно расширить.
        !Кроме того, вы можете описать объединение(Union) или кортеж(Tuple) только с помощью псевдонима типа(alias)!!!
        Other ways to use interfaces
      Create indexable types( Создание типов, которые могут быть индексируемыми):
        Можно использовать интерфейсы, описывающие типы массивов, в которые можно выполнять индексирование.
        Например, интерфейс IceCreamArray объявляет сигнатуру индекса как number и возвращает тип string. Эта сигнатура индекса указывает, что IceCreamArray индексируется числом и будет возвращать строку.
          */
          interface IceCreamArray {
            [index: number]: string;
          }

          let myIceCream2: IceCreamArray;
          myIceCream2 = ['chocolate', 'vanilla', 'strawberry'];
          let myStr: string = myIceCream2[0];
          console.log(myStr);
          /*
      В TypeScript можно управлять видимостью членов класса, добавив ключевое слово public, private или protected перед именем элемента:
      -public - Если модификатор доступа не указан, значение по умолчанию — public. Элемент можно также явно обозначить как общедоступный с помощью ключевого слова public.
      -private - После изменения элемента с помощью ключевого слова private доступ к нему извне невозможен.
      -protected - Модификатор protected действует так же, как модификатор private, за исключением того, что элементы, объявленные как protected, доступны также в производных классах. (Вы узнаете об этом позже из этого модуля.)
    Кроме того, с помощью модификатора readonly свойства можно обозначить как readonly. Доступные только для чтения свойства могут быть заданы только во время инициализации при объявлении или в constructor.
    ?creating custom types.
    ?types/interface differences (optional)
    ?function types.
      let addNumbers2 = (x: number, y: number): number => x + y;
      +Funcion with parameters
          Компилятор TypeScript по умолчанию предполагает, что требуются все параметры, определенные в функции. При вызове функции компилятор TypeScript проверяет следующее:
            -Значения были предоставлены для каждого параметра.
            -передаются ли только те параметры, которые необходимы функции;
            -параметры передаются в том порядке, в котором они определены в функции.
            Это отличается от JavaScript, где предполагается, что все параметры являются необязательными и позволено передавать в функцию больше (или меньше) аргументов, чем в ней определено.
        +Required parameters
          Если не указано иное, все параметры функции являются обязательными, а число аргументов, передаваемых в функцию, должно соответствовать числу обязательных параметров, которые требуются функции.
            */
          function addNumbersReq(x: number, y: number): number {
            return x + y;
          }
          addNumbersReq(1, 2); // Returns 3
          // addNumbersReq(1);    // Returns an error
          /*
      +Optional parameters
        Кроме того, можно определить необязательные параметры, добавив в конец имени параметра вопросительный знак (?). Необязательный параметр должен следовать после всех обязательных параметров в списке параметров.
        Кроме того, чтобы эта функция возвращала правильное значение, необходимо учитывать вероятность того, что y может передаваться как undefined.
          */
          function addNumbersOpt(x: number, y?: number): number {
            if (y === undefined) {
              return x;
            } else {
              return x + y;
            }
          }
          addNumbersOpt(1, 2); // Returns 3
          addNumbersOpt(1);    // Returns 1
          /*
      +Default parameters
        Если значение передается необязательному параметру в качестве аргумента, ему будет присвоено это значение. В противном случае ему присваивается значение по умолчанию.
        Как и в случае с необязательными параметрами, параметры по умолчанию должны следовать после обязательных параметров в списке параметров.
          */
          function addNumbersDef(x: number, y = 25): number {
            return x + y;
          }
          addNumbersDef(1, 2);  // Returns 3
          addNumbersDef(1);     // Returns 26
          /*
    ?utitily types (optional)
      В TypeScript есть набор типов, которые являются шорткатами преобразований других типов.
        Partial<Type> - создает новый тип, в котором все свойства типа Type являются необязательными. fieldsToUpdate: Partial<Todo>
        Required<Type> - создает новый тип, в котором все свойства типа Type являются обязательными. newTodo: Required<Todo>
        Readonly<Type> - создает новый тип, в котором все свойства типа Type являются только для чтения. readonlyTodo: Readonly<Todo>
        Pick<Type, Keys> - Создает тип, выбирая набор свойств Keys(строковый литерал или объединение строковых литералов) из Type pickTodo: Pick<Todo, "title" | "description">
        Omit<Type, Keys> - Создает тип, исключая набор свойств Keys(строковый литерал или объединение строковых литералов) из Type omitTodo: Omit<Todo, "title" | "description">
        !Record<Keys, Type> - создает новый тип, в котором все свойства имеют тип Type. recordTodo: Record<"todo1" | "todo2", Todo> !!!
          type Keys = 'a' | 'b' | 'c';
          type ValueType = number;
          // Create a record using Record utility type
          const myRecord: Record<Keys, ValueType> = {
            a: 1,
            b: 2,
            c: 3
          };

    ?typeguards (optional)
      Защитники типа — это правила, которые помогают выводу типов определить суженый диапазон типов для значения, принадлежащего к типу Union. Другими словами, разработчику предоставлен механизм, 
        позволяющий с помощью выражений составить логические условия, проанализировав которые, вывод типов сможет сузить диапазон типов до указанного и выполнить над ним требуемые операции.
        Как пример querySelector
        Сужение диапазона множества типов на основе типа данных
          При необходимости составления условия, в основе которого лежат допустимые с точки зрения JavaScript типы, прибегают к помощи уже знакомых операторов как typeof и instanceof.
          C помощью операторов typeof и instanceof составляется условие по которому компилятор может вычислить к какому конкретно типу или диапазону будет относиться значение в определяемой условием области.
          */
         // Пример для оператора typeof
          function f(param: string | (() => string)): void {
            param; // param: string | (() => string)
          
            let value: string =
              typeof param !== 'string' ? param() : param;
          
            param; // param: string | (() => string)
          }
          /*
    ?generic types (concept)
      Обобщенное программирование (Generic Programming) — это подход, при котором алгоритмы могут одинаково работать с данными принадлежащими к разным типам данных без изменения декларации (описания типа).
      В TypeScript обобщения могут быть указаны для типов, определяемых с помощью:
        -псевдонимов (type)
        -интерфейсов, объявленных с помощью ключевого слова interface
        -классов (class), в том числе классовых выражений (class expression)
        -функций (function) определенных в виде как деклараций (Function Declaration), так и выражений (Function Expression)
        -методов (method)
        Обобщения объявляются при помощи пары угловых скобок, в которые через запятую, заключены параметры типа называемые также типо-заполнителями или универсальными параметрами Type<T0, T1>.
        Параметры типа могут быть указаны в качестве типа везде, где требуется аннотация типа T, S, U, V и т.д.
        С помощью K и V принято обозначать типы соответствующие Key/Value, а при помощи P — Property. Идентификатором Z принято обозначать полиморфный тип this.
        Кроме того, не исключены случаи, в которых предпочтительнее выглядят полные имена, как например RequestService, ResponseService, к которым ещё можно применить Венгерскую нотацию - TRequestService, TResponseService.
          -type Identifier<T> = {};
          -interface Identifier<T> {}
          -class Identifier<T> {
            public identifier<T>(): void {}
          }
          -let identifier = class<T> {};
          -function identifier<T>(): void {}
          -let identifier = function <T>(): void {};
          -let identifier = <T>() => {};
      ?В реальности обобщения позволяют сокращать количество преобразований (приведений) и писать многократно используемый код, при этом повышая его типобезопасность.
      Универсальные шаблоны являются шаблонами кода, которые можно определять и использовать в базе кода. Они предоставляют способ указать функциям, классам или интерфейсам, какой тип вы хотите использовать при вызове.
      Это можно сравнить с аргументами, которые передаются в функцию, правда универсальный шаблон позволяет указать компоненту, какой тип он должен ждать в момент вызова.
        Create generic functions(Создайте универсальные функции, если ваш код является функцией или классом, который:)
        -Работает с различными типами данных.
          -Использует этот тип данных в нескольких местах.
        Generics can(Универсальные шаблоны могут:)
          -Обеспечить большую гибкость при работе с типами.
          -Поддержать повторное использование кода.
          -Сократить потребность в использовании типа any.
          */
          function identity<T, U>(value: T, message: U): T {
            console.log(message);
            return value
          }
          
          let returnNumber = identity<number, string>(100, 'Hello!');
          /*
  */