/* 
!JavaScript:

  +Basics
    ?Data types
      Динамическая типизация: JavaScript является слабо типизированным или динамическим языком. Это значит, что вам не нужно определять тип переменной заранее.
      Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов:
      Примитивы:
        -String строковый тип данных
        -Number числовой тип данных
        -BigInt number не может содержать числа больше, чем  9007199254740991 что бы создать значен типа BigInt добавляем n в конце лисла.
        -Boolean логический тип данных
        -Undefined переменная объявлена, но значение не присвоено
        -Null typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов; При попытке обратиться к объекту которого нет. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
        -Symbol используется для создания уникальных идентификаторов в объектах. В некоторых языках программирования символы также называются атомами.
      Object:
        Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;
        Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.
    ?Number methods
        -num.toString(base) возвращает строковое представление числа в той или иной системе счисления (base). от 2 до 36 (по умолчанию 10) 
        -num.toFixed(...) возвращает строку с числом, записанным с указанным числом десятичных знаков: var x = 9.656; x.toFixed(2); => "9.66" x.toFixed(0); => returns 10 x.toFixed(6); => returns 9.656000
      Методы преобразования переменных в числовой тип (Global):
        -Number() преобразования переменных JavaScript в числа: Number(true) => 1 | Number("  10") => возвращает 10 | Number("10 20") => NaN 
        -parseInt() парсит строку и возвращает целое число. В строке можно использовать пробелы. Возвращается только первое число: parseInt("10 20 30") => 10 | parseInt('25px') => 25 | parseInt("years 10") => NaN 
        -parseFloat() парсит строку и возвращает число с десятичной точкой. parseFloat("10.33") => 10.33 | parseFloat("10 20") => 10
      Проверка безопастности числа:
        -Number.isFinite(value) проверяет, является ли значение числом и не NaN. Возвращает true или false.
        -Number.isNaN(value) проверяет, является ли значение NaN. Возвращает true или false.
        -Number.isSafeInteger() true, если передаваемое значение является безопасным целым числом ( -123 ) => true | ( "123" ) => false | ( [] ) => false | ( undefined ) => false
      Округление: Объект Math, который содержит несколько функций для работы с округлением:
        -Math.floor(2.8) = 2 в меньш сторону
        -Math.ceil(2.2) = 3 в большую сторону 
        -Math.round(2.5) = 3 Округляет до целого числа.
      Получение случайного числа:
        -Math.random() В диапазоне от 0(включительно) до 1(но не включая 1)
      Другие:
        -Math.max(a, b, c...) Math.min(a, b, c...) Возвращает наибольшее/наименьшее число 
        -Math.pow(x, y) Возвращает число x в степени y
        -Math.abs() возвращает модуль числа, то есть из отрицательного числа делает положительное. (3) => 3 | (-3) => 3 | (0) => 0
    ?String methods
      Поиск подстроки:
        -str.indexOf(substr, pos) Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. второй аргумент позволяет начать поиск с определённой позиции
          Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:
        -str.lastIndexOf(substr, position) ищет с конца строки к её началу. Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.
        -str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет. Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции.
        -str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой
      Получение подстроки:
        -str.slice(start [, end]) от start до end (не включая end)	можно передавать отрицательные значения let str = "stringify"  str.slice(0, 5) => "strin" end отсутствует, slice возвращает символы до конца строки
          Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки: let str = "stringify" str.slice(-4, -1) => // gif
        -str.substring(start [, end]) между start и end	отрицательные значения равнозначны 0. Это — почти то же, что и slice, но можно задавать start больше end.
          Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами. let str = "stringify"; str.substring(2, 6) => // "ring" str.substring(6, 2) => // "ring"
          Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.
        -str.substr(start [, length]) length символов, начиная от start. В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции: let str = "stringify" str.substr(2, 4) => // "ring"
          Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца: let str = "stringify" str.substr(-4, 2) => // "gi"
      Сравнение строк:
        -str.codePointAt(pos) возвращает кодовое значение символа в строке str на позиции pos. Если pos не задан, возвращает кодовое значение первого символа. Если pos больше длины строки, возвращает undefined. 
        -String.fromCodePoint(code) возвращает строку, представляющую кодовое значение code. Если code не является кодовым значением, возвращается пустая строка. fromCodePoint(90) ) => // Z
      Изменение регистра:
        -str.toUpperCase() Возвращает верхний регистр строки.
        -str.toLowerCase() Возвращает нижний регистр строки.
      Доступ к символам: 
        -str[0] возвращает первый символ строки str | если символ с такой позицией отсутствует, тогда [] вернёт undefined
        -str.charAt(0) возвращает первый символ строки str (существует в основном по историческим причинам.) если символ с такой позицией отсутствует charAt — пустую строку 
      полезные методы:
        -str.trim() — убирает пробелы в начале и конце строки.
        -str.repeat(n) — повторяет строку n раз.
        -str.replace("Microsoft", "W3Schools"); не изменяет строку, для которой он вызывается. возвращает новую строку. заменяет только первое совпадение
          Чтобы заменить все совпадения, используйте регулярное выражение с /gфлагом let text = "Please visit Microsoft and Microsoft!"; text.replace(/Microsoft/g, "W3Schools"); => "Please visit W3Schools and W3Schools!"
          Нечувствительный к регистру: let text = "Please visit Microsoft and Microsoft!"; text.replace(/microsoft/gi, "W3Schools"); => "Please visit W3Schools and W3Schools!"
      Property:
        -str.length  = кол-во символов. 
    ?let var const - differences
      Существует 2 основных отличия var от let/const:
        1. Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
        2. «var» допускает повторное объявление переменной. let, будет ошибка
        3. «var» обрабатываются в начале запуска функции. Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того, 
          в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции). Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
          Объявления переменных «всплывают», но присваивания значений – нет. Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. 
      Переменные let:
        1. Видны только после объявления и только в текущем блоке.
        2. Нельзя переобъявлять (в том же блоке).
        3. При объявлении переменной в цикле for(let …) – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная let.
      Переменная const – это константа, в остальном – как let.
    ?ternary operator
      Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента. Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
    ?switch case - examples, where it can be useful
      Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
      Конструкция «switch» может заменить несколько проверок if. При сравнении она использует оператор строгого равенства ===.
        1. Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
        2. Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
        3. Если ни один case не совпал – выполняется (если есть) вариант default.
      Несколько вариантов case, использующих один код, можно группировать.
           */
          let a = 2 + 2;
          switch (a) {
            case 3:
              alert( 'Маловато' );
              break;
            case 4:
              alert( 'В точку!' );
              break;
            case 5:
              alert( 'Перебор' );
              break;
            default:
              alert( "Нет таких значений" );
          }
          /*
        
    ?type conversions
      Строковое: Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
      Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
        undefiend => NaN
        null => 0
        true/false => 1/0
        string => Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
      Логическое: Происходит в математических операциях. Может быть вызвано с помощью Boolean(value).
        0, null, undefined, NaN, "" => false
        любое другое значение => true
      Автоматическое: математические операторы преобразуют знач к числам, кроме + если одно из слагаемых строка, то и все остальные приводятся к строкам ‘1’ + 2 // '12’

  +Advanced Expressions
    ?Be able to discover cases of implicit data types conversion into boolean, string, number
      watch above
    ?Strict comparison
      Операторы сравнения возвращают значения логического типа.
      Строки сравниваются посимвольно в лексикографическом порядке. Используется кодировка Unicode, а не настоящий алфавит
      Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
      Оператор строгого равенства === проверяет равенство без приведения типов. Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.
      Значения null и undefined равны == друг другу и не равны любому другому значению. Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===.
      Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.
    ?Object.is (optional)
    Все мы знаем что в js нет строгой типизации переменных и параметров , и из этого могут вытекать неприятные последствия. 
    Поэтому проверять два значения на равенства рекомендуется через оператор эквивалентности ===, который сравнивает два аргумента не только по значению , но и по типу.
      -console.log(+0 === -0); //true
      -console.log(NaN === NaN); //false
      -console.log(5 === '5');//false
    Как можно заметить и здесь не все гладко, в примерах где +0 === -0, NaN === NaN, нам вернулся не совсем тот результат который мы ожидали.
      -console.log(Object.is(+0 , -0)); //false
      -console.log(Object.is(NaN, NaN)); //true
      -console.log(Object.is(5 , '5'));//false
    Но появление этого метода не означает закат операторов сравнения (==) и (===), поэтому вы можете пользоваться и старыми операторами, только 
    помните что если корректность работы вашего кода зависит от особых случаев, то метод Object.is(), может стать для вас альтернативным решением.
    Поведение этого метода не аналогично оператору === (en-US). Оператор === (en-US) (также как и оператор == (en-US)) считает числовые значения -0 и +0 равными, а значение Number.NaN не равным самому себе.
    ?what is polyfills
      Полифил — это фрагмент кода, который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию.
      Из-за меньшей производительности и ограниченной функциональности нельзя использовать исключительно полифилы. Нативная реализация API быстрее и с ней можно сделать больше, чем с помощью полифила.
      Babel:
        Когда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их. И не везде реализованы все функции.
        И тут приходит на помощь Babel. Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.

  +Function
    Локальные переменные: Переменные, объявленные внутри функции, видны только внутри этой функции. 
    Внешние переменные: У функции есть доступ к внешним переменным, например. Внешняя переменная используется, только если внутри функции нет такой локальной. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
    Параметры: Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции). Когда функция вызывается в строках (*) и (**), переданные значения копируются в локальные переменные from и text. Затем они используются в теле функции.
    Возврат значения: Функция может вернуть результат, который будет передан в вызвавший её код.
    ?arrow func/ func expression/ func declaration
      func expression / func declaration
        Оба способа объявления функции эквивалентны, но есть существенная разница: функции, объявленные как Function Declaration, будут доступны, даже если обратится к ним до того, как они были объявлены.
        Интерпретатор вначале пробегается по всему документу с кодом и ищет все функции, объявленные как Function Declaration, и только потом начинает выполнять код документа построчно.
      5 отличий между обычными и стрелочными функциями:
        1. this
          -Внутри обыкновенной функции значение this динамическое (в зависимости от контекста исполнения). 
            В JS существует 4е способа как ты можешь вызвать функцию:
              1. Во время обычного выполнения значение this эквивалентно глобальному объекту
              2. Во время выполнения функции объекта значением this является объект, у которого был вызван метод
              3. Косвенный вызов используя myFunc.call(thisVal, arg1, ..., argN) или myFunc.apply(thisVal, [arg1, ..., argN]), значение this эквивалентно первому аргументу
              4. Вызов с помощью конструктора используя ключевое слово new, значение this эквивалентно новосозданной сущности
          -Стрелочные функции: 
            Поведение this внутри стрелочной функции отличается от поведения this внутри обычной функции.Не имеет значения как она была вызвана, 
            значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции.
            Другими словами функция не создает собственный контекст исполнения, она использует внешний.
            Когда ты используешь колбек внутри метода, ты можешь быть уверен, что стрелочная функция не создаст собственный this
        2. Конструкторы
          -Обычная функция может легко создавать объекты.
          -Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.
        3. Объект arguments
          -Внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.
          -С другой стороны, в стрелочных функциях отсутствует специальное слово arguments.Опять, точно так же, как и со значение this массив arguments для стрелочных функций будет браться из внешней функции.
            Если ты хочешь все таки получить доступ напрямую к аргументам стрелочной функции, ты можешь использовать фичу деструктуризации: Параметр ...args собирает все аргументы преданные при вызове стрелочной функции: { 0: 'c', 1: 'd' }.
        4. Неявный return
          -Только использование выражения return возвращает результат выполнения функции
          -Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.
        5. Методы 
          -Обычные
            Чаще всего, обыкновенная функция используется для создания методов класса. Иногда тебе будет нужно применить метод в качестве колбека, например для setTimeout() или для event listener`а.
            Иногда тебе будет нужно применить метод в качестве колбека, например для setTimeout() или для event listener`а. Например, давай попробуем использовать logName() метод как колбек для setTimeout():
            logName() {console.log(this.heroName); } setTimeout(batman.logName, 1000); => after 1 second logs "undefined" В данном случае метод отделен от объекта.
            Вручную привязать контекст: setTimeout(batman.logName.bind(batman), 1000); => after 1 second logs "Batman"
          -Стрелочные
            Ты можешь использовать стрелочные функции как методы, внутри класса.
            Сейчас, на контрасте с обыкновенной функцией, метод определенный с использованием стрелочной функции привязывает thisк объекту класса.
            Значение this внутри метода logName() всегда объект класса

  +Date & time (optional)
    ?Date object
    ?Date methods, props
      Дата - Создаёт экземпляр объекта Date, представляющего собой момент времени. Объект Дата содержит число миллисекунд прошедших с 1 января 1970 г. UTC. Он содержит дату и время, а также предоставляет методы управления ими.
      Создание:
        Для создания нового объекта Date нужно вызвать конструктор new Date() с одним из следующих аргументов:
          -new Date() - Без аргументов – создать объект Date с текущими датой и временем.
          -new Date(milliseconds) - Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0. Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp). 
            Датам до 1 января 1970 будут соответствовать отрицательные таймстампы //* let Dec31_1969 = new Date(-24 * 3600 * 1000); 31 декабря 1969 года
          -new Date(datestring) - Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в Date.parse //* let date = new Date("2017-01-26");
          -new Date(year, month, date, hours, minutes, seconds, ms) - Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента. //* new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
            --year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
            --month начинается с 0 (январь) по 11 (декабрь).
            --Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
            --Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
      Получение компонентов даты: Существуют методы получения года, месяца и т.д. из объекта Date
        -getFullYear() Получить год (4 цифры)
        -getMonth() Получить месяц (0-11)
        -getDate() Получить день месяца (1-31)
        -getHours(), getMinutes(), getSeconds(), getMilliseconds() - Получить, соответственно, часы, минуты, секунды или миллисекунды.
        -getDay() Получить день недели (0-6, в зависимости от начала недели)
          Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом. Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".
            let date = new Date(); getUTCHours() 7:00 UTC+0  getHours() 10:00 UTC+3
        -getTime() Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
        -getTimezoneOffset() Возвращает разницу между местным и UTC часовым поясом в минутах. 
      Установка компонентов даты:
        -setFullYear(year [, month, date]) Установить год (4 цифры)
        -setMonth(month [, date]) Установить месяц (0-11)
        -setDate(date) Установить день месяца (1-31)
        -setHours(hours [, minutes, seconds, ms]) Установить часы (0-23)
        -setMinutes(minutes [, seconds, ms]) Установить минуты (0-59)
        -setSeconds(seconds [, ms]) Установить секунды (0-59)
        -setMilliseconds(ms) Установить миллисекунды (0-999)
        -setTime(time) Установить дату и время в миллисекундах от 1 января 1970 года UTC+0.
        У всех этих методов, кроме setTime(), есть UTC-вариант
      Автоисправление даты:
        Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит. //* let date = new Date(2013, 0, 32); 1 Mar 2016
      Преобразование к числу, разность дат:
        Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime() console.log(+date):
          Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах. Этот приём можно использовать для измерения времени.
      Date.now()
        Если нужно просто измерить время, объект Date нам не нужен. Существует особый метод Date.now(), возвращающий текущую метку времени. Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.
          Вероятно, предыдущий пример лучше переписать так: let start = Date.now(); let end = Date.now(); console.log(end - start);
      Разбор строки с датой
        Метод Date.parse(str) считывает дату из строки. Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ. Пример: "2016-03-01T12:00:00.000Z". Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.
        Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.
        Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN.

  +Objects Built-in methods.
    let user = new Object(); // синтаксис "конструктор объекта" let user = {};  // синтаксис "литерал объекта" 
    Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
      Они хранят свойства (пары ключ-значение), где:
        -Ключи свойств должны быть строками или символами (обычно строками).
        -Значения могут быть любого типа.
      Чтобы получить доступ к свойству, мы можем использовать:
        -Запись через точку: obj.property.
        -Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
      Дополнительные операторы:
        -Удаление свойства: delete obj.prop.
        -Проверка существования свойства: "key" in obj. Если вы хотите рассматривать только свойства самого объекта, а не его прототипов, используйте getOwnPropertyNames(), hasOwnProperty() или propertyIsEnumerable. if( obj.hasOwnProperty( prop ) ) { ... }
        -Перебор свойств объекта: цикл for for (let key in obj).
    Упорядочение свойств объекта - Если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать? 
      Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
    ?Know how to use built-in methods
      -Object.create() - создаёт новый объект с указанным прототипом и свойствами. Object.create(proto[, propertiesObject])
        Параметры
          -proto - Объект, который станет прототипом вновь созданного объекта.
          -propertiesObject - Если указан и не равен undefined, должен быть объектом, чьи собственные перечисляемые свойства (то есть такие, которые определены на самом объекте, а не унаследованы по цепочке прототипов) указывают дескрипторы свойств, добавляемых в новый объект.
            Имена добавляемых свойств совпадают с именами свойств в этом объекте. Эти свойства соответствуют второму аргументу метода Object.defineProperties().
        Возвращаемые значения: Новый объект с заданным прототипом и свойствами.
      -Object.assign() - используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.
        Object.assign(target, ...sources) => Возвращается получившийся целевой объект.
        (Он использует внутренний метод [[Get]] на исходных объектах и внутренний метод [[Set]] на целевом объекте, так что он также вызывает геттеры и сеттеры. Именно поэтому он присваивает свойства вместо простого копирования или определения новых свойств.
        Это поведение может сделать метод непригодным для вливания новых свойств в прототип, если вливаемые исходные объекты содержат геттеры. Вместо него для копирования в прототипы определений свойств, включая признак их перечисляемости, следует использовать методы Object.getOwnPropertyDescriptor() и Object.defineProperty().)
      -Object.keys() - Метод Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов). //* Object.keys(obj)
        Метод Object.keys возвращает массив строковых элементов, соответствующих именам перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном перечислении свойств в объекте через цикл. 
        (Если вы хотите увидеть все свойства, а не только перечисляемые, смотрите метод Object.getOwnPropertyNames().)
      -Object.values() - возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов. Object.values(obj)
      -Object.entries() - возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in перечисляет свойства из цепочки прототипов).
        Порядок элементов в массиве который возвращается Object.entries() не зависит от того как объект объявлен. Если существует необходимость в определённом порядке, то  массив должен быть отсортирован до вызова метода, например Object.entries(obj).sort((a, b) => a[0] - b[0]);.

      -Object.prototype.hasOwnProperty() -  возвращает логическое значение, указывающее, содержит ли объект указанное свойство. obj.hasOwnProperty(prop) prop Имя проверяемого свойства. в отличие от оператора in, этот метод не проверяет существование свойств в цепочке прототипов объекта.
      -Object.prototype.propertyIsEnumerable() - возвращает логическое значение, указывающее, является ли указанное свойство перечислимым. obj.propertyIsEnumerable(prop) prop Имя проверяемого свойства.

      -Object.freeze() - замораживает объект, после чего нельзя будет изменить значения свойств объекта.
      -Object.isFrozen() - возвращает true, если объект заморожен, иначе false.
      -Object.seal() - замораживает объект, после чего нельзя будет изменить значения свойств объекта, но можно добавлять новые свойства.
      -Object.isSealed() - возвращает true, если объект заморожен, иначе false.
      Object.preventExtensions() - предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).
      -Object.defineProperties() - определяет новые или изменяет существующие свойства, непосредственно на объекте, возвращая этот объект. //* Object.defineProperties(obj, props)
        Параметры:
          -obj Объект, на котором определяются новые или изменяются существующие свойства.
          -props Объект, чьи собственные перечисляемые свойства представляют собой дескрипторы для создаваемых или изменяемых свойств. Дескрипторы свойств обладают следующими дополнительными ключами
            -configurable: Равен true только в том случае, если тип этого дескриптора свойства может быть изменён и если свойство может быть удалено из содержащего его объекта. Значение по умолчанию установлено в false.
            -enumerableРавен: true только в том случае, если это свойство можно увидеть через перечисление свойств содержащего его объекта. Значение по умолчанию установлено в false.
            -value: Значение, ассоциированное со свойством. Может быть любым допустимым значением JavaScript (числом, объектом, функцией и т.д.). Значение по умолчанию установлено в undefined.
            -writable: Равен true только в том случае, если значение, ассоциированное со свойством, может быть изменено с помощью оператора присваивания (en-US). Значение по умолчанию установлено в false.
            -get: Функция, возвращающая значение свойства. Значение по умолчанию установлено в undefined.
            -set: Функция, принимающая значение и возвращающая новое значение свойства. Значение по умолчанию установлено в undefined.
        Возвращаемое значение: Объект, переданный в функцию.
      -Object.defineProperty() - определяет новое или изменяет существующее свойство, непосредственно на объекте, возвращая этот объект. //* Object.defineProperty(obj, prop, descriptor) descriptor - Дескриптор определяемого или изменяемого свойства.
        Этот метод позволяет точно добавлять или изменять свойства объекта. Обычное добавление свойств через присваивание создаёт свойства, которые можно увидеть через перечисление свойств 
        (с помощью цикла for...in или метода Object.keys), чьи значения могут быть изменены и которые могут быть удалены. Этот же метод позволяет настроить эти дополнительные детали свойства.
        Дескрипторы свойств, присутствующие в объектах, бывают двух основных типов: дескрипторы данных и дескрипторы доступа.
          Дескриптор данных — это свойство, имеющее значение, которое может быть (а может и не быть) записываемым.
          Дескриптор доступа — это свойство, описываемое парой функций — геттером и сеттером.
          Дескриптор может быть только чем-то одним из этих двух типов; он не может быть одновременно обоими.
          И дескриптор данных, и дескриптор доступа являются объектами. Они обладают следующими обязательными ключами: См выше prop
      
  +Arrays Built-in methods
    Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов. 
      Объявление:
        -Существует два варианта синтаксиса для создания пустого массива:
          let arr = new Array();
          let arr = [];
        -Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.
        -Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
          Если мы уменьшаем length вручную, массив укорачивается.
      Получение элементов:
        -Мы можем получить элемент по его индексу, например arr[0].
        -Также мы можем использовать метод at(i) для получения элементов с отрицательным индексом, для отрицательных значений i, он отступает от конца массива. В остальном он работает так же, как arr[i], если i >= 0.
      Чтобы пройтись по элементам массива:
        -for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
        -for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
    ?Know how to copy array
    ?Know how to modify array
  +Arrays Iterating, Sorting, Filtering
    ?Know how to sort Array
    ?Know several method how to iterate Array elements
    Методы массива:
      Добавление/удаление элементов:
        -push(...items)добавляет items в конец массива.
        -pop() удаляет элемент в конце массива и возвращает его.
        -shift() удаляет элемент в начале массива и возвращает его.
        -unshift(...items) добавляет items в начало массива.
        -splice  Умеет всё: добавлять, удалять и заменять элементы. arr.splice(index[, deleteCount, elem1, ..., elemN]) Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
          удаление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент => ["Я", "JavaScript"] | arr.splice(-1,1) – первый с конца. 
          добавление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 0, "программирование"); // начиная с позиции 1, добавить 0 элементов => ["Я", "программирование", "изучаю", "JavaScript"] | arr.splice(-1,0, "программирование") – первый с конца.
          удаление и замена: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1, "программирование"); // начиная с позиции 1, удалить 1 элемент и вставить "программирование" => ["Я", "программирование"]
          Отрицательные индексы разрешены: let arr = [1, 2, 5];  arr.splice(-1, 0, 3, 4); => [1, 2, 3, 4, 5]
        -slice arr.slice([start], [end]) Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
          let arr = ["t", "e", "s", "t"];  arr.slice(1, 3) => ["e", "s"] arr.slice(-2) => ["s", "t"] 
          Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
        -concat arr.concat(arg1, arg2...) Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения. Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
          let arr = ["t", "e", "s", "t"];  arr.concat("test", "test2") => ["t", "e", "s", "t", "test", "test2"]
      Перебор: 
        -forEach Позволяет запускать функцию для каждого элемента массива. arr.forEach(function(item, index, array) { // ... делать что-то с item }); Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
      Поиск в массиве: (Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.)
        -arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
        -arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
        -arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен. let arr = [1, 0, false]; arr.includes(0) => true arr.includes(2) => false
          Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf.
        -arr.find(fn) findLast()  Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием? Функция вызывается по очереди для каждого элемента массива. Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
          let result = arr.find(function(item, index, array) { // если true - возвращается текущий элемент и перебор прерывается // если все итерации оказались ложными, возвращается undefined});
        -arr.findIndex(fn) findLastIndex() по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
        -arr.filter(fn) На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn). Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов. let someUsers = users.filter(item => item.id < 3);
      Преобразование и упорядочения массива:
        -arr.map(fn) применяет функцию fn к каждому элементу массива и возвращает новый массив. Функция fn принимает 3 аргумента: item, index и array.
        -arr.sort(fn) сортирует массив на месте(копия массива не создаётся), меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. let arr = [ 1, 2, 15 ]; arr.sort(); => [ 1, 15, 2 ]
          По умолчанию элементы сортируются как строки. Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что "2" > "15".
          Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная быстрая сортировка). 
          Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение.
          На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше». Это позволяет писать более короткие функции: let arr = [ 1, 15, 2 ]; arr.sort((a, b) => a - b); => [ 1, 2, 15 ]
        -arr.reverse() Метод reverse() на месте переставляет элементы массива (меняя исходный массив), на котором он был вызван, изменяет массив и возвращает ссылку на него.
        _-str.split(delim) Он разбивает строку на массив по заданному разделителю delim. В примере  таким разделителем является строка из запятой и пробела. let arr = names.split(', '); Или с пустым аргументом разбил бы строку на массив букв  str.split('')
          У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2); => [ 'Вася', 'Петя' ]
        -arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.
        -reduce/reduceRight Они используются для вычисления какого-нибудь единого значения на основе всего массива. let value = arr.reduce(function(previousValue, item, index, array) {...}, [initial]);
          Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов. 
          previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial), а при отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
          При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент. По окончании он становится результатом reduce.
      Array.isArray - Массивы не образуют отдельный тип языка. Они основаны на объектах. Поэтому typeof не может отличить простой объект от массива. Он возвращает true, если value массив, и false, если нет.
      Другие:
        -arr.some(fn)/arr.every(fn) Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
        -arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end. Если end не задан, заполняется до конца массива.
        -arr.copyWithin(target, start, end) – копирует массив с индекса start до end в массив с индексом target. Если end не задан, копируется до конца массива. [1, 2, 3, 4, 5].copyWithin(0, 3); => [4, 5, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(0, 3, 4); => [4, 2, 3, 4, 5]
        -arr.flat(n) – var newArray = arr.flat(depth); Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth. (На сколько уровней вложенности уменьшается мерность исходного массива. По умолчанию 1.)
          const arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); => [1, 2, 3, 4, [5, 6]]      const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr4.flat(Infinity); => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          Метод flat удаляет пустые слоты из массива: var arr4 = [1, 2, , 4, 5]; arr4.flat(); => [1, 2, 4, 5]
        -arr.flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. 
          Это идентично map функции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно.
          let arr1 = ["it's Sunny in", "", "California"]; arr1.map(x => x.split(" ")); => [["it's","Sunny","in"],[""],["California"]] arr1.flatMap(x => x.split(" ")); => ["it's","Sunny","in", "", "California"]
        -arr.keys() возвращает новый итератор массива Array Iterator, содержащий ключи каждого индекса в массиве. var arr = ['a', 'b', 'c']; var iterator = arr.keys(); iterator.next() => { value: 0, done: false }
        -arr.values() возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.
        -arr.toString() возвращает строковое представление указанного массива и его элементов. Cоединяет массив и возвращает одну строку, содержащую каждый элемент массива, разделённый запятыми.

  +Loops
    ?for loop
    ?while loop
    ?do while loop
      Цикл «while»
      do {// тело цикла} while (condition); Цикл сначала выполнит тело, а затем проверит условие condition
      for начало let i = 0 | условие	i < 3 | тело	alert(i) | шаг	i++
      Прерывание цикла: «break»
        Код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а не передал -  прерывает. Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом
      Переход к следующей итерации: continue
        При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true). Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
      Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.

!JavaScript in Browser:

  +Global object window
    Глобальный объект
      Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.
      Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы. Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight – высота окна браузера.
      Глобальный объект имеет универсальное имя – globalThis. …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js). 
      В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами глобального объекта. Но не let и const, которые объявляются в блоке кода, не станут свойствами глобального объекта.
      Корневой объект window, который выступает в 2 ролях:
        -Во-первых, это глобальный объект для JavaScript-кода как было сказано выше. (Object, Array, String, Number, Boolean, Math, Date, RegExp, Error, JSON, …)
        -Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.
          -DOM (Document Object Model) – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
          -BOM (Browser Object Model) - это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа. (navigator, screen, history, location …)
          -CSSOM (CSS Object Model) – объектная модель CSS, которая представляет все содержимое CSS в виде объектов, которые можно менять. Объект CSSStyleDeclaration – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
    ?Document
      ?DOM-дерево:
        -В соответствии с объектной моделью документа (DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
          Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, document.body – объект для тега <body>.
        -Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
        -Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
        -Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM.
          Существует всего два исключения из этого правила: 1. По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются. 2. Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body.
        -Автоисправление - Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM. Например, в начале документа всегда должен быть тег <html>.  То же самое касается и тега <head> и <body>.
        -Другие типы узлов: Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:
          1. document – «входная точка» в DOM.
          2. узлы-элементы – HTML-теги, основные строительные блоки.
          3. текстовые узлы – содержат текст.
          4. комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
      ?Навигация по DOM документу: 
        Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки. Есть два основных набора ссылок:
          -Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
          -Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
      ?Поиск: getElement*, querySelector*
        Есть 6 основных методов поиска элементов в DOM:
          Метод	                      Ищет по...	       Ищет внутри элемента?        	Возвращает живую коллекцию?
          -querySelector         	   CSS-selector	                ✔	                               -
          -querySelectorAll        	CSS-selector	                ✔	                               -
          -getElementById         	   id	                        -	                                -
          -getElementsByName         	name	                      -	                                ✔
          -getElementsByTagName      tag or '*'                  	✔                                	✔
          -getElementsByClassName      class	                    ✔	                                ✔
        Методы другие:
          -elem.matches(css)  проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.  Когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют. elem.matches('a[href$="zip"]')
          -elem.closest(css) Метод ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск. 
            Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.
          -elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
      ?Свойства узлов: тип, тег и содержимое:
        Классы DOM-узлов:
          У разных DOM-узлов могут быть разные свойства(<a>, <img>, <input>). Каждый узел имеет свои свойства. Каждый DOM-узел принадлежит соответствующему встроенному классу. Например, <a> принадлежит классу HTMLAnchorElement. 
          Корнем иерархии является EventTarget => Node и остальные DOM-узлы.
          -EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.
          -Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
            Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.
          -Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. 
            Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.
          -HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы: HTMLAnchorElement, HTMLButtonElement, HTMLDivElement, HTMLImageElement, HTMLInputElement, HTMLSpanElement, HTMLTableElement и т.д.
            каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы. Таким образом, полный набор свойств и методов данного узла собирается в результате наследования.
          //* document.body.constructor.name => HTMLBodyElement
          Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.
        Свойства:
          -innerHTML Внутреннее HTML-содержимое узла-элемента. Можно изменять. Пример: document.body.innerHTML = '<p>Привет мир!</p>';
          -outerHTML Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.  Это как innerHTML плюс сам элемент.
          -nodeValue/data Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.
          -textContent Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
          -hidden Когда значение установлено в true, делает то же самое, что и CSS display:none.
      ?Атрибуты и свойства:
          Но преобразование атрибута в свойство происходит не один-в-один!
        DOM-свойства:
          DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять. Например, создадим новое свойство для document.body: document.body.myProperty = 'Привет мир!'; и проверим: document.body.myProperty; // Привет мир!
            Мы можем добавить и метод: Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам
            Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript: 1) Им можно присвоить любое значение. 2) Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).
            DOM-свойства типизированы - например, свойство input.checked (для чекбоксов) имеет логический тип.
            Есть и другие примеры. Атрибут style – строка, но свойство style является объектом: div.style => [object CSSStyleDeclaration]
        HTML-атрибуты
          Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов. <body id="page"> => body.id = "page".
          Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный. Cтандартный атрибут для одного тега может быть нестандартным для другого.
          Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?
            Все атрибуты доступны с помощью следующих методов:
              -elem.hasAttribute(name) – проверяет наличие атрибута.
              -elem.getAttribute(name) – получает значение атрибута.
              -elem.setAttribute(name, value) – устанавливает значение атрибута.
              -elem.removeAttribute(name) – удаляет атрибут.
              Эти методы работают именно с тем, что написано в HTML.
              -Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes: коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами name и value.
          Синхронизация между атрибутами и свойствами:
            Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями). todo разобраться.
          Нестандартные атрибуты, dataset:
            Иногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript, или чтобы «помечать» HTML-элементы для JavaScript. Но с пользовательскими атрибутами могут возникнуть проблемы. Что если мы используем нестандартный атрибут для наших целей, а позже он появится в стандарте и будет выполнять какую-то функцию?
            Чтобы избежать конфликтов, существуют атрибуты вида data-*. Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset. //* <body data-about="Elephants"> document.body.dataset.about => "Elephants"
            Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState. Использование data-* атрибутов – валидный, безопасный способ передачи пользовательских данных.
        В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда, когда DOM-свойства не подходят, когда нужны именно атрибуты, например:
          -Нужен нестандартный атрибут. Но если он начинается с data-, тогда нужно использовать dataset.
          -Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например, свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.
      ?Изменение документа
        Методы для создания узлов:
          -document.createElement(tag) – создаёт элемент с заданным тегом,
          -document.createTextNode(value) – создаёт текстовый узел (редко используется),
          -elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.
        Вставка и удаление:
          -node.append(...nodes or strings) – вставляет в node в конец,
          -node.prepend(...nodes or strings) – вставляет в node в начало,
          -node.before(...nodes or strings) – вставляет прямо перед node,
          -node.after(...nodes or strings) – вставляет сразу после node,
          -node.replaceWith(...nodes or strings) – заменяет node.
          -node.remove() – удаляет node.
        Устаревшие методы:
          -parent.appendChild(node)
          -parent.insertBefore(node, nextSibling)
          -parent.removeChild(node)
          -parent.replaceChild(newElem, node)
          Все эти методы возвращают node.
        Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:
          -"beforebegin" – вставляет html прямо перед elem,
          -"afterbegin" – вставляет html в elem в начало,
          -"beforeend" – вставляет html в elem в конец,
          -"afterend" – вставляет html сразу после elem.
          Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы, но они редко используются.
        Чтобы добавить HTML на страницу до завершения её загрузки:
          -document.write(html) После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.
      ? Стили и классы
        Как правило, существует два способа задания стилей для элемента:
          -Создать класс в CSS и использовать его: <div class="some">
          -Писать стили непосредственно в атрибуте style: <div style="...">.
        JavaScript может менять и классы, и свойство style. Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством style только в том случае, если классы «не могут справиться».
        Для управления классами существуют два DOM-свойства:
          -className – строковое значение, удобно для управления всем набором классов. Перезапишет все классы, которые были до этого.
          -classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.
        Чтобы изменить стили:
          -elem.style – это объект, который соответствует тому, что написано в атрибуте "style". Установка стиля elem.style.width="100px" работает так же, как наличие в атрибуте style строки width:100px. background-color  => elem.style.backgroundColor
          -style.cssText - Обычно мы используем style.* для присвоения индивидуальных свойств стиля. Нельзя установить список стилей как, например, div.style="color: red; width: 100px", потому что div.style – это объект, и он доступен только для чтения.
            Для задания нескольких стилей в одной строке используется специальное свойство style.cssText: Это свойство редко используется, потому что такое присваивание удаляет все существующие стили
      ? Размеры и прокрутка элементов
        У элементов есть следующие геометрические свойства (метрики):
          -offsetParent – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
          -offsetLeft/offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent.
          -offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки.
          -clientLeft/clientTop – расстояние от верхнего левого внешнего угла до внутренного. Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
          -clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
          -scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
          -scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
          Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.
      ? Размеры и прокрутка окна
        Размеры:
          -Ширина/высота видимой части документа (ширина/высота области содержимого): document.documentElement.clientWidth/Height
          -Ширина/высота всего документа со всей прокручиваемой областью страницы:
            let scrollHeight = Math.max(
              document.body.scrollHeight, document.documentElement.scrollHeight,
              document.body.offsetHeight, document.documentElement.offsetHeight,
              document.body.clientHeight, document.documentElement.clientHeight
            );
        Прокрутка:
          -Прокрутку окна можно получить так: window.pageYOffset/pageXOffset.
          -Изменить текущую прокрутку:
            -window.scrollTo(pageX,pageY) – абсолютные координаты,
            -window.scrollBy(x,y) – прокрутка относительно текущего места,
            -elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).
      ? Координаты
        Любая точка на странице имеет координаты:
          1. Относительно окна браузера – elem.getBoundingClientRect().
          2. Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы.
        Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute.
        Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между absolute и fixed.

  +Events Basics
    ?Event Phases
    ?Event Listeners
    ?DOM Events
    ?Know basic Event types
    ?Mouse / Keyboard Events
    ?Form / Input Events
  +Timers
    ?setTimeout
    ?setInterval
  +Web Storage API & cookies
    ?LocalStorage
    ?SessionStorage
  */