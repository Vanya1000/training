/* 
!Design patterns:

!Общий обзор
  +Архитектура приложения
    Архитектура приложения — это набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром. Архитектура включает в себя подходы: ограничения, правила и эвристики, которым надо следовать при написании кода.
  +Паттерн проектирования
    Паттерн проектирования — шаблонное решение частой архитектурной проблемы. Область ответственности паттернов проектирования меньше, чем у архитектуры в целом. Паттерны помогают нам решать проблемы на более «низком уровне», ближе к непосредственно коду. 
    Архитектура же решает проблемы проектирования всей системы в целом.
  Если упростить, то архитектура — это инструкция «Как построить дом в общем», она охватывает целый проект. А паттерны — инструкции для конкретных задач: «Как забить сваи», «Как замешать цемент», «Как проложить проводку».
!Архитектура во фронтенде
  Грамотная архитектура помогает спроектировать и развивать систему так, чтобы её было проще и удобнее расширять и изменять.
    -Если общение между модулями регламентировано, их реализацию проще заменить на другую.
    -Если общение с внешним миром регламентировано, меньше шансов для утечки данных.
    -Если код разделён грамотно, программу проще тестировать.
    -Если код организован понятно, уходит меньше времени на добавление новых фич и поиск багов в старых.
    -Если архитектура широко известна, погружение в проект проходит быстрее.
  +Архитектурные подходы
    Мы можем условно разделить архитектурные подходы по их целям и зоне действия. 
      ?Часть подходов распределяют ответственность между модулями. Они определяют, какие модули и за что будут отвечать.
        Model-View-Controller (MVC) — это один из самых популярных подходов. Он разделяет приложение на три слоя: модель, представление и контроллер. Каждый слой отвечает за свою часть приложения. Модель отвечает за данные, представление за отображение данных, а контроллер за логику приложения.
      ?Другие определяют, насколько каждый из модулей близок к бизнес-логике. Таким подходам важно, какая часть кода занимается непосредственно задачей приложения, а какая — инфраструктурными задачами.
        В зависимости от степени близости к бизнес-логике такие подходы делят код на «слои». Самый распространённый подход среди таких — это трёхслойная архитектура. Она разделяет код на слои: представление, бизнес-логику и хранилище данных.
      ?Третьи управляют потоками данных в приложении. Они определяют, как модули общаются друг с другом: напрямую, опосредованно или с помощью специальных сервисов типа шины событий.
        Flux — это один из самых популярных подходов. Он определяет, как модули общаются друг с другом. В Flux модули общаются напрямую, но только через специальные объекты — хранилища.  Это пример однонаправленного потока данных. Хранилища хранят состояние приложения и оповещают об изменениях подписчиков.
        Кроме него используют двунаправленный поток, например, реактивные обновления данных. 
      ?Другие подходы определяют компоновку приложения. Будет это одна большая программа (монолит) или набор нескольких программ поменьше (микросервисов).
  +Минусы архитектуры 
    Создание, организация и следование архитектуре всегда требует ресурсов: времени, денег, умственных затрат. Выбор следует делать после сравнения издержек и выгод каждого из подходов-кандидатов.

! +Intermediate knowledge of patterns and best practices:
    ?design patterns used on his project, and able to compare these patterns (optional)
    Некоторые проблемы слишком малы для выделения в архитектурный подход, но достаточно часто встречаются, чтобы породить стандартные решения. Такие стандартные решения называются паттернами или шаблонами.
      Это повторяемая архитектурная конструкция, которая решает наиболее часто встречающущиеся проблемы в проектировании программного обеспечения.
      Предназначенны для получения расширяемости системы. Но все зависит от ситуации. И в зависимости от того как что то будет меняться в системе, нужно выбирать тот или иной паттерн.
      +Порождающие (Creational patterns) - Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов. Делают систему независимой от способа создания, композиции и представления объектов.
        Инкапсулируют знания о конкретных классах которые применяются в системе. Скрывают детали того как эти классы создаються и стыкуются друг с другом. Обеспечивают большую гибкость в вопросох что создавать и как создавать. 
        ?Factory Method 
          Cоздаёт объект, избавляя нас от необходимости знать детали создания. Фабрика в программировании принимает от нас сигнал, что надо создать объект, и создаёт его, инкапсулируя логику создания внутри себя.
          Пример: Несколько классов у которых очень много общих свойств, но отличаются несколько. 
        ?abstract factory 
          Абстрактная фабрика не возвращает конкретный объект, вместо этого она описывает тип объекта, который будет создан.
        ?Builder 
          (Позволяет создавать объекты, добавляя им свойства по заданным правилам. Он полезен, когда при создании объекта нужно выполнить много шагов, часть из которых могут быть необязательными.)
        ?Singleton 
          (Это шаблон, который позволяет создать лишь один объект, а при попытке создать новый возвращает уже созданный.) ES-модули являются синглтонами сами по себе.
          Например используется в mongoose, чтобы избежать создания нескольких соединений с базой данных. И если коннеект уже есть, то просто возвращается его экземпляр.
        ?прототип
          Как пример в JS можно использовать Object.create() для создания прототипа.
      +Структурные (Structural patterns) - Они заботятся о том, как сущности могут использовать друг друга. Из каких классов и объектов состоит система, как эти классы и объекты связаны между собой.
        Когда у нас есть достаточно большая система и там присутствуют разные объекта и мы хотим для этих объектов какой то новый функционал, при не затрагивая функционал прошлой системы.
        ?Adapter 
          (если работаете с сервисами или модулями, API которых не совместимо с требованиями вашего приложения. Это позволит снизить сцепление кода).
        ?Decorator 
          ( Позволяет добавлять какое то новое поведение или функционал к существующему объекту.  )
          Например какая то функция может принимать инстанс класса и добавлять ему новый функционал.
        ?Facade (Фасад прячет за собой сложную логику других модулей, предоставляя более простые методы или функции.) Позволяет создавать простой интерфейс для сложной системы. Как пример JQuery, lodash.
          Он немного похож на адаптер, потому что тоже может делать несовместимое API совместимым, но его основная цель всё же — инкапсулировать часть связанной логики и дать к ней доступ через один метод.
        ?Proxy 
          (Позволяет ставить различные ловушки на поля объектов, вызов функций. Избавление лишних запросов на сервер. 
            Промежуточный модуль, предоставляет интерфейс к какому-либо другому модулю.  Он похож на декоратор, но в отличие от него не меняет поведение оригинального объекта в рантайме. Вместо этого он «вмешивается» в общение с оригинальным объектом.)
          Используйте прокси, когда вам необходимо заменить полностью или поменять API другого модуля, не трогая оригинальный объект. 
        ?flyweight легковес 
          (Передавать и работать с данными, через различные типы объектов ) Кэширование сохранение в памяти данных, чтобы не делать лишних запросов к серверу.
        ?Conposite компоновщик
          позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.
      +Поведенческие (Behavioral patterns) - Решают задачи эффективного и безопасного взаимодействия между объектами программы.  Алгоритмы и способы реализации взаимодействия различных объектов и классов.
        ?Chain of Responsibility цепочка обязанностей
            Позволяет последовательно у одного и того же объекта вызывать какой то набор операций и тем самым последовательно их модифицировать.
            Возвращаем ссылку на текущий объект в методе и благодаря этому есть возможность использовать цепочку вызовов.
        ?Command команда
          Позволяет создавать определенную абстрактную оболочку над функционалом который позволяет управлять, ну уже через другой объект. Также позволяет сохранять состояния которые были вызваны.
          Receiver - получатель команды. Он знает, как выполнить команду. И хранит историю вызовов.
          Invoker - вызывает команду. Он не знает, какая команда будет выполнена. Он просто вызывает метод execute() у объекта команды.
          Command - команда абстрактный класс и его наследники конкретные команды которые должны быть реализованы
        ?Iterator итератор 
          (даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.)
          Пример итераторы в JS es6.
        ?Mediator посредник
          Позволяет выстраивать плотную и тесную коммуникацию между объектами разного типа, не создавая прямых связей между ними.
        ?Observer 
          Формирует зависимости один ко многим между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляют свое состояние.
          (Шаблон, который создаёт механизм подписки, когда некоторые сущности могут реагировать на поведение других.)
        ?State состояние
          Мы можем создавать различные классы которые будут являться элементами стэйта и мы можем делегировать изменение состояния этих классов на какой то общий класс который будет являться стейтом 
            и который будет менять состояние этих отдельных элементов. И вся логика будет построенна на этом вернеуровневом классе который будет менять внутренне значение.
        ?Strategy стратегия
          Определяет некоторое семейство алгоримов которые наследуют объекты в неизменяемом порядке.
          Позволяет создавать некоторую оболочку для различных интерфейсов что бы мы могли использовать разные алгоритмы и не зависеть от конкретной реализации.
        ?Template Method
          Он определяет некоторый скелет будущего алгоритма, но при этом он делегирует создание конкретного функционала в дочерние классы.
          Т.е он определяет структуру, а вот реализацию мы можем делегировать на дочерние классы.
        ?снимок 
          ( позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации. )
        ?посетитель 
          (позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.)
    ?KISS, DRY, YAGNI
    1. YAGNI
      You Aren’t Gonna Need It / Вам это не понадобится
        Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.
        Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.
        Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.
    2. DRY
      Don’t Repeat Yourself / Не повторяйся
        Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?
        В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, 
          что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.
        Использование SSOT позволит создать более прочную и понятную кодовую базу.
        Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.
        В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. 
        Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.
    3. KISS
      Keep It Simple, Stupid / Будь проще
        Этот принцип гласит, что простые системы будут работать лучше и надежнее. Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.
        Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.
        Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.
    ?The meaning behind SOLID principles. https://habr.com/ru/company/ruvds/blog/426413/
    SOLID — это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании.
    Аббревиатура SOLID была предложена Робертом Мартином, автором нескольких книг, широко известных в сообществе разработчиков. Эти принципы позволяют строить на базе ООП масштабируемые и сопровождаемые программные продукты с понятной бизнес-логикой.
    Расшифровка:
      -Single responsibility — принцип единственной ответственности ( каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс.)
      -Open-closed — принцип открытости / закрытости (должны быть открыты для расширения, но закрыты для изменения.)
      -Liskov substitution — принцип подстановки Барбары Лисков Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
      -Interface segregation — принцип разделения интерфейса (класс не должен содержать в себе методов которые он не использует).
      -Dependency inversion — принцип инверсии зависимостей (Верхнеуровневые сущности не должны зависеть от нижнеуровневых реализаций)
    -S Принцип единственной обязанности / ответственности (single responsibility principle / SRP) обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. 
      Например, рассмотрим этот код:
      */class Animal {
        constructor(name: string){ }
        getAnimalName() { }
        saveAnimal(a: Animal) { }
        }/*
        В соответствии с принципом единственной ответственности класс должен решать лишь какую-то одну задачу. Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя свойствами объекта в конструкторе и в методе getAnimalName.
        Если изменится порядок работы с хранилищем данных, используемым приложением, то придётся вносить изменения во все классы, работающие с хранилищем. Такая архитектура не отличается гибкостью, изменения одних подсистем затрагивают другие, что напоминает эффект домино.
        Для того чтобы привести вышеприведённый код в соответствие с принципом единственной ответственности, создадим ещё один класс, единственной задачей которого является работа с хранилищем, в частности — сохранение в нём объектов класса Animal.
      -O Принцип открытости / закрытости (open-closed principle / OCP) декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. 
        */
          class Discount {
            giveDiscount() {
                if(this.customer == 'fav') {
                    return this.price * 0.2;
                }
                if(this.customer == 'vip') {
                    return this.price * 0.4;
                }
            }
        }
          /* Такой подход нарушает принцип открытости-закрытости. Как видно, здесь, если нам надо дать некоей группе клиентов особую скидку, приходится добавлять в класс новый код.
          Для того чтобы переработать этот код в соответствии с принципом открытости-закрытости, добавим в проект новый класс, расширяющий класс Discount. В этом новом классе мы и реализуем новый механизм:
          */
          class VIPDiscount: Discount {
            getDiscount() {
                return super.getDiscount() * 2;
            }
        }
        // Если решено дать скидку в 80% «супер-VIP» клиентам, выглядеть это должно так:
        class SuperVIPDiscount: VIPDiscount {
          getDiscount() {
              return super.getDiscount() * 2;
          }
        }
        /*Как видите, тут используется расширение возможностей классов, а не их модификация.
      -L Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP) Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
        Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
        Напишем функцию, предназначенную для возврата информации о количествах конечностей животного.
        */
        function AnimalLegCount(a: Array<Animal>) {
          for(int i = 0; i <= a.length; i++) {
              if(typeof a[i] == Lion)
                  return LionLegCount(a[i]);
              if(typeof a[i] == Mouse)
                  return MouseLegCount(a[i]);
              if(typeof a[i] == Snake)
                  return SnakeLegCount(a[i]);
          }
        }
          /* Функция нарушает принцип подстановки (и принцип открытости-закрытости).
        Этот код должен знать о типах всех обрабатываемых им объектов и, в зависимости от типа, обращаться к соответствующей функции для подсчёта конечностей конкретного животного. Как результат, при создании нового типа животного функцию придётся переписывать:
        Для того чтобы эта функция не нарушала принцип подстановки, преобразуем её с использованием требований, сформулированных Стивом Фентоном. Они заключаются в том, что методы, 
          принимающие или возвращающие значения с типом некоего суперкласса (Animal в нашем случае) должны также принимать и возвращать значения, типами которых являются его подклассы (Pigeon).
        Вооружившись этими соображениями мы можем переделать функцию AnimalLegCount:
        */
          function AnimalLegCount(a: Array<Animal>) {
            for(let i = 0; i <= a.length; i++) {
                a[i].LegCount();
            }
        }
        AnimalLegCount(animals);
        /* Теперь эта функция не интересуется типами передаваемых ей объектов. Она просто вызывает их методы LegCount. Всё, что она знает о типах — это то, что обрабатываемые ей объекты должны принадлежать классу Animal или его подклассам.
        Теперь в классе Animal должен появиться метод LegCount:
        */
        class Animal {
          //...
          LegCount();
        }
        // А его подклассам нужно реализовать этот метод:
        class Lion extends Animal{
          //...
          LegCount() {
              //...
          }
        }
        /* В результате, например, при обращении к методу LegCount для экземпляра класса Lion производится вызов метода, реализованного в этом классе, и возвращается именно то, что можно ожидать от вызова подобного метода.
      -I Принцип разделения интерфейса (interface segregation principle / ISP) в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». 
        Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, 
          чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют. 
        Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.
        Рассмотрим интерфейс Shape:
        */interface Shape {
        drawCircle();
        drawSquare();
        drawRectangle();
        }
        // В результате классы, реализующие этот интерфейс и представляющие отдельные геометрические фигуры, такие, как круг (Circle), квадрат (Square) и прямоугольник (Rectangle), должны содержать реализацию всех этих методов. Выглядит это так:
        class Circle implements Shape {
          drawCircle(){
              //...
          }
          drawSquare(){
              //...
          }
          drawRectangle(){
              //...
          }    
        }
        class Square implements Shape {
            drawCircle(){
                //...
            }
            drawSquare(){
                //...
            }
            drawRectangle(){
                //...
            }    
        }
        class Rectangle implements Shape {
            drawCircle(){
                //...
            }
            drawSquare(){
                //...
            }
            drawRectangle(){
                //...
            }    
        }
        /* Странный у нас получился код. Например, класс Rectangle, представляющий прямоугольник, реализует методы (drawCircle и drawSquare), которые ему совершенно не нужны. То же самое можно заметить и при анализе кода двух других классов.
          Предположим, мы решим добавить в интерфейс Shape ещё один метод, drawTriangle.
          Это приведёт к тому, что классам, представляющим конкретные геометрические фигуры, придётся реализовывать ещё и метод drawTriangle. В противном случае возникнет ошибка.
          Принцип разделения интерфейса предостерегает нас от создания интерфейсов, подобных Shape из нашего примера. Клиенты (у нас это классы Circle, Square и Rectangle) не должны реализовывать методы, которые им не нужно использовать. 
          Кроме того, этот принцип указывает на то, что интерфейс должен решать лишь какую-то одну задачу (в этом он похож на принцип единственной ответственности), поэтому всё, что выходит за рамки этой задачи, должно быть вынесено в другой интерфейс или интерфейсы.
        */interface Shape {
          draw();
        }
        interface ICircle {
            drawCircle();
        }
        interface ISquare {
            drawSquare();
        }//..
        /*
      -D Принцип инверсии зависимостей (dependency inversion principle / DIP)
        1. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
        2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
        В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. 
          В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.
          */class XMLHttpService extends XMLHttpRequestService {}
          class Http {
            constructor(private xmlhttpService: XMLHttpService) { }
            get(url: string , options: any) {
                this.xmlhttpService.request(url,'GET');
            }
            post() {
                this.xmlhttpService.request(url,'POST');
            }
            //...
          }
          /* Здесь класс Http представляет собой высокоуровневый компонент, а XMLHttpService — низкоуровневый. Такая архитектура нарушает пункт A принципа инверсии зависимостей: «Модули верхних уровней не должны зависеть от модулей нижних уровней. 
              Оба типа модулей должны зависеть от абстракций».
            Класс Http вынужденно зависит от класса XMLHttpService. Если мы решим изменить механизм, используемый классом Http для взаимодействия с сетью — скажем, это будет Node.js-сервис или, например, сервис-заглушка, применяемый для целей тестирования, 
            нам придётся отредактировать все экземпляры класса Http, изменив соответствующий код. Это нарушает принцип открытости-закрытости.
            Класс Http не должен знать о том, что именно используется для организации сетевого соединения. Поэтому мы создадим интерфейс Connection:
            */
            interface Connection {
              request(url: string, opts:any);
            }
            // Интерфейс Connection содержит описание метода request и мы передаём классу Http аргумент типа Connection:
            class Http {
              constructor(private httpConnection: Connection) { }
              get(url: string , options: any) {
                  this.httpConnection.request(url,'GET');
              }
              post() {
                  this.httpConnection.request(url,'POST');
              }
              //...
          }
            /* Теперь, вне зависимости от того, что именно используется для организации взаимодействия с сетью, класс Http может пользоваться тем, что ему передали, не заботясь о том, что скрывается за интерфейсом Connection.
            Как можно заметить, здесь высокоуровневые и низкоуровневые модули зависят от абстракций.
*/