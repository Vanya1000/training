/* 
!JavaScript:

  +Advanced Expressions
    ?Hoisting
      Смысл поднятия в том, что переменные переносятся из места объявления в коде в верх их области видимости. Это механизм относится только к объявлению функций и переменных.
        -Одним из преимуществ помещения в память объявлений функций до выполнения кода то, что можно использовать функцию до её объявления. Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.
        -JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после её использования, то значение будет undefined. неявно происходит так: var a = 5; => var a; a = 5;
    ?Temporal dead zone
      TDZ: термин для описания состояния, когда переменные недоступны. Они находятся в области видимости, но не объявлены.
        -Переменные let и const существуют в TDZ с начала их объемлющей области видимости до момента их объявления.
        -Можно также сказать, что переменные существуют в TDZ с момента их привязки (когда переменная привязывается к области видимости, внутри которой она находится) до момента ее объявления (когда для этой переменной в памяти резервируется имя).
          Если бы мы обратились к переменной в блоке раньше, чем она была объявлена, это вызвало бы ошибку ReferenceError. Из-за TDZ.
      Это связано с hoisting. JS-движок, который разбирает и выполняет код, должен сделать 2 шага:
        1. Парсинг кода в абстрактное синтаксическое дерево/исполняемый байт-код, и
        2. выполнение во время исполнения.
        На шаге 1 происходит подъем, который выполняется движком JS. По сути, он перемещает все объявления переменных в верхнюю часть их области видимости.
        Единственное различие между const и let заключается в том, что когда они поднимаются, их значения не становятся по умолчанию undefiend. console.log(typeof name); => cannot acces name before initialization let name = 'test'; 
        Он знает, что имя существует (оно объявлено), но мы не можем получить к нему доступ до его инициализации.
      Почему у нас есть TDZ?
        -Она помогает нам отлавливать ошибки.
        -Пытаться получить доступ к переменной до ее объявления – это неправильный путь, и он не должен быть возможным.

  +Objects Built-in methods.
    ?Know static Object methods
      Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса. В объявлении класса они помечаются ключевым словом static.
      Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта. Синтаксис:
      */
      class MyClass {
        static property = '...';
      
        static method() {
          '...'
        }
      }
      /*
      Технически, статическое объявление – это то же самое, что и присвоение классу:
      MyClass.property = ...
      MyClass.method = ...
      Статические свойства и методы наследуются. Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.
      к статическому полю нельзя обратиться через this, только через имя класса. Поскольку статический метод относится классу в целом, а не к объекту, то мы НЕ можем обращаться в нем к нестатическим полям/свойствам и методам объекта, наподобие следующего: 
      Person.printAge();  // undefined printAge не статический метод, поэтому мы не можем обратиться к нему через имя класса, а только через объект.
      Однако мы можем использовать в статических методах слово this для обращения к статическим полям и другим статическим методам:

      -Object.create() - создаёт новый объект с указанным прототипом и свойствами. Object.create(proto[, propertiesObject])
        Параметры
          -proto - Объект, который станет прототипом вновь созданного объекта.
          -propertiesObject - Если указан и не равен undefined, должен быть объектом, чьи собственные перечисляемые свойства (то есть такие, которые определены на самом объекте, а не унаследованы по цепочке прототипов) указывают дескрипторы свойств, добавляемых в новый объект.
            Имена добавляемых свойств совпадают с именами свойств в этом объекте. Эти свойства соответствуют второму аргументу метода Object.defineProperties().
        Возвращаемые значения: Новый объект с заданным прототипом и свойствами.
      -Object.assign() - используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.
        Object.assign(target, ...sources) => Возвращается получившийся целевой объект.
        (Он использует внутренний метод [[Get]] на исходных объектах и внутренний метод [[Set]] на целевом объекте, так что он также вызывает геттеры и сеттеры. Именно поэтому он присваивает свойства вместо простого копирования или определения новых свойств.
        Это поведение может сделать метод непригодным для вливания новых свойств в прототип, если вливаемые исходные объекты содержат геттеры. Вместо него для копирования в прототипы определений свойств, включая признак их перечисляемости, следует использовать методы Object.getOwnPropertyDescriptor() и Object.defineProperty().)
      -Object.keys() - Метод Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов). //* Object.keys(obj)
        Метод Object.keys возвращает массив строковых элементов, соответствующих именам перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном перечислении свойств в объекте через цикл. 
        (Если вы хотите увидеть все свойства, а не только перечисляемые, смотрите метод Object.getOwnPropertyNames().)
      -Object.values() - возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов. Object.values(obj)
      -Object.entries() - возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in (разница в том, что for-in перечисляет свойства из цепочки прототипов).
        Порядок элементов в массиве который возвращается Object.entries() не зависит от того как объект объявлен. Если существует необходимость в определённом порядке, то  массив должен быть отсортирован до вызова метода, например Object.entries(obj).sort((a, b) => a[0] - b[0]);.

      -Object.prototype.hasOwnProperty() -  возвращает логическое значение, указывающее, содержит ли объект указанное свойство. obj.hasOwnProperty(prop) prop Имя проверяемого свойства. в отличие от оператора in, этот метод не проверяет существование свойств в цепочке прототипов объекта.
      -Object.prototype.propertyIsEnumerable() - возвращает логическое значение, указывающее, является ли указанное свойство перечислимым. obj.propertyIsEnumerable(prop) prop Имя проверяемого свойства.
      -Object.getPrototypeOf() - возвращает прототип (то есть значение внутреннего свойства [[Prototype]]) указанного объекта. Object.getPrototypeOf(obj)

      -Object.freeze() - замораживает объект, после чего нельзя будет изменить значения свойств объекта.
      -Object.isFrozen() - возвращает true, если объект заморожен, иначе false.
      -Object.seal() - замораживает объект, после чего нельзя будет изменить значения свойств объекта, но можно добавлять новые свойства.
      -Object.isSealed() - возвращает true, если объект заморожен, иначе false.
      Object.preventExtensions() - предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).
      -Object.defineProperties() - определяет новые или изменяет существующие свойства, непосредственно на объекте, возвращая этот объект. //* Object.defineProperties(obj, props)
        Параметры:
          -obj Объект, на котором определяются новые или изменяются существующие свойства.
          -props Объект, чьи собственные перечисляемые свойства представляют собой дескрипторы для создаваемых или изменяемых свойств. Дескрипторы свойств обладают следующими дополнительными ключами
            -configurable: Равен true только в том случае, если тип этого дескриптора свойства может быть изменён и если свойство может быть удалено из содержащего его объекта. Значение по умолчанию установлено в false. // false => запретить удаление "delete user.name"
            -enumerableРавен: true только в том случае, если это свойство можно увидеть через перечисление свойств содержащего его объекта. Значение по умолчанию установлено в false. // false => запретить перечисление "for..in"
            -value: Значение, ассоциированное со свойством. Может быть любым допустимым значением JavaScript (числом, объектом, функцией и т.д.). Значение по умолчанию установлено в undefined.
            -writable: Равен true только в том случае, если значение, ассоциированное со свойством, может быть изменено с помощью оператора присваивания (en-US). Значение по умолчанию установлено в false. // false => запретить присвоение "user.name="
            -get: Функция, возвращающая значение свойства. Значение по умолчанию установлено в undefined.
            -set: Функция, принимающая значение и возвращающая новое значение свойства. Значение по умолчанию установлено в undefined.
              Object.defineProperties(object1, {
                property1: {
                  value: 42,
                  writable: true
                },
                property2: {}
              });
        Возвращаемое значение: Объект, переданный в функцию.
      -Object.defineProperty() - определяет новое или изменяет !существующее свойство, непосредственно на объекте, возвращая этот объект. //* Object.defineProperty(obj, prop, descriptor) descriptor - Дескриптор определяемого или изменяемого свойства.
        Этот метод позволяет точно добавлять или изменять свойства объекта. Обычное добавление свойств через присваивание создаёт свойства, которые можно увидеть через перечисление свойств 
        (с помощью цикла for...in или метода Object.keys), чьи значения могут быть изменены и которые могут быть удалены. Этот же метод позволяет настроить эти дополнительные детали свойства.
        Дескрипторы свойств, присутствующие в объектах, бывают двух основных типов: дескрипторы данных и дескрипторы доступа.
          Дескриптор данных — это свойство, имеющее значение, которое может быть (а может и не быть) записываемым.
          Дескриптор доступа — это свойство, описываемое парой функций — геттером и сеттером.
          Дескриптор может быть только чем-то одним из этих двух типов; он не может быть одновременно обоими.
          И дескриптор данных, и дескриптор доступа являются объектами. Они обладают следующими обязательными ключами: См выше prop
            Object.defineProperty(object1, 'property1', {
              value: 42,
              writable: false
            });
      
    ?Property flags & descriptors (student is able to set property via Object. defineProperty)
    ?Know how to create iterable objects, Symbol.iterator usage (optional)
      Перебираемые объекты
        Объекты, которые можно использовать в цикле for..of, называются итерируемыми.
          -Технически итерируемые объекты должны иметь метод Symbol.iterator.
            -Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации.
            -Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any}, где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение.
          -Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
          -Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
          -Строковый итератор знает про суррогатные пары.
        Объекты, имеющие индексированные свойства и length, называются псевдомассивами. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.
        Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо «настоящих» массивов, потому что эти объекты более абстрактны.
        Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта или псевдомассива obj, и затем мы можем применять к нему методы массивов. Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым контекстом к каждому элементу.
        */
        let range = {
          from: 1,
          to: 5
        };
        
        // 1. вызов for..of сначала вызывает эту функцию
        range[Symbol.iterator] = function() {
        
          // ...она возвращает объект итератора:
          // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
          return {
            current: this.from,
            last: this.to,
        
            // 3. next() вызывается на каждой итерации цикла for..of
            next() {
              // 4. он должен вернуть значение в виде объекта {done:.., value :...}
              if (this.current <= this.last) {
                return { done: false, value: this.current++ };
              } else {
                return { done: true };
              }
            }
          };
        };
        
        // теперь работает!
        for (let num of range) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        // Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код.
        let range2 = {
          from: 1,
          to: 5,
        
          [Symbol.iterator]() {
            this.current = this.from;
            return this;
          },
        
          next() {
            if (this.current <= this.to) {
              return { done: false, value: this.current++ };
            } else {
              return { done: true };
            }
          }
        };
        
        for (let num of range2) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        /*

  +Object as Hash.
    Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object.
    Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть". У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений. 
    Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу. Она позволяет организовать данные ассоциативного массива удобным для хранения способом. 
    Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей. 
      Хеширование
        Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива. Для получения индекса из ключа нужно выполнить два действия: найти хеш (хешировать ключ) и привести его к индексу (например, через остаток от деления).
        Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины.  Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". 
        Хеш всегда одинаковый для одних и тех же данных! console.log(hash); // => -337197338 С хешированием мы встречаемся в разработке часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 не что иное, как хеш, полученный в результате хеширования данных коммита.
        После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления: const index = Math.abs(hash) % 1000; // по модулю // Это делается для того, чтобы индексы не были слишком большими
          Запись:
            const data = {}; data['key'] = 'value';Такая простая, на первый взгляд, строчка, запускает целый процесс. Ниже его грубое описание, без деталей и с упрощениями: Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне
              1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
              const internal = [];
              Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:
              2. Хеширует ключ. Результатом хеширования становится число.
              const hash = crc32.str('key');
              3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
              const index = Math.abs(hash) % 1000;
              В значение внутреннего индексированного массива, по найденному индексу, записывается ещё один массив, первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
              internal[index] = ['key', 'value'];
          Чтение: 
            1. Хешируется ключ. Результатом хеширования становится число.
            const hash = crc32.str('key');
            2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
            const index = Math.abs(hash % 1000);
            3. Если индекс существует, то извлекается массив, который находился внутри, и возвращается наружу.
            return internal[index]; // ['key', 'value']
      Коллизии
        Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат работы хеш-функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.
        Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. Есть несколько способов разрешения коллизий (открытая адресация, метод цепочек), и каждому из них соответствует свой тип хеш-таблицы.
    ?Be able to loop through Object keys
    */
    const objHash = {
      'one': 1,
      'two': 2,
      'three': 3,
    }
    for (let key in objHash) {
      if (objHash.hasOwnProperty(key)) {
        console.log(`${key}: ${objHash[key]}`);
      }
    }
    const objKey = Object.keys(objHash)
    /*

  +Arrays Built-in methods
    Методы массива:
      Добавление/удаление элементов:
        -push(...items)добавляет items в конец массива.
        -pop() удаляет элемент в конце массива и возвращает его.
        -unshift(...items) добавляет items в начало массива.
        -shift() удаляет элемент в начале массива и возвращает его.
        
        -splice  Умеет всё: добавлять, удалять и заменять элементы. arr.splice(index[, deleteCount, elem1, ..., elemN]) Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.
          удаление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент => ["Я", "JavaScript"] | arr.splice(-1,1) – первый с конца. 
          добавление: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 0, "программирование"); // начиная с позиции 1, добавить 0 элементов => ["Я", "программирование", "изучаю", "JavaScript"] | arr.splice(-1,0, "программирование") – первый с конца.
          удаление и замена: let arr = ["Я", "изучаю", "JavaScript"]; arr.splice(1, 1, "программирование"); // начиная с позиции 1, удалить 1 элемент и вставить "программирование" => ["Я", "программирование"]
          Отрицательные индексы разрешены: let arr = [1, 2, 5];  arr.splice(-1, 0, 3, 4); => [1, 2, 3, 4, 5]
        -slice arr.slice([start], [end]) Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
          let arr = ["t", "e", "s", "t"];  arr.slice(1, 3) => ["e", "s"] arr.slice(-2) => ["s", "t"] 
          Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
        -concat arr.concat(arg1, arg2...) Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения. Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
          let arr = ["t", "e", "s", "t"];  arr.concat("test", "test2") => ["t", "e", "s", "t", "test", "test2"]
      Перебор: 
        -forEach Позволяет запускать функцию для каждого элемента массива. arr.forEach(function(item, index, array) { // ... делать что-то с item }); Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
      Поиск в массиве: (Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.)
        -arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
        -arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
        -arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен. let arr = [1, 0, false]; arr.includes(0) => true arr.includes(2) => false
          Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf.
        -arr.find(fn) findLast()  Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием? Функция вызывается по очереди для каждого элемента массива. Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
          let result = arr.find(function(item, index, array) { // если true - возвращается текущий элемент и перебор прерывается // если все итерации оказались ложными, возвращается undefined});
        -arr.findIndex(fn) findLastIndex() по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
        -arr.filter(fn) На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn). Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов. let someUsers = users.filter(item => item.id < 3);
      Преобразование и упорядочения массива:
        -arr.map(fn) применяет функцию fn к каждому элементу массива и возвращает новый массив. Функция fn принимает 3 аргумента: item, index и array.
        -arr.sort(fn) сортирует массив на месте(копия массива не создаётся), меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. let arr = [ 1, 2, 15 ]; arr.sort(); => [ 1, 15, 2 ]
          По умолчанию элементы сортируются как строки. Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и действительно выходит, что "2" > "15".
          Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная быстрая сортировка). 
          Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение.
          На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше». Это позволяет писать более короткие функции: let arr = [ 1, 15, 2 ]; arr.sort((a, b) => a - b); => [ 1, 2, 15 ]
        -arr.reverse() Метод reverse() на месте переставляет элементы массива (меняя исходный массив), на котором он был вызван, изменяет массив и возвращает ссылку на него.
        _-str.split(delim) Он разбивает строку на массив по заданному разделителю delim. В примере  таким разделителем является строка из запятой и пробела. let arr = names.split(', '); Или с пустым аргументом разбил бы строку на массив букв  str.split('')
          У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2); => [ 'Вася', 'Петя' ]
        -arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.
        -reduce/reduceRight Они используются для вычисления какого-нибудь единого значения на основе всего массива. let value = arr.reduce(function(previousValue, item, index, array) {...}, [initial]);
          Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов. 
          previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial), а при отсутствии initial в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
          При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент. По окончании он становится результатом reduce.
      Array.isArray - Массивы не образуют отдельный тип языка. Они основаны на объектах. Поэтому typeof не может отличить простой объект от массива. Он возвращает true, если value массив, и false, если нет.
      Другие:
        -arr.some(fn)/arr.every(fn) Функция fn вызывается для каждого элемента массива. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
        -arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end. Если end не задан, заполняется до конца массива.
        -arr.copyWithin(target, start, end) – копирует массив с индекса start до end в массив с индексом target. Если end не задан, копируется до конца массива. [1, 2, 3, 4, 5].copyWithin(0, 3); => [4, 5, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(0, 3, 4); => [4, 2, 3, 4, 5]
        -arr.flat(n) – var newArray = arr.flat(depth); Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth. (На сколько уровней вложенности уменьшается мерность исходного массива. По умолчанию 1.)
          const arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); => [1, 2, 3, 4, [5, 6]]      const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]; arr4.flat(Infinity); => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          Метод flat удаляет пустые слоты из массива: var arr4 = [1, 2, , 4, 5]; arr4.flat(); => [1, 2, 4, 5]
        -arr.flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. 
          Это идентично map функции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно.
          let arr1 = ["it's Sunny in", "", "California"]; arr1.map(x => x.split(" ")); => [["it's","Sunny","in"],[""],["California"]] arr1.flatMap(x => x.split(" ")); => ["it's","Sunny","in", "", "California"]
        -arr.keys() возвращает новый итератор массива Array Iterator, содержащий ключи каждого индекса в массиве. var arr = ['a', 'b', 'c']; var iterator = arr.keys(); iterator.next() => { value: 0, done: false }
        -arr.values() возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.
        -arr.toString() возвращает строковое представление указанного массива и его элементов. Cоединяет массив и возвращает одну строку, содержащую каждый элемент массива, разделённый запятыми.
    ?Know how to copy array part
    ?Know how to flatten nested array
    */
    Array.prototype.flatten = function() {
      var ret = [];
      for(var i = 0; i < this.length; i++) {
          if(Array.isArray(this[i])) {
              ret = ret.concat(this[i].flatten());
          } else {
              ret.push(this[i]);
          }
      }
      return ret;
  };
    /*

  +Arrays Iterating, Sorting, Filtering
    ?Be able to custom sorting for Array
    */
    array.sort((x, y) => {
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
      return 0;
    });
    /*
    ?Be able to filter Array elements

  +Functional Scope
    Область видимости или Scope
      -Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области кода.
    Глобальная область видимости или Global Scope
      -В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.
    Локальная область видимости или Local Scope
      -Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.
      -Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.
      */
      // Глобальная область
        function foo1(){
       // Локальная область 1
          function foo2(){
           // Локальная область 2
          }
        }
      /*
    Область видимости функции
      -Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.
    Область видимости блока
      -Область видимости блока - это область в условиях if и switch или циклов for, и while. Вообще говоря, всякий раз, когда мы видим фигурные скобки {} - это блок. В ES6 ключевые слова const и let позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.
    Лексическая область видимости
      -Ещё один момент, о котором стоит упомянуть - это лексическая область. Лексическая область означает, что дочерняя область имеет доступ к переменным, определенным в родительской области. Дочерние функции лексически связаны с контекстом исполнения их родителей.
    Динамическая область видимости
      -Лексическая область видимости - это набор правил о том, как и где движок JavaScript может найти переменную. Ключевой характеристикой лексического контекста является то, что он определяется во время написания кода (при условии, что мы не используем eval () или with).
      -Динамическая область видимости, по понятным причинам, подразумевает, что существует модель, в которой область видимости может определяться динамически во время выполнения, а не статически во время создания. 
      */
      function foo(){
        console.log(a); // 5 В лексической области видимости указывается, что ссылка на a в foo() будет преобразована в глобальную переменную a, что приведет к выводу значения 5.
      }

      function bar(){
        var a = 10;
        foo();
      }
      
      var a = 5;
      
      bar();
      /*
      Динамическая область видимости, напротив, не связана с тем, как и где объявляются функции и области, а связана с тем, откуда они вызываются. Другими словами, цепочка областей видимости основана на стеке вызовов, а не на вложении областей видимости в коде.
      Таким образом, если бы JavaScript имел динамическую область видимости, то, когда выполняется foo(), теоретически приведенный ниже код, вместо 5 вернул бы 10 в качестве вывода.
      Когда foo() не может найти ссылку на переменную для a, вместо просмотра вложенной (лексической) цепочки областей видимости, он идет вверх по стеку вызовов, чтобы найти, откуда вызывалась функция foo(). Поскольку foo() была вызвана из bar(), он проверяет переменные в области видимости bar() и находит там a со значением 10.
      Но JavaScript, на самом деле, не имеет динамической области видимости. Он имеет только лексическую область. А вот механизм this подобен динамической области видимости.
      Вывод
        -Лексическая область - определяется во время написания кода, тогда как динамическая область (и this) - во время выполнения. Лексическая область заботится о том, где была объявлена функция, а динамическая область - о том, откуда была вызвана функция.
        -И наконец: this заботится о том, как была вызвана функция. Это показывает нам, насколько тесно механизм this связан с идеей динамической области видимости.
    ?Know global scope and functional scope
    ?Know variables visibility areas
    ?let var const - differences
      Существует 2 основных отличия var от let/const:
        1. Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
        2. «var» допускает повторное объявление переменной. let, будет ошибка
        3. «var» обрабатываются в начале запуска функции. Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того, 
          в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции). Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
          Объявления переменных «всплывают», но присваивания значений – нет. Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. 
      Переменные let:
        1. Видны только после объявления и только в текущем блоке.
        2. Нельзя переобъявлять (в том же блоке).
        3. При объявлении переменной в цикле for(let …) – она видна только в этом цикле. Причём каждой итерации соответствует своя переменная let.
      Переменная const – это константа, в остальном – как let.
    ?Understand nested scopes and able work with them

  +Functions Parameters / Arguments
  /here
    ?Know how to define Function parameters
    ?Know difference between parameters passing by value and by reference
      Передача параметров по значению
        Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.
        При вызове функции change ей передается число n. Однако после вызова функции мы видим, что число n не изменилось, хотя в самой функции произошло увеличение значения параметра. 
        Потому что при вызове функция change получает копию значения переменной n. И любые изменения с этой копией никак не затрагивают саму переменную n.
      Передача по ссылке
        Объекты и массивы передаются по ссылке. То есть функция получает сам объект или массив, а не их копию.
    ?Know how to handle dynamic amount of Function parameters
      Spread syntax Остаточные параметры (...)
        Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена. Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.
        Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».
        */
        function sumAll(...args) { // args — имя массива
          let sum = 0;
        
          for (let arg of args) sum += arg;
        
          return sum;
        }

        function showName(firstName, lastName, ...titles) {
          alert( firstName + ' ' + lastName ); // Юлий Цезарь
        
          // Оставшиеся параметры пойдут в массив
          // titles = ["Консул", "Император"]
          alert( titles[0] ); // Консул
          alert( titles[1] ); // Император
          alert( titles.length ); // 2
        }
        /*
        Остаточные параметры должны располагаться в конце! ...rest должен всегда быть последним.
      Объект arguments можно использовать при вызове функции с бо́льшим количеством аргументов, чем было предусмотрено в её объявлении. Такой способ удобен для функций, в которые допустимо передавать переменное количество аргументов. 
        Можно воспользоваться arguments.length, чтобы определить количество переданных в функцию аргументов, а затем обработать каждый из них с помощью объекта arguments. Чтобы определить количество параметров функции, описанных в её сигнатуре, можно использовать свойство Function.length.
        Использование оператора расширения для объекта arguments
          Как и с обычными массива-подобными объектами, для преобразования объекта arguments в обычный массив можно использовать метод Array.from() или оператор расширения: var args = Array.from(arguments); var args = [...arguments];
          Свойства:
            -arguments.callee Ссылка на функцию, которая выполняется в текущий момент.
            -arguments.caller Ссылка на функцию, которая вызвала функцию, выполняющуюся в текущий момент.
            -arguments.length Количество переданных в функцию аргументов.
            -arguments[@@iterator]  Возвращает новый объект Array Iterator, содержащий значения для каждого индекса в массиве.
      
  +ECMAScript Intermediate
    ?Function default parameters
      Параметры по умолчанию (Default parameters)
        В JavaScript параметры функции по умолчанию имеют значение undefined. Однако в некоторых ситуация может быть полезным поменять значение по умолчанию. В таких случаях default parameters могут быть весьма кстати.
        В прошлом для этого было необходимо в теле функции проверять значения параметров на undefined и в положительном случае менять это значение на дефолтное (default).
        С параметрами по умолчанию проверка наличия значения параметра в теле функции не нужна. Теперь вы можете просто указать значение по умолчанию для параметра b в объявлении функции:
        */
        function multiply(a, b = 1) {
          return a * b;
        }
        /*
    ?ECMA script modules
      По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». Модуль обычно содержит класс или библиотеку с функциями.
      -AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
      -CommonJS – модульная система, созданная для сервера Node.js.
      -UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.
      Система модулей на уровне языка появилась в стандарте JavaScript в 2015 году и постепенно эволюционировала.
        1. Что такое модуль? 
          Модуль – это просто файл. Один скрипт – это один модуль. Чтобы работал import/export, нужно для браузеров указывать атрибут <script type="module">.
          Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
            -export отмечает переменные и функции, которые должны быть доступны вне текущего модуля. export function sayHi(user) {}
            -import позволяет импортировать функциональность из других модулей. import {sayHi} from './sayHi.js';
          У модулей есть ряд особенностей:
            -Отложенное (deferred) выполнение по умолчанию.
              Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer (описан в главе Скрипты: async, defer). Это верно и для внешних и встроенных скриптов-модулей.
                -загрузка внешних модулей, таких как <script type="module" src="...">, не блокирует обработку HTML.
                -модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.
                -сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
            -Атрибут async работает во встроенных скриптах.
            -Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
            -Дублирующиеся внешние скрипты игнорируются.
        2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
          Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
          Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.
          Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.
        3. В модулях всегда включена директива use strict.
        4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.
          Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
          📁 alert.js
          alert("Модуль выполнен!");

          Импорт одного и того же модуля в разных файлах
          📁 1.js
          import `./alert.js`; // Модуль выполнен!
          📁 2.js
          import `./alert.js`; // (ничего не покажет)
          На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.
          Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте admin, то другие модули тоже увидят эти изменения.
          Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.
        В модуле «this» не определён
        Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.
      Экспорт
        -Экспорт до объявления
          export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        -Экспорт отдельно от объявления 
          Также можно написать export отдельно. export {sayHi, sayBye}; // список экспортируемых переменных
        -Экспортировать «как» export {sayHi as hi, sayBye as bye}; Теперь hi и bye – официальные имена для внешнего кода, их нужно использовать при импорте:
        -Экспорт по умолчанию
          На практике модули встречаются в основном одного из двух типов:
            -Модуль, содержащий библиотеку или набор функций, как say.js выше.
            -Модуль, который объявляет что-то одно, например модуль user.js экспортирует только class User. (default export)
          export default class User {} Заметим, в файле может быть не более одного export default. …И потом импортируем без фигурных скобок: import User from './user.js'; // не {User}, просто User
          Так как в файле может быть максимум один export default, то экспортируемая сущность не обязана иметь имя.
            экспортируем значение, не создавая переменную export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; Это нормально, потому что может быть только один export default на файл, так что import без фигурных скобок всегда знает, что импортировать.
          Имя «default»
            чтобы экспортировать функцию отдельно от её объявления: export {sayHi as default};
      Импорт
        Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так: import {sayHi, sayBye} from './say.js';
        Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например: import * as say from './say.js'; 
          1. Предположим, мы добавили в наш проект стороннюю библиотеку say.js с множеством функций: Теперь, если из этой библиотеки в проекте мы используем только одну функцию:
            …Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
          2. Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: sayHi() вместо say.sayHi().
          3. Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.
        Импорт «как» 
          Мы также можем использовать as, чтобы импортировать под другими именами. import {sayHi as hi, sayBye as bye} from './say.js';
    ?Know how to use spread operator for Function arguments
      Остаточные параметры (Rest parameters)
        Остаточные параметры предоставляют нам массив неопределённых аргументов. В примере мы используем остаточные параметры, чтобы собрать аргументы с индексами со 2-го до последнего. 
        Затем мы умножим каждый из них на значение первого аргумента. 
        */
        function multiply(multiplier, ...theArgs) {
          return theArgs.map(x => multiplier * x);
        }
        
        var arr = multiply(2, 1, 2, 3);
        console.log(arr); // [2, 4, 6]
        /*
    ?Be able to compare arguments and rest parameters
      Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments. Этот способ всё ещё работает, мы можем найти его в старом коде.
      Но у него есть один недостаток. Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).
      К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.
      Соответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.
      Стрелочные функции не имеют "arguments"
    ?Spread operator for Array
      Оператор расширения
        Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное. Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.
        Для Math.max:
        */
        let arr = [3, 5, 1];
        alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
        // Мы даже можем комбинировать оператор расширения с обычными значениями:
        let arr1 = [1, -2, 3, 4];
        let arr2 = [8, 3, -8, 1];
              
        alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
        /*
    ?Understand and able to use spread operator for Array concatenation Destructuring assignment
      Оператор расширения можно использовать и для слияния массивов:
      */
      let arr = [3, 5, 1];
      let arr3 = [8, 9, 15];
      let merged = [0, ...arr, 2, ...arr3]; // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
      /*
      В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.
      Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:
      */
      let str = "Привет";
      alert( [...str] ); // П,р,и,в,е,т
      /*
      Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, чтобы перебирать элементы. Так же, как это делает for..of.
      Цикл for..of перебирает строку как последовательность символов, поэтому из ...str получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи стандартного объявления массива: [...str].
      Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив: Array.from(str)
        Но между Array.from(obj) и [...obj] есть разница: 
          -Array.from работает как с псевдомассивами, так и с итерируемыми объектами 
          -Оператор расширения работает только с итерируемыми объектами
      Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.
        Как отличить их друг от друга:
          Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
          Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
    ?Be able to discover destructuring assignment concept
      Деструктурирующее присваивание
          Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.
          Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
        Деструктуризация массива
          у нас есть массив с именем и фамилией let arr = ["Ilya", "Kantor"] деструктурирующее присваивание записывает firstName = arr[0]  и surname = arr[1] let [firstName, surname] = arr;
          Отлично смотрится в сочетании со split или другими методами, возвращающими массив: let [firstName, surname] = "Ilya Kantor".split(' ');
          -Деструктуризация» не означает «разрушение».
            «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.
            Это просто короткий вариант записи: let firstName = arr[0]; let surname = arr[1];
          -Пропускайте элементы, используя запятые: 
            Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой: let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
          -Работает с любым перебираемым объектом с правой стороны
            На самом деле мы можем использовать любой перебираемый объект, не только массивы: let [a, b, c] = "abc";  let [one, two, three] = new Set([1, 2, 3]);
          -Присваивайте чему угодно с левой стороны
            Мы можем использовать что угодно «присваивающее» с левой стороны. Например, можно присвоить свойству объекта: let user = {}; [user.name, user.surname] = "Ilya Kantor".split(' ');
          -Цикл с .entries()
            Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:
            */
            let user = {
              name: "John",
              age: 30
            };
            
            // цикл по ключам и значениям
            for (let [key, value] of Object.entries(user)) {
              alert(`${key}:${value}`); // name:John, затем age:30
            }
            /*
          -Трюк обмена переменных
            Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего присваивания: 
              let guest = "Jane"; let admin = "Pete"; [guest, admin] = [admin, guest];
              Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.Таким образом, мы можем поменять местами даже более двух переменных.
          -Остаточные параметры «…»
            Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):
            let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]; Переменная rest является массивом из оставшихся элементов.
          -Значения по умолчанию
            Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:
            Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =: let [name = "Guest", surname = "Anonymous"] = ["Julius"];
            Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют. let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
        Деструктуризация объекта
          let {var1, var2} = {var1:…, var2:…} У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}. 
              let {title, width, height} = options; Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения.
            -Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
              Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие: let {width: w, height: h, title} = options; // width -> w // height -> h // title -> title
              Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.
            -Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь: let {width = 100, height = 200, title} = options;
              Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.
            -Мы также можем совмещать : и =:
              let {width: w = 100, height: h = 200, title} = options;
          -Остаток объекта «…»
            Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
            let options = {
              title: "Menu",
              height: 200,
              width: 100
            };
            let {title, ...rest} = options;
            сейчас title="Menu", rest={height: 200, width: 100}
              В примерах выше переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох.
                Вот так не будет работать:
                  let title, width, height;
                  {title, width, height} = {title: "Menu", width: 200, height: 100};
                  Проблема в том, что JavaScript обрабатывает {...} в основном потоке кода (не внутри другого выражения) как блок кода. Такие блоки кода могут быть использованы для группировки операторов.
                  Так что здесь JavaScript считает, что видит блок кода, отсюда и ошибка. На самом-то деле у нас деструктуризация.  Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки (...):
                  ({title, width, height} = {title: "Menu", width: 200, height: 100});
          -Вложенная деструктуризация
            Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.
        Умные параметры функций
          Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов.  На помощь приходит деструктуризация!
          Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
            */
              // мы передаём объект в функцию
              let options = {
                title: "My menu",
                items: ["Item1", "Item2"]
              };

              // ...и она немедленно извлекает свойства в переменные
              function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
                // title, items – взято из options,
                // width, height – используются значения по умолчанию
                alert( `${title} ${width} ${height}` ); // My Menu 200 100
                alert( items ); // Item1, Item2
              }

              showMenu(options);
            /*
            Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
            showMenu({}); // ок, все значения - по умолчанию  showMenu(); // так была бы ошибка
            Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {}
            В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.
    ?Understand variables and Function arguments destructuring assignment
      См выше
    ?String templates
      Шаблонные строки
        Шаблонные строки — это ещё один способ создания строк, наравне с одинарными или двойными кавычками. Шаблонные строки объявляются с помощью обратных кавычек.
        Шаблонная строка может быть многострочной, все переносы строк в ней будут сохранены. В шаблонной строке с помощью синтаксиса ${ } можно использовать любые выражения JavaScript. Любой нестроковый результат (например, объект) будет приведён к строке.
        `строка текста ${выражение} строка текста`
      Экранирование символов
        const doubleQuotes = "\"Я вам запрещаю!\" – Джейсон Стэтхем." => const doubleQuotes = `"Я вам запрещаю!" – Джейсон Стэтхем.`
      Переносы строк Секция статьи "Переносы строк"
        const str = 'Я первая строка\n' + 'А я вторая строка\n' + 'Ну и так далее'
        Выглядит не очень удобно, даже если записать их на отдельных строках в редакторе. В шаблонных строках можно делать переносы строк, как в обычном тексте, и все они сохранятся.
        В этой строке будут так же сохранены все пробелы и табуляции в начале строк. Это может быть удобно для написания html-разметки в строке.
      Динамические строки
        В обычных строках, чтобы подставить значение в строку, необходимо использовать конкатенацию через оператор +. const url = 'https://' + host + '/?search=' + query
        В итоге получается нужная нам строка, но для каждого такого динамического значения необходимо явно добавлять оператор сложения + и дробить строку на части, если между динамическими частями есть статические.
        const url = `https://${host}/?search=${query}`
      Будьте осторожны при написании HTML внутри шаблонных строк. Шаблонные строки, так же как и обычные, не экранируют спецсимволы. Это значит что использование ненадёжного HTML из шаблонной строки может привести к различным атакам.
    ?Know how for..of loop works (optional)
      Оператор for...of относится к типу оператора for, который циклически повторяет итерируемые объекты ( iterable objects)), пока не достигнет конца строки. for(let a of arr) {log(a)}
        Цикл for...of через массив arr выполнен с меньшим количеством кода, чем при использовании цикла for.
      Итерируемые объекты и итераторы
        По словам разработчика Mozilla, “Благодаря итерируемому протоколу объекты JavaScript могут определять или настраивать поведение итерации, например, какие значения повторяются циклически в конструкции for..of.” и “чтобы быть итерируемым, 
        объект реализует метод @@iterator, означающий, что объект (или один из объектов в цепочке прототипов) должен иметь свойство с ключом @@iterator, которое доступно через константу Symbol.iterator.”
        Протокол Iterator определяет способ, с помощью которого поток значений возвращается из объекта. Итератор реализует метод next. Метод next обладает следующим рядом правил:
          -Он должен возвращать объект со свойствами done, value {done, value}
          -done относится к типу Boolean и указывает на достижение конца потока.
          -value содержит значение текущего цикла.
      Примеры итерируемых объектов:  (String Map TypedArray Array Set Generator) Объект не является итерируемым. Чтобы сделать его итерируемым, необходимо реализовать метод Symbol.iterator.
  +Advanced Functions
    ?this scope
      В JavaScript this — это текущий контекст исполнения функции. Поскольку функцию можно вызвать четырьмя способами:
        -вызов функции: alert('Hello World!'),
        -вызов метода: console.log('Hello World!'),
        -вызов конструктора: new RegExp('\\d'),
        -непрямой вызов: alert.call(undefined, 'Hello World!'),
        и каждый из них определяет свой контекст, поведение this слегка не соответствует ожиданиям начинающих разработчиков. Кроме того, strict mode также влияет на контекст исполнения.
      Прежде чем мы начнём, давайте познакомимся с несколькими терминами:
        -Вызов — это исполнение кода тела функции. Например, вызовом функции parseInt будет parseInt('15').
        -Контекстом вызова является значение this в теле функции.
        -Область видимости функции — это набор переменных, объектов и функций, к которым можно получить доступ из тела функции.
      Вызов функции
        Вызов функции совершается, когда за выражением, являющимся объектом функции, следуют открывающая скобка (, разделённый запятыми список аргументов и закрывающая скобка ), например, parseInt('18').
        Выражение не может быть аксессором myObject.myFunction, который совершает вызов метода. Например, [1,5].join(',') — это вызов не функции, а метода.
        this при вызове функции
          this — это глобальный объект при вызове функции. Глобальный объект определяется средой исполнения. В веб-браузере это объект window. В вызове функции контекстом исполнения является глобальный объект.
          Когда this используется вне области видимости какой-либо функции (самая внешняя область видимости: контекст глобального исполнения), он также относится к глобальному объекту: console.log(this === window); // => true
        this при вызове функции в strict mode
          Strict mode был введён в ECMAScript 5.1 и представляет собой более надёжную систему защиты и проверки ошибок. Этот режим влияет на контекст исполнения, заставляя this быть undefined. Контекст исполнения перестаёт быть глобальным объектом, в отличие от предыдущего случая.
          Strict mode активен не только в текущей области видимости, но и во всех вложенных: 
          Один файл JavaScript может содержать как «строгие», так и «нестрогие» функции. Поэтому возможно иметь в одном скрипте разные контексты исполнения для одного типа вызова:
        Ловушка: this во внутренней функции
          Обычной ошибкой при работе с вызовом функции является уверенность в том, что this во внутренней функции такой же, как и во внешней. Вообще-то контекст внутренней функции зависит только от вызова, а не от контекста внешней функции.
          Чтобы получить ожидаемый this, модифицируйте контекст внутренней функции при помощи непрямого вызова (используя .call() или .apply(), об этом позже) или создайте связанную функцию (используя .bind(), об этом тоже поговорим позже).
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                // this is window or undefined in strict mode
                console.log(this === numbers); // => false
                return this.numberA + this.numberB;
              }
              return calculate();
            }
          };
         console.log(numbers.sum()); // => NaN or throws TypeError in strict mode
          /*
          numbers.sum() — это вызов метода объекта, поэтому контекстом sum является объект numbers. Функция calculate определена внутри sum, поэтому вы можете ожидать, что this — это объект numbers и в calculate(). 
          Тем не менее, calculate() — это вызов функции, а не метода, и поэтому его this — это глобальный объект window или undefined в strict mode. Даже если контекстом внешней функции sum является объект numbers, у него здесь нет власти.
          Для решения проблемы функция calculate должна быть исполнена в том же контексте, что и метод sum, чтобы получить доступ к значениям numberA и numberB. Это можно сделать при помощи метода .call():
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                console.log(this === numbers); // => true
                return this.numberA + this.numberB;
              }
              // use .call() method to modify the context
              return calculate.call(this);
            }
          };
         console.log(numbers.sum()); // => 15
          /* calculate.call(this) исполняет функцию calculate, но дополнительно модифицирует контекст в соответствии с первым параметром.
        Вызов метода
          Метод — это функция, хранящаяся в объекте. helloFunction — это метод в myObject. Для доступа к методу нужно использовать аксессор: myObject.helloFunction.
          Вызов метода совершается, когда за выражением в виде аксессора, расценивающемся как объект функции, следует пара скобок и разделенный запятыми список аргументов между ними.
          В прошлом примере myObject.helloFunction() — это вызов метода helloFunction объекта myObject. Также вызовами метода являются: [1, 2].join(',') или /\s/.test('beautiful world').
          Важно отличать вызов функции от вызова метода. Главным отличием является то, что для вызова метода необходим аксессор (<expression>.functionProperty() или <expression>['functionProperty']()), а для вызова функции — нет (<expression>()).
          this при вызове метода
            this — это объект, которому принадлежит метод. При вызове метода, принадлежащего объекту, this становится этим объектом.
            Вызов calc.increment() сделает контекстом функции increment объект calc. Поэтому можно спокойно использовать this.num.
            Объект JavaScript наследует метод своего прототипа. Когда вызывается метод, унаследованный от объекта, контекстом всё равно является сам объект:
            */
            var myDog = Object.create({
              sayName: function() {
                 console.log(this === myDog); // => true
                  return this.name;
              }
            });
            myDog.name = 'Milo';
            // method invocation. this is myDog
            console.log(myDog.sayName()); // => 'Milo'
            /*
            Object.create() создаёт новый объект myDog и создаёт прототип. Объект myDog наследует метод sayName. Когда исполняется myDog.sayName(), myDog является контекстом исполнения.
            В синтаксисе ECMAScript 6 class контекст вызова метода — тоже сам объект:
           */
            class Planet {
              constructor(name) {
                this.name = name;
              }
              getName() {
                console.log(this === earth); // => true
                return this.name;
              }
            }
            var earth = new Planet('Earth');
            // method invocation. the context is earth
            console.log(earth.getName()); // => 'Earth'
            /*
          Ловушка: отделение метода от его объекта
            Метод объекта можно переместить в отдельную переменную. При вызове метода с использованием этой переменной вы можете подумать, что this — это объект, в котором определён метод.
            На самом деле, если метод вызван без объекта, происходит вызов функции, и this становится глобальным объектом window или undefined. Создание связанной функции исправляет контекст — им становится объект, в котором содержится метод.
            Следующий пример создаёт конструктор Animal и его экземпляр — myCat. Затем через 1 секунду setTimeout() логирует информацию об объекте myCat:
            */
            function Animal(type, legs) {
              this.type = type;
              this.legs = legs;
              this.logInfo = function() {
                console.log(this === myCat); // => false
                console.log('The ' + this.type + ' has ' + this.legs + ' legs');
              };
            }
            var myCat = new Animal('Cat', 4);
            // logs "The undefined has undefined legs"
            // or throws a TypeError, in strict mode
            setTimeout(myCat.logInfo, 1000); // setTimeout(myCat.logInfo.bind(myCat), 1000);
            /*
            Вы можете подумать, что setTimeout вызовет myCat.logInfo(), которая запишет информацию об объекте myCat. Но метод отделяется от объекта, когда передаётся в качестве параметра: setTimout(myCat.logInfo), и через секунду происходит вызов функции.
            Когда logInfo вызывается как функция, this становится глобальным объектом или undefined (но не объектом myCat), поэтому информация об объекте выводится некорректно. 
            myCat.logInfo.bind(myCat) возвращает новую функцию, исполняемую в точности как logInfo, но this которой остаётся myCat даже в случае вызова функции.
          Вызов конструктора
            Вызов конструктора совершается, когда за ключевым словом new следует выражение, расцениваемое как объект функции, и пара скобок с разделённым запятыми списком аргументов. Пример: new RegExp('\\d').
            В этом примере объявляется функция Country, которая затем вызывается в качестве конструктора:
            */
            function Country(name, traveled) {
              this.name = name ? name : 'United Kingdom';
              this.traveled = Boolean(traveled); // transform to a boolean
            }
            Country.prototype.travel = function() {
              this.traveled = true;
            };
           // Constructor invocation
            var france = new Country('France', false);
           // Constructor invocation
            var unitedKingdom = new Country;
            
           france.travel(); // Travel to France
            /*
            new Country('France', false) — это вызов конструктора функции Country. Результатом исполнения является новые объект, чьё поле name равняется 'France'. Если конструктор вызван без аргументов, скобки можно опустить: new Country.
            Начиная с ECMAScript 6, JavaScript позволяет определять конструкторы ключевым словом class.
            */
            class City {
              constructor(name, traveled) {
                this.name = name;
                this.traveled = false;
              }
              travel() {
                this.traveled = true;
              }
            }
            // Constructor invocation
            var paris = new City('Paris', false);
            paris.travel();
            /*
            new City('Paris') — это вызов конструктора. Инициализация объекта управляется специальным методом класса: constructor, this которого является только что созданным объектом.
            Вызов конструктора создаёт новый пустой объект, наследующий свойства от прототипа конструктора. Ролью функции-конструктора является инициализация объекта. Как вы уже знаете, контекст этого типа вызова называется экземпляром.
            Когда перед аксессором myObject.myFunction идёт ключевое слово new, JavaScript совершит вызов конструктора, а не метода. Возьмём в качестве примера new myObject.myFunction(): 
            сперва при помощи аксессора extractedFunction = myObject.myFunction функция извлекается, а затем вызывается как конструктор для создания нового объекта: new extractedFunction().
            this в вызове конструктора
              this — это только что созданный объект. Контекстом вызова конструктора является только что созданный объект. Он используется для инициализации объекта данными из аргументом функции-конструктора.
              Когда исполняется new Dog(), JavaScript создаёт пустой объект и делает его контекстом метода constructor. Теперь вы можете добавлять свойства, используя this: this.property = 'Default Value'.
          Непрямой вызов
            Непрямой вызов производится, когда функция вызывается методами .call() или .apply(). Функции в JavaScript — объекты первого класса, то есть функция — это объект типа Function.
            Из списка методов этой функции два, .call() и .apply(), используются для вызова функции с настраиваемым контекстом:
              -Метод .call(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова, а список аргументов arg1, arg2, ... передаётся вызываемой функции.
              -Метод .apply(thisArg, [args]) принимает в качестве первого аргумента thisArg контекст вызова, а array-like объект [args] передаётся вызываемой функции в качестве аргумента.
              */
              function increment(number) {
                return ++number;
              }
              console.log(increment.call(undefined, 10));    // => 11
              console.log(increment.apply(undefined, [10])); // => 11
              /*
              increment.call() и increment.apply() оба вызывают функцию-инкремент с аргументом 10. Главным отличием между ними является то, что .call() принимает список аргументов, 
              например, myFunction.call(thisValue, 'value1', 'value2'), а .apply() принимает эти значения в виде array-like объекта: myFunction.apply(thisValue, ['value1', 'value2']).
              this при непрямом вызове
                this — это первый аргумент .call() или .apply()
              Непрямой вызов может пригодиться, когда функцию нужно вызвать в особом контексте, например, решить проблему при вызове функции, где this — всегда window или undefined. Его также можно использовать для симуляции вызова метода объекта.
          Связанная функция
            Связанная функция — это функция, связанная с объектом. Обычно она создаётся из обычной функции при помощи метода .bind(). У двух функций совпадают тела и области видимости, но различаются контексты.
            Метод .bind(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова связанной функции, а необязательный список аргументов arg1, arg2, ... передаётся вызываемой функции. Он возвращает новую функцию, связанную с thisArg.
            Следующий код создаёт связанную функцию и вызывает её:
            */ 
            function multiply(number) {
              'use strict';
              return this * number;
            }
            // create a bound function with context
            var double = multiply.bind(2);
            // invoke the bound function
            console.log(double(3));  // => 6
            console.log(double(10)); // => 20
            /*
            multiply.bind(2) возвращает новый объект функции double, который связан с числом 2. Код и область видимости у multiply и double совпадают. В отличие от методов .apply() и .call(), сразу вызывающих функцию, метод .bind() возвращает новую функцию, которую впоследствии нужно будет вызвать с уже заданным this.
            this в связанной функции
              this — это первый аргумент .bind() Ролью .bind() является создание новой функции, чей вызов будет иметь контекст, заданный в первом аргументе .bind(). Это — мощный инструмент, позволяющий создавать функции с заранее определённым значением this.
              */
              var numbers = {
                array: [3, 5, 10],
                getNumbers: function() {
                  return this.array;
                }
              };
              // Create a bound function
              var boundGetNumbers = numbers.getNumbers.bind(numbers);
              console.log(boundGetNumbers()); // => [3, 5, 10]
              // Extract method from object
              var simpleGetNumbers = numbers.getNumbers;
              console.log(simpleGetNumbers()); // => undefined or throws an error in strict mode
              /*
              numbers.getNumbers.bind(numbers) возвращает функцию boundGetNumbers, которая связана с объектом numbers. Затем boundGetNumbers() вызывается с this, равным numbers, и возвращает корректный объект.
          Стрелочная функция
            Стрелочная функция не создаёт свой контекст исполнения, а заимствует this из внешней функции, в которой она определена. 
            */
            class Point {
              constructor(x, y) {
                this.x = x;
                this.y = y;
              }
              log() {
                console.log(this === myPoint);
                setTimeout(()=> {
                  console.log(this === myPoint);      // => true
                  console.log(this.x + ':' + this.y); // => '95:165'
                }, 1000);
              }
            }
            var myPoint = new Point(95, 165);
            myPoint.log();
            /*
            setTimeout вызывает стрелочную функцию в том же контексте (метод myPoint), что и метод log(). Как мы видим, стрелочная функция «наследует» контекст той функции, в которой определена.
            Если попробовать использовать в этом примере обычную функцию, она создаст свой контекст (window или undefined). Поэтому для того, чтобы код работал корректно, нужно вручную привязать контекст: setTimeout(function() {...}.bind(this)). Это громоздко, поэтому проще использовать стрелочную функцию.
            Если стрелочная функция определена вне всех функций, её контекст — глобальный объект. Стрелочная функция связывается с лексическим контекстом раз и навсегда. this нельзя изменить даже при помощи метод смены контекста:
            Ловушка: определение метода стрелочной функцией
              Вы можете захотеть использовать стрелочную функцию для объявления метода. Справедливо: их объявления гораздо короче по сравнению с обычным выражением: (param) => {...} вместо function(param) {..}.
              Так как format — стрелочная функция, определённая в глобальном контексте, её this — это объект window. Даже если format исполняется в качестве метода объекта walkPeriod.format(), window остаётся контекстом вызова. Так происходит, потому что стрелочная функция имеет статический контекст, не изменяемый другими типами вызовов.
              this — это window, поэтому this.hours и this.minutes становятся undefined. Метод возвращает строку 'undefined hours and undefined minutes', что не является желаемым результатом.
          Заключение 
            Поскольку вызов функции имеет наибольшее влияние на this, отныне не спрашивайте: Откуда берется this?  а спрашивайте: Как функция вызывается? А в случае со стрелочной функцией спросите: Каков this там, где объявлена стрелочная функция?
    ?Reference Type & losing this
    ?Understand difference between function and method
    ?Understand how this works, realize this possible issues
    ?Manage this scope
    ?Be able to replace this scope
    ?Be able to use call and apply Function built-in methods

  +Functional Patterns
    ?Immediately invoked functional expression (IIFE) (optional)
      IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.
        (function () {
        statements
        })();
        Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. 
        Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
        Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.
      Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.
      Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.
      */
      var result = (function () {
        var name = "Barry";
        return name;
      })();
      // Immediately creates the output:
      result; // "Barry"
      /*
    ?Know IIFE pattern (optional)
      Управлять областью видимости переменных в JavaScript можно, пользуясь паттерном «Модуль». Для того чтобы создать приватную область видимости, можно воспользоваться замыканием. Как известно, функции создают собственные области видимости, содержимое которых отделено от глобальной области видимости:
        (function () {
         // здесь находится приватная область видимости
        })();
        Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции (как, впрочем, и внутри других функций) создаётся приватная область видимости, недоступная извне. 
        То есть, если объявить внутри этой области видимости другую функцию, то, после того, как IIFE выполнится, доступ к ней получить не удастся.
      Как сделать так, чтобы к функции, объявленной внутри другой функции, всё же, можно было бы обратиться? Собственно говоря, то, о чём мы сейчас будем говорить, и есть паттерн «Модуль». Рассмотрим следующий пример.
      Объект, возвращаемый из IIFE — это обычный объект, у которого может быть множество методов и свойств. Они формируют общедоступный интерфейс или API модуля.
      */
      // Объявим модуль
      var Module = (function () {
        return {
          myMethod: function () {
          
          },
          someOtherMethod: function () {
          
          }
        };
      })();
      
      // Вызовем функцию как метод объекта
      Module.myMethod();
      Module.someOtherMethod();
      /*
    ?Callback (Function as argument)
      Фу́нкция вы́сшего поря́дка — в программировании функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. 
      Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных. Использование функций высшего порядка приводит к абстрактным и компактным программам, принимая во внимание сложность производимых ими вычислений.[1]
      Функции — это объекты
        Чтобы понимать callback-функции, нужно понимать обычные функции. Это может показаться банальностью, но функции в Javascript'е — немного странные штуки.
        Функции в Javascript'е — на самом деле объекты. А именно, объекты класса Function, создаваемые конструктором Function. В объекте Function содержится строка с JS-кодом данной функции. 
        Если вы перешли с языка C или Java, это может показаться странным (как код может быть строкой?!), но, вообще говоря, в Javascript'е такое сплошь и рядом. Различие между кодом и данными иногда размывается.
        Преимущество концепции «функция-как-объект» заключается в том, что код можно передавать в другую функцию точно так же, как обычную переменную или объект (потому что в буквальном понимании код — всего лишь объект).
        Вместо того чтобы дожидаться, пока функция закончит выполняться и вернёт значение, мы можем использовать callback-функции, чтобы получить его асинхронно. Это полезно для случаев, когда требуется много времени для завершения, например, при AJAX-запросах, ведь мы не можем приостановить браузер.
    ?Know callback pattern
    ?Understand callback limitations (callback hell) (optional)
      Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо ... у нас код, содержащий другие цепочки вызовов, условия и т.д. Иногда это называют «адом колбэков» или «адской пирамидой колбэков».
    ?Binding, binding one function twice
      bind returns a new function which keeps the context of the original function intact when called. In essence it does this:
      */
      function bind(originalFunction, context) {
        return function () {
            originalFunction.call(context);
        };
      }
      /*
    ?Know how to bind this scope to function
      */
    let user55 = {
      firstName: "Вася"
    };
    
    function func() {
      alert(this.firstName);
    }
    
    let funcUser = func.bind(user55);
    funcUser(); // Вася
    /*
    Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user. Все аргументы передаются исходному методу func как есть
    ?Carrying and partial functions
      Каррирование – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках. Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
        Каррирование не вызывает функцию. Оно просто трансформирует её.
        */
        function curry(fn) {
          return function rememberFirstArg(a) {
            return function rememberSecondArg(b) {
              return fn(a, b)
            }
          }
        }
        
        const curriedMultiply = curry(multiply)
        
        // multiply(2, 10)
        // curriedMultiply(2)(10)
        /*
        Как вы видите, реализация довольна проста: это две обёртки.
        Результат curry(func) – обёртка function(a).
        Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
        Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.
      Что такое каррирование? 
        Каррированная функция - это функция, которая может принимать несколько аргументов, но по одному за раз. Способность принимать по одному аргументу за раз, называется унарностью. Унарность, это обязательное свойство каррированных функций.
      Что такое частичное применение?
        Частичное применение - это функция, которая принимает за раз столько аргументов, сколько пожелает, но не все. Все каррированные функции возвращают частичное применение, для хранения введенных аргументов.
        */
        const add = x => y => x + y;
        const inc10 = add(10);
        const inc20 = add(20);

        inc10(3); // => 13
        inc20(3); // => 23
        /*
  +Network requests
    ?Fetch (with usage)
      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
        По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера
        Типичный запрос с помощью fetch состоит из двух операторов await:
          */
        let response = await fetch(url, options); // завершается с заголовками ответа
        let result = await response.json(); // читать тело ответа в формате JSON
        /*
        Или, без await:
        */
        fetch(url, options)
          .then(response => response.json())
          .then(result => {/* обрабатываем результат */});
        /*
        Параметры ответа:
          response.status – HTTP-код ответа,
          response.ok – true, если статус ответа в диапазоне 200-299.
          response.headers – похожий на Map объект с HTTP-заголовками.
        Методы для получения тела ответа:
          response.text() – возвращает ответ как обычный текст,
          response.json() – преобразовывает ответ в JSON-объект,
          response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
          response.blob() – возвращает объект как Blob (бинарные данные с типом),
          response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
        Опции fetch, которые мы изучили на данный момент:
          method – HTTP-метод,
          headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
          body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
    ?XMLHTTPRequest (concept) (optional)
      XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
      В современной веб-разработке XMLHttpRequest используется по трём причинам:
        -По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.
        -Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).
        -Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.
      Типичный код GET-запроса с использованием XMLHttpRequest:
      */
      let xhr = new XMLHttpRequest();

      xhr.open('GET', '/my/url');
      
      xhr.send();
      
      xhr.onload = function() {
        if (xhr.status != 200) { // HTTP ошибка?
          // обработаем ошибку
          alert( 'Ошибка: ' + xhr.status);
          return;
        }
      
        // получим ответ из xhr.response
      };
      
      xhr.onprogress = function(event) {
        // выведем прогресс
        alert(`Загружено ${event.loaded} из ${event.total}`);
      };
      
      xhr.onerror = function() {
        // обработаем ошибку, не связанную с HTTP (например, нет соединения)
      };
      /*
    ?WebSocket (concept) (optional)
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. 
        Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
      WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws: let socket = new WebSocket("ws://javascript.info");
      WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.
        -Нет ограничений, связанных с кросс-доменными запросами.
        -Имеют хорошую поддержку браузерами.
        -Могут отправлять/получать как строки, так и бинарные данные.
      
  +Web components
    ?Web components, shadow DOM (concept) (optional)
      Веб-компоненты
        Веб-компоненты - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях.
        Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
        Модель веб-компонентов подразумевает инкапсуляцию и совместимость отдельных HTML-элементов.
        На данный момент частичная поддержка существует в браузерах Chrome, Firefox, Opera и Safari. Для браузеров не поддерживающих веб-компоненты реализованы полифилы.
          -Веб-компоненты включают три технологии, каждая из которых может использоваться отдельно от других:
          -Custom Elements — API для создания собственных HTML элементов.
          -HTML Templates — тег <template> позволяет реализовывать изолированные DOM-элементы.
          -Shadow DOM — изолирует DOM и стили в разных элементах.
  
  +Date & time
    ?Timezones (optional)
      Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после "get" вставляется "UTC".
      Если ваше локальное время сдвинуто относительно UTC, то следующий код покажет разные часы:
        // текущая дата
        var date = new Date();
        // час в текущей временной зоне
        alert( date.getHours() );
        // сколько сейчас времени в Лондоне?
        // час в зоне GMT+0
        alert( date.getUTCHours() );
      Кроме описанных выше, существуют два специальных метода без UTC-варианта:
        getTimezoneOffset()
        Возвращает разницу между местным и UTC-временем, в минутах.
        alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60
    ?Internationalization js (Intl) (optional)
      Общая проблема строк, дат, чисел в JavaScript – они «не в курсе» языка и особенностей стран, где находится посетитель.
        Строки
          При сравнении сравниваются коды символов, а это неправильно, к примеру, в русском языке оказывается, что "ё" > "я" и "а" > "Я", хотя всем известно, что я – последняя буква алфавита и это она должна быть больше любой другой.
        Даты
          В разных странах принята разная запись дат. Где-то пишут 31.12.2014 (Россия), а где-то 12/31/2014 (США), где-то иначе.
        Числа
          В одних странах выводятся цифрами, в других – иероглифами, длинные числа разделяются где-то пробелом, где-то запятой.
        Все современные браузеры, кроме IE10 (но есть библиотеки и для него) поддерживают стандарт ECMA 402, предназначенный решить эти проблемы навсегда.
      Основные объекты
        Intl.Collator - Умеет правильно сравнивать и сортировать строки.
        Intl.DateTimeFormat - Умеет форматировать дату и время в соответствии с нужным языком.
        Intl.NumberFormat - Умеет форматировать числа в соответствии с нужным языком.
      Локаль
        Локаль – первый и самый важный аргумент всех методов, связанных с интернационализацией. Локаль описывается строкой из трёх компонентов, которые разделяются дефисом:
          -Код языка.
          -Код способа записи.
          -Код страны.
        Все методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения. Если локаль не указана или undefined – берётся локаль по умолчанию, установленная в окружении (браузере).
  +Closures Advanced
    https://learn.javascript.ru/closure#leksicheskoe-okruzhenie
    ?Context (lexical environment)
    «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую
          */
          function makeWorker() {
            let name = "Pete";
          
            return function() {
              alert(name);
            };
          }
          
          let name = "John";
          
          // create a function
          let work = makeWorker();
          
          // call it
          work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)
          /*
          Лексическое Окружение
            Чтобы понять, что происходит, давайте для начала обсудим, что такое «переменная» на самом деле.
            В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
            Объект лексического окружения состоит из двух частей:
              -Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
              -Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
            "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».
          Один вызов – одно лексическое окружение 
            Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. 
            И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
    ?Understand function creation context (lexical environment)
      Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.  это то, каким образом функции знают, где они были созданы.
    ?Be able to explain difference between scope and context
      Scope – область видимости. Область видимости определяет, есть ли у вас доступ к переменной. До введения let и const область видимости в JavaScript определялась функцией (у var функциональная область видимости). Переменные объявленные вне функции записывались в глобальную область видимости.
      Context – контекст выполнения (this) Контекст описывает окружение в котором выполняется код (любой код имеет контекст выполнения). В каждый момент времени только один контекст выполнения выполняет код. Несколько популярных видов контекста:
        -Global контекст 
        -Function контекст
        -Стрелочные функции
        -В методе объекта
        -В конструкторе
        -В методах call, apply и bind
        В браузере:
        -Как обработчик событий DOM 
        -В инлайновом обработчике событий
      Одна и та же функция может быть вызвана с разным контекстом. Контекстом еще часто называют значение переменной this внутри функции.  Значение переменной this чаще всего определяется тем, как вызывается функция. 
    ?Inner/outer lexical environment
      У внутреннего лексического окружения есть ссылка outer на внешнее. Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального. 
      Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
    ?Understand lexical environment traversing mechanism
    ?Understand connection between function and lexical environment

  +Object Oriented Programming
    ?new keyword
      Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее. Это можно сделать при помощи функции-конструктора и оператора "new".
    ?Understand how new keyword works
    ?Function constructor
      Функция-конструктор
        Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
          -Имя функции-конструктора должно начинаться с большой буквы.
          -Функция-конструктор должна выполняться только с помощью оператора "new".
      Когда функция вызывается как new User(...), происходит следующее: 
        1. Создаётся новый пустой объект, и он присваивается this.
        2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
        3. Возвращается значение this.
    ?Know function constructor concept
    ?Able to create constructor functions
    */
    function User(name) {
      // this = {};  (неявно)
    
      // добавляет свойства к this
      this.name = name;
      this.isAdmin = false;
    
      // return this;  (неявно)
    }
    /*
    Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.
    ?Public, private, static members
      Публичные поля классов
        Публичные поля классов предназначены для задания свойств экземпляра объекта и статических свойств изнутри тела класса.
        И статические, и публичные поля являются изменяемыми, перечисляемыми, настраиваемыми свойствами. Таким образом, в отличие от приватных полей, они участвуют в прототипном наследовании.
        Новый синтаксис для публичных полей позволяет упростить определение класса:
        */
       // classic instance property
        class MyClass {
          constructor() {
            this.counter = 0;
          }
        }
        // public field
        class MyClass {
          counter = 0;
        }
        // ------------------------
        class IncreasingCounter {
          _count = 0;
          get value() {
            console.log('Getting the current value!');
            return this._count;
          }
          increment() {
            this._count++;
          }
        }
        /*
        Свойство _count теперь лаконично объявлено в начале класса. Нам больше не нужен конструктор только для того, чтобы определить некоторые поля. Отлично!
        Тем не менее, _count — все еще публичное свойство. А в этом конкретном примере мы хотим предотвратить обращение к этому полю напрямую.
      Приватные поля классов
        Именно здесь на помощь приходят приватные поля. Новый синтаксис для приватных полей схож с синтаксисом публичных полей, за исключением того, что Вы помечаете их как приватные, используя символ #. Вы можете думать, что # — это просто часть имени поля:
        */
        class IncreasingCounter {
          #count = 0;
          get value() {
            console.log('Getting the current value!');
            return this.#count;
          }
          increment() {
            this.#count++;
          }
        }
        // Приватные поля недоступны вне тела класса:
        const counter = new IncreasingCounter();
        counter.#count;
        // → SyntaxError
        counter.#count = 42;
        // → SyntaxError
        /*
      Статические свойства
        Синтаксис полей классов может быть использован для создания публичных и приватных статических свойств и методов, как показано ниже:
        Статические методы и свойства класса доступны только внутри самого класса, но не в его экземплярах.
        */
        class FakeMath {
          // `PI` is a static public property.
          static PI = 22 / 7; // Close enough.
        
          // `#totallyRandomNumber` is a static private property.
          static #totallyRandomNumber = 4;
        
          // `#computeRandomNumber` is a static private method.
          static #computeRandomNumber() {
            return FakeMath.#totallyRandomNumber;
          }
        
          // `random` is a static public method (ES2015 syntax)
          // that consumes `#computeRandomNumber`.
          static random() {
            console.log('I heard you like random numbers…')
            return FakeMath.#computeRandomNumber();
          }
        }
        
        FakeMath.PI;
        // → 3.142857142857143
        FakeMath.random();
        // logs 'I heard you like random numbers…'
        // → 4
        //FakeMath.#totallyRandomNumber;
        // → SyntaxError
        //FakeMath.#computeRandomNumber();
        // → SyntaxError
        /*
    ?Know how to create public members
    ?Know how to create private members
    ?Know how to create static members
    ?Understand OOP emulation patterns and conventions

  +Prototypal Inheritance Basics
    ?__proto__ property
      __proto__ это ссылка на прототип функции конструктора который ее создал!!!!
      а prototype есть только у функции или class в момент объявления!!!!!
      __proto__ устанавливает prototype либо явно rabbit.__proto__ = animal; но нельзя. Либо при new Object() или Object.create(null)
      XXX.__proto__ есть у всех объектов и почти всегда это объект Object.prototype 
      Разные по типу объекты могут иметь разные __proto__. а одинаковые объекты могут иметь одинаковый __proto__. 
        let obj = {};
        let obj2 = {};
        obj.__proto__ === obj2.__proto__; // true

        let users =[];
        let users2 =[];
        users.__proto__ === users2.__proto__; // true

        let age = 18;
        let age2 = 18;
        age.__proto__ === age2.__proto__; // true

        function someFunc() {};
        let someFunc2 = function() {};
        let someFunc3 = () => {};
        class someClass {};
        и эти __proto__ равны.

        Любой объект в JS создается с помощью class или function
    ?Understand __proto__ object property
    ?Able to use [Object.create] and define __proto__ explicitly
      let clone = Object.create(Object.getPrototypeOf(rabbit), Object.getOwnPropertyDescriptors(rabbit)); //  клон obj c тем же прототипом (с поверхностным копированием свойств)
      let clear = Object.create(null); чистый объект без прототипа (словари)

      let promise = new Promise(() => {}); // создается явно

        let man = {} // new Object(...) за кадром создается так
        let users = [] // new Array(...) за кадром создается так
        let age = 18; // когда обращаемся через точку временно создается new Number(...)
        let youtube = "youtube"; // когда обращаемся через точку временно создается new String(...)
        function someFunc() {}; // за кадром создается так new Function(...)
        let someFunc2 = function() {}; // за кадром создается так new Function(...)
        let someFunc3 = () => {}; // за кадром создается так new Function(...)
        class someClass {}; // за кадром создается так new Function(...)

        let channel = new someClass() // когда с помощью класса создается объект мы его создаем явно!

        let areYouOkAfterThat = "true"; // только если обращаемся как к объекту то временно создается new Boolean(...)

        1. Любой объект создается с помощъю функции конструктора либо же класса и у него есть свойство __proto__
        2. Что бы понимать, что за __proto__, нужно ТОЧНО знать с помощью какой функции-конструктора (класса) создан данный объект. За кадром или явно
        class SomeClass {}
        function SomeFunc() {} // с большой буквы и стрелочная функция не может быть конструктором
        const API = function() {} // главное ключевое слово function
        Object, Promise, Function, Boolean, Number, String, Array, Date, RegExp, Error, Symbol, Map, Set, WeakMap, WeakSet, Proxy, etc

        И у любого объекта который одновременно является классом или функцией с помощю function есть свойство prototype Каждый prototype - это независимый объект, сам по себе с определенным набором свойств и методов.
        И соответственно console.log(Object.prototype) не будет равен console.log(Promise.prototype)
        __proto__ -  у любого объекта (равно прототипу того класса с помощью которого он был создан)                              prototype - у class либо function
        __proto__ любого объекта всегда ссылается на prototype класса(функции-конструктора), с помощью которой этот объект был создан!
        Пример: let man = {} man.__proto__ === Object.prototype

        ЗАЧЕМ КЛАССУ НУЖЕН ОБЪЕКТ prototype?
        И зачем объектам созданным с помощъю этого класса, св-во __proto__, которое ссылается на этот объект prototype
        Если мы пытаемся прочитать свойство объекта, либо вызвать его метод, а его нет, то объект полезет искать его через ссылку __proto__ в prototype класса, с помощью которого он был создан.
        class это просто синаксический сахар над function SomeFunc
    ?Able to set / get object prototype (optional)
      example: Object.setPrototypeOf(obj, prototype)
      example: Object.getPrototypeOf(obj)
    ?prototype property
    ?Know function prototype property
    ?Understand dependency between function constructor prototype and instance __proto__
    ?Able to create 'class' methods using function prototype property
      */
      // constructor function
      function MyClass () {
        var privateVariable; // private member only available within the constructor fn
      
        this.privilegedMethod = function () { // it can access private members
          //..
        };
      }
      
      // A 'static method', it's just like a normal function 
      // it has no relation with any 'MyClass' object instance
      MyClass.staticMethod = function () {};
      
      MyClass.prototype.publicMethod = function () {
        // the 'this' keyword refers to the object instance
        // you can access only 'privileged' and 'public' members
      };
      
      var myObj = new MyClass(); // new object instance
      
      myObj.publicMethod();
      MyClass.staticMethod();
    /*

  +ECMAScript Classes
    ?Class declaration
      Базовый синтаксис для классов выглядит так:
      */
      class MyClass {
        prop = value; // публичное поле
        constructor(...) { // конструктор
          // ...
        }
        method(...) {} // метод
        get something(...) {} // геттер
        set something(...) {} // сеттер
        [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
        // ...
      }
      /*
      MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.
    ?Know class declaration syntax
    ?Understand difference between class and constructor function
      1. Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.
        В отличие от обычных функций, конструктор класса не может быть вызван без new: //  Error: Class constructor User cannot be invoked without 'new'
      2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype". И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.
      3. Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

      -Разница между объявлением функции (function declaration) и объявлением класса (class declaration) в том, что объявление функции 
        совершает подъём (hoisted), в то время как объявление класса — нет. Поэтому вначале необходимо объявить ваш класс и только затем работать с ним. (Источник: Classes)
      -Классы имеют специальный конструктор ключевых слов - может быть только один из них, или выдается ошибка. Функции могут иметь несколько определений переменной функции с именем "конструктор"
    ?Getter/setter
      Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.
      При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
      */
      Object.defineProperties(User.prototype, {
        name: {
          get() {
            return this._name
          },
          set(name) {
            // ...
          }
        }
      });
      /*
    ?What does super() do and where we have to use it?
      в классах-потомках конструктор обязан вызывать super(...), и (!) делать это перед использованием this.
      В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:"derived".
      Разница в следующем:
        -Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
        -Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
        Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.

  +ECMAScript Data Types & Expressions
    ?Object keys/values
    ?Object calculated props
      let user = new Object(); // синтаксис "конструктор объекта" let user = {};  // синтаксис "литерал объекта" 
    Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
      Они хранят свойства (пары ключ-значение), где:
        -Ключи свойств должны быть строками или символами (обычно строками).
        -Значения могут быть любого типа.
      Чтобы получить доступ к свойству, мы можем использовать:
        -Запись через точку: obj.property.
        -Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
      Дополнительные операторы:
        -Удаление свойства: delete obj.prop.
        -Проверка существования свойства: "key" in obj. Если вы хотите рассматривать только свойства самого объекта, а не его прототипов, используйте getOwnPropertyNames(), hasOwnProperty() или propertyIsEnumerable. if( obj.hasOwnProperty( prop ) ) { ... }
        -Перебор свойств объекта: цикл for for (let key in obj).
    Упорядочение свойств объекта - Если мы будем в цикле перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать? 
      Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
    ?Set/Map data types
      Map – коллекция пар ключ-значение.
        в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.
        Хотя map[key] также работает, например, мы можем установить map[key] = 2, в этом случаеmap рассматривался бы как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).
        Map может использовать объекты в качестве ключей.
        Использование объектов в качестве ключей – одна из наиболее заметных и важных функций Map. Это то что невозможно для Object.
        Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку: map.set('1', 'str1').set(1, 'num1').set(true, 'bool1');
        Методы и свойства:
          -new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
          -map.set(key, value) – записывает по ключу key значение value.
          -map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
          -map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
          -map.delete(key) – удаляет элемент по ключу key.
          -map.clear() – очищает коллекцию от всех элементов.
          -map.size – возвращает текущее количество элементов.
          -Отличия от обычного объекта Object:
            Что угодно может быть ключом, в том числе и объекты.
            Есть дополнительные методы, свойство size.
      Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
        let set = new Set(["апельсин", "яблоко", "банан"]); for (let value of set) alert(value);
        Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.
        Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.
        Методы и свойства:
          -new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
          -set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
          -set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
          -set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
          -set.clear() – удаляет все имеющиеся значения.
          -set.size – возвращает количество элементов в множестве.
          -Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
    ?WeakSet/WeakMap data types
      Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор, пока эта структура данных содержится в памяти.
      Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок на него нет.
      -WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
        Есть только методы get, set, delete и has. Если сборщик мусора удалил объект, то и значения, связанные с ним, автоматически удаляются из WeakMap. 
        Например, если мы используем объект в качестве ключа, то как только он становится недостижимым, он будет удалён из памяти (и из WeakMap) автоматически.
      -WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.
      -Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.
      -WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

  +JavaScript Errors
    ?try..catch statement
      Конструкция try..catch позволяет обрабатывать ошибки во время исполнения кода. Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.
      Синтаксис:
      */
      try {
        // исполняем код
      } catch(err) {
        // если случилась ошибка, прыгаем сюда
        // err - это объект ошибки
      } finally {
        // выполняется всегда после try/catch
      }
      /*
      Секций catch или finally может не быть, то есть более короткие конструкции try..catch и try..finally также корректны.
      Объекты ошибок содержат следующие свойства:
        -message – понятное человеку сообщение.
        -name – строка с именем ошибки (имя конструктора ошибки).
        -stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.
      Если объект ошибки не нужен, мы можем пропустить его, используя catch { вместо catch(err) {.
      Мы можем также генерировать собственные ошибки, используя оператор throw. Аргументом throw может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса Error.
      Проброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.
      Даже если у нас нет try..catch, большинство сред позволяют настроить «глобальный» обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.
    ?Know how to handle errors
    ?Custom errors (optional)
      Оператор throw генерирует ошибку. throw <объект ошибки>
        Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).
        В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.
        let error = new Error(message);
        // или
        let error = new SyntaxError(message);
        let error = new ReferenceError(message);
        // ...
  +ECMAScript Advanced
    ?Garbage collector (concept) (optional)
      Главное, что нужно знать:
        -Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
        -Объекты сохраняются в памяти, пока они достижимы.
        -Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.
    ?Promises
      -Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и колбэки.
      -При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.
      -Аргумент resolve/reject (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.
      -Обработчики назначаются вызовом .then/catch.
      -Для передачи результата от одного обработчика к другому используется чейнинг.
        Синтаксис
          new Promise(executor);
          new Promise(function(resolve, reject) { ... });
            executor
              Объект функции с двумя аргументами resolve и reject. Функция executor получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект.
              Первый аргумент (resolve) вызывает успешное исполнение промиса, второй (reject) отклоняет его.
              Обычно функция executor описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию resolve или reject. Обратите внимание, что возвращаемое значение функции executor игнорируется.
        Promise может находиться в трёх состояниях:
          -ожидание (pending): начальное состояние, не исполнен и не отклонён.
          -исполнено (fulfilled): операция завершена успешно.
          -отклонено (rejected): операция завершена с ошибкой.
        Так как методы Promise.prototype.then() и Promise.prototype.catch() сами возвращают промис, их можно вызывать цепочкой, создавая соединения.
          Примечание: говорят, что промис находится в состоянии завершён (settled) когда он или исполнен или отклонён, т.е. в любом состоянии, кроме ожидания (это лишь форма речи, не являющаяся настоящим состоянием промиса).
        Свойства
          Promise.length Значение свойства всегда равно 1 (количество аргументов конструктора).
        Методы
          -Promise.all(iterable) Ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.
          -Promise.allSettled(iterable)  Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.
          -Promise.race(iterable) Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable.
          -Promise.reject(reason) Возвращает промис, отклонённый из-за reason.
          -Promise.resolve(value) Возвращает промис, исполненный с результатом value.
        Создание промиса
          Объект Promise создаётся при помощи ключевого слова new и своего конструктора. Конструктор Promise принимает в качестве аргумента функцию, называемую "исполнитель" (executor function). Эта функция должна принимать две функции-колбэка в качестве параметров. 
            Первый из них (resolve) вызывается, когда асинхронная операция завершилась успешно и вернула результат своего исполнения в виде значения. Второй колбэк (reject) вызывается, когда операция не удалась, и возвращает значение, указывающее на причину неудачи, чаще всего объект ошибки.
            */
            const myFirstPromise = new Promise((resolve, reject) => {
              // выполняется асинхронная операция, которая в итоге вызовет:
              //
              //   resolve(someValue); // успешное завершение
              // или
              //   reject("failure reason"); // неудача
            });
            /*
            Чтобы снабдить функцию функциональностью промисов, нужно просто вернуть в ней объект Promise:
    ?Promise states
    ?Promise Chaining
      Цепочки промисов
        «Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.
        Например, мы хотим по очереди:
          -Загрузить данные посетителя с сервера (асинхронно).
          -Затем отправить запрос о нём на github (асинхронно).
          -Когда это будет готово, вывести его github-аватар на экран (асинхронно).
          -…И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
        При чейнинге, то есть последовательных вызовах .then…then…then, в каждый следующий then переходит результат от предыдущего.
        Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
        То есть, логика довольно проста:
          В каждом then мы получаем текущий результат работы.
          Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.
    ?Promise static methods
    ?Be able to compare promise and callback patterns (optional)
    ?Be able to handle errors in promises
      Перехват ошибок
        При возникновении ошибки – она отправляется в ближайший обработчик onRejected.
        Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец нашей цепочки:
        .catch(error => {
          alert(error); // Error: Not Found
        });
      Обработчик .catch(onRejected) получает ошибку и должен обработать её.
        Есть два варианта развития событий:
          1. Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).
          2. Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).
      Это также похоже на обычный try..catch – в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. 
        Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не «вываливается» в консоль и не «убивает» скрипт.
    ?event loop
      «Как JavaScript может быть асинхронным и однопоточным?» Если кратко, то JavaScript однопоточный, а асинхронное поведение не является частью самого языка; вместо этого оно построено на основе него в браузере (или среде программирования) и доступно через браузерные API.
        Макро-задачи и микро-задачи
          И микрозадачи, и макрозадачи являются асинхронными задачами, но они будут входить в две разные асинхронные очереди, и приоритет очереди микрозадач выше приоритета макрозадачи.
            -Макрозадача (setTimeout, setInterval, setImmediate, requestAnimationFrame)
            -Микрозадача (Promise.then, Promise.catch, Promise.finally, process.nextTick)
          Код JavaScript делится на синхронный код и асинхронный код, а асинхронный код делится на макро-задачи и микро-задачи. Макро-задачи и микро-задачи - это две разные асинхронные очереди, и приоритет микро-задач выше, чем у макро-задач.
        -Stack (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода. Вызовы функций помещаются в стек (об этом ниже).
        -Heap (куча) — объекты собраны в кучу, которая есть ни что иное, как название для наименее структурированной части памяти.
    ?async/await
    Существует специальный синтаксис для работы с промисами, который называется «async/await».
      Ключевое слово async перед объявлением функции:
        -Обязывает её всегда возвращать промис.
        -Позволяет использовать await в теле этой функции.
      Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:
        -Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
        -Иначе вернётся результат промиса.
      Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.
      Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). 
        Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.
!JavaScript in Browser:

  +Global object window
    ?Location
      Window.location - !Свойство (про location)! только для чтения Window.location возвращает объект Location с информацией о текущем расположении документа.
      Хотя Window.location представляет собой объект только для чтения Location, вы можете присвоить ему DOMString. Это значит что в большинстве случаев вы можете работать с location как со строкой: location = 'http://www.example.com' это синоним для location.href = 'http://www.example.com'.
      Объект window.location можно использовать для получения адреса текущей страницы (URL) и для перенаправления браузера на новую страницу.
      Свойства
        -window.location.href содержащий URL целиком. При изменении, соответствующий документ переходит на новую страницу.
        -window.location.hostname возвращает доменное имя веб хостинга
        -window.location.pathname возвращает путь и имя файла текущей страницы
        -window.location.protocol возвращает используемый веб протокол (http: или https:)
        -window.location.port содержащий номер порта текущего URL.
        -window.location.search содержащий '?' с последующими параметрами URL.
      Методы 
        -window.location.reload() Перезагружает ресурс по текущему URL. Единственный опциональный параметр Boolean (en-US) при значении true указывает, что страница должна быть заново загружена с сервера, при значении false страница может быть загружена из кеша.
        -window.location.replace() Заменяет текущий ресурс на новый по URL, указанному в качестве параметра. Отличие от assign() в том, что при использовании replace() текущая страница не будет сохранена в History, и пользователь не сможет использовать кнопку назад, чтобы вернуться к ней.
        -window.location.assign() Загружает ресурс по URL, указанному в качестве параметра.
    ?Know browser location structure
    ?History API (Global object window)
      DOM-объект Window предоставляет доступ к истории текущей сессии браузера (не путать с историей браузерных расширений) через объект history. Он предоставляет полезные методы и свойства, которые позволяют переходить назад и вперёд по истории пользователя и манипулировать её содержимым.
      Основные методы объекта History:
        -window.history.length: Количество записей в текущей сессии истории
        -window.history.state: Возвращает текущий объект истории
        -window.history.go(n): Метод, позволяющий гулять по истории. В качестве аргумента передается смещение, относительно текущей позиции. Если передан 0, то будет обновлена текущая страница. Если индекс выходит за пределы истории, то ничего не произойдет.
        -window.history.back(): Метод, идентичный вызову go(-1)
        -window.history.forward(): Метод, идентичный вызову go(1)
        -window.history.pushState(data, title [, url]): Добавляет элемент истории.
        -window.history.replaceState(data, title [, url]): Обновляет текущий элемент истории
    ?Know browser History APIconcept
    ?Be able to navigate within browser history
    ?Be able to use history state (optional)
    ?Navigator (optional)
      Объект navigator предназначен для предоставления подробной информации о браузере, который пользователь использует для доступа к сайту или веб-приложению. Кроме данных о браузере, в нём ещё содержится сведения о операционной системе, сетевом соединении и др.
        const navigatorObj = window.navigator;
          Объект navigator имеет свойства и методы. Очень часто они используется для того чтобы узнать, какие функции поддерживаются браузером, а какие нет.
            Свойства объекта navigator:
              -appCodeName – кодовое имя браузера;
              -appName – имя браузера;
              -appVersion — версия браузера;
              -cookieEnabled - позволяет определить включены ли cookie в браузере;
              -geolocation - используется для определения местоположения пользователя;
              -language - язык браузера;
              -online - имеет значение true или false в зависимости от того находиться ли браузер в сети или нет;
              -platform - название платформы, для которой скомпилирован браузер;
              -product - имя движка браузера;
              -userAgent - возвращает заголовок user agent, который браузер посылает на сервер.
            Методы объекта navigator:
              -javaEnabled – позволяет узнать, включён ли в браузере Java;
              -sendBeacon - предназначен для отправки небольшого количества информации на веб-сервер без ожидания ответа.
    ?Know how to parse user agent (optional)
      Обнаружение браузера с помощью userAgent
        userAgent - это строка, содержащая информацию о браузере, которую он посылает в составе заголовка запроса на сервер.
        Пример содержания строки userAgent в браузере Google Chrome:
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36"
          Эти данные можно использовать, например, для обнаружения браузера.
            if (navigator.userAgent.indexOf('Chrome') !== -1 ) {}
    ?Know how to discover client platform, browser
    ?Cookies
      document.cookie предоставляет доступ к куки.
        -Операция записи изменяет только то куки, которое было указано.
        -Имя и значение куки должны быть закодированы.
        -Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).
      Настройки куки:
        -path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
        -domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
        -expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
        -secure делает куки доступным только при использовании HTTPS.
        -samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.
      Дополнительно:
        -Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
        -Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.

  +Page Lifecycle
    Навигация
      Навигация - это первый этап при загрузке приложения. Он происходит каждый раз, когда пользователь запрашивает страницу, вводя URL в адресную строку браузера, нажимает на ссылку, отправляет заполненные поля формы и выполняет некоторые другие действия.
    DNS запрос
      Первый шаг навигации к странице - это поиск места, откуда нужно запрашивать данные. Если вы переходите на https://example.com, браузер грузит HTML-код страницы с IP-адреса 93.184.216.34. Если вы никогда ранее не были на этом сайте, произойдёт поиск DNS записи.
    TCP Рукопожатие (Handshake)
      В тот момент, когда IP адрес становится известен, браузер начинает установку соединения к серверу с помощью рукопожатия TCP three-way handshake (en-US). Этот механизм спроектирован так, чтобы два устройства, пытающиеся установить связь, могли обменяться параметрами соединения, прежде чем приступать к передаче данных. Чаще всего - через защищённое соединение HTTPS.
    TLS Переговоры (Negotiation)
      Для установки безопасных соединений с использованием HTTPS требуется ещё одно рукопожатие. На этот раз - TLS переговоры. На этом шаге определяется, какой шифр будет использоваться для шифрования соединения, удостоверяется надёжность сервера и устанавливается безопасное соединение. 
        Этот шаг также требует несколько дополнительных сообщений, которыми должны обменяться сервер и браузер, прежде чем данные будут посланы.
    Ответ на запрос
      Как только мы установили соединение с веб-сервером, браузер отправляет инициирующий HTTP GET запрос от имени пользователя. Чаще всего запрашивается HTML файл. В момент, когда сервер получает запрос, он начинает ответ с посылки заголовков ответа и содержимым HTML-файла.
      Этот ответ содержит в себе первый байт полученных данных. Время до первого байта (Time to First Byte, TTFB) - это время между моментом когда пользователь отправил запрос, скажем, нажав на ссылку, и моментом получения первого пакета данных HTML. Первый пакет обычно содержит 14КБ данных.
    TCP медленный старт / правило 14kb
      Объём первого пакета данных - всегда 14KB. Это часть спецификации TCP slow start (en-US) - алгоритма, который балансирует скорость соединения. Такое правило позволяет постепенно, по мере необходимости, увеличивать размеры передаваемых данных, пока не будет определена максимальная ширина канала.
        В алгоритме TCP slow start (en-US) каждый следующий отправленный сервером пакет увеличивается в размере в два раза.
    Парсинг
      Как только браузер получает первый кусочек данных, он сразу начинает обрабатывать получаемую информацию. Эта обработка называется "Парсинг" (Parsing). Во время парсинга получаемые данные преобразуются в DOM и CSSOM (en-US), которые напрямую участвуют в отрисовке.
    ?Parsing
      Из полученного от сервера HTML-документа формируется DOM (Document Object Model).
        1.Загружаются и распознаются стили, формируется CSSOM (CSS Object Model).
        2. На основе DOM и CSSOM формируется дерево рендеринга, или render tree — набор объектов рендеринга (Webkit использует термин «renderer», или «render object», а Gecko — «frame»). Render tree дублирует структуру DOM, но сюда не попадают невидимые 
          элементы (например — <head>, или элементы со стилем display:none;). Также, каждая строка текста представлена в дереве рендеринга как отдельный renderer. Каждый объект рендеринга содержит соответствующий ему объект DOM (или блок текста), и 
          рассчитанный для этого объекта стиль. Проще говоря, render tree описывает визуальное представление DOM.
        3. Для каждого элемента render tree рассчитывается положение на странице — происходит layout. Браузеры используют поточный метод (flow), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов 
          требуется больше).
        4. Наконец, происходит отрисовка всего этого добра в браузере — painting.
        В процессе взаимодействия пользователя со страницей, а также выполнения скриптов, она меняется, что требует повторного выполнения некоторых из вышеперечисленных операций.
    ?Reflow
      Если же изменения затрагивают содержимое, структуру документа, положение элементов — происходит reflow (или relayout). Причинами таких изменений обычно являются:
        -Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
        -Изменение содержимого, в т.ч. текста в полях форм;
        -Расчёт или изменение CSS-свойств;
        -Добавление, удаление таблиц стилей;
        -Манипуляции с атрибутом «class»;
        -Манипуляции с окном браузера — изменения размеров, прокрутка;
        -Активация псевдо-классов (например, :hover).
    ?Repaint
      Repaint
        В случае изменения стилей элемента, не влияющих на его размеры и положение на странице (например, background-color, border-color, visibility), браузер просто отрисовывает его заново, с учётом нового стиля — происходит repaint (или restyle).

  +Events Basics
    ?Be able to explain difference between capturing and bubbling
      Стандарт DOM Events описывает 3 фазы прохода события:
        -Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
        -Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
        -Фаза всплытия (bubbling stage) – событие начинает всплывать.
      Всплытие:
        Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
        Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:
        Клик по внутреннему <p> вызовет обработчик onclick:
          1. Сначала на самом <p>.
          2. Потом на внешнем <div>.
          3. Затем на внешнем <form>.
          4. И так далее вверх по цепочке до самого document.
        При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).
          -Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
          -Далее обработчики вызываются на целевом элементе.
          -Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.
        Каждый обработчик имеет доступ к свойствам события event:
          -event.target – самый глубокий элемент, на котором произошло событие.
          -event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
          -event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
        Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
        В разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.
        Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий.
    ?Know Event concept
      Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).
      События мыши:
        -click – клик по кнопке мыши.
        -contextmenu – клик правой кнопкой мыши.
        -dblclick – двойной клик по кнопке мыши.
        -mouseover / mouseout – когда мышь наводится на / покидает элемент.
        -mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
      События на элементах управления:
        -submit – пользователь отправил форму <form>.
        -focus – пользователь фокусируется на элементе, например нажимает на <input>.
      Клавиатурные события:
        -keydown и keyup – когда пользователь нажимает / отпускает клавишу.
      События документа:
        -DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
      CSS events:
        transitionend – когда CSS-анимация завершена.
    Обработчики событий:
      Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
    Есть три способа назначения обработчиков событий:
      1. Атрибут HTML: onclick="...".
      2. Свойство объекта: elem.onclick = function() {...}.
      3. Метод объекта: elem.addEventListener("click", function() {...}).
      Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.
      Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.
    ?Custom events (optional)
      Генерация пользовательских событий
        Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как click, mousedown и другие. Это бывает полезно для автоматического тестирования.
      Конструктор Event
        Событие встроенного класса Event можно создать так: let event = new Event(type[, options]);
          -type – тип события, строка, например "click" или же любой придуманный нами – "my-event".
          -options – объект с тремя необязательными свойствами:
            -bubbles: true/false – если true, тогда событие всплывает.
            -cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
            -composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.
            По умолчанию все три свойства установлены в false: {bubbles: false, cancelable: false, composed: false}.
      Метод dispatchEvent
        После того, как объект события создан, мы должны запустить его на элементе, вызвав метод elem.dispatchEvent(event). Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг bubbles, то оно будет всплывать.
  +Events Propagation / Preventing
    ?Know Event propagation cycle
    ?Know how to stop Event propagation
      Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
      В разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.
    ?Know how to prevent Event default browser behavior
      Действий браузера по умолчанию достаточно много:
        -mousedown – начинает выделять текст (если двигать мышкой).
        -click на <input type="checkbox"> – ставит или убирает галочку в input.
        -submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
        -keydown – при нажатии клавиши в поле ввода появляется символ.
        -contextmenu – при правом клике показывается контекстное меню браузера.
      Отмена действия браузера
        -Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault(). <a href="/" onclick="event.preventDefault()">здесь</a>
        -Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика. <a href="/" onclick="return false">Нажми здесь</a>
    ?Delegating
      Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.
      Алгоритм делегирования событий:
        -Вешаем обработчик на контейнер.
        -В обработчике проверяем исходный элемент event.target.
        -Если событие произошло внутри нужного нам элемента, то обрабатываем его.
        Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
        Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
        Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
    ?Understand Event delegating concept
    ?Understand Event delegating benefits and drawbacks

  +Timers
    ?clearTimeout
      Отмена через clearTimeout
        Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.
        let timerId = setTimeout(...); clearTimeout(timerId);
    ?requestAnimationFrame (optional)
      window.requestAnimationFrame указывает браузеру на то, что вы хотите произвести анимацию, и просит его запланировать перерисовку на следующем кадре анимации. В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
      Примечание: Ваш callback метод сам должен вызвать requestAnimationFrame() иначе анимация остановится.
      Вы должны вызывать этот метод всякий раз, когда готовы обновить анимацию на экране, чтобы запросить планирование анимации. Обычно запросы происходят 60 раз в секунду, но чаще всего совпадают с частотой обновления экрана. 
      В большинстве браузеров в фоновых вкладках или скрытых <iframe>, вызовы requestAnimationFrame() приостанавливаются, для того, чтобы повысить производительность и время работы батареи.
      window.requestAnimationFrame(callback);  callback - Функция, которая будет вызвана, когда придёт время обновить вашу анимацию на следующей перерисовке.
      Возвращаемое значение
        requestID — длинное целое, являющееся уникальным идентификатором для записи, содержащей callback. Оно не равно нулю, но других предположений о его значении делать не следует. Вы можете передать его в window.cancelAnimationFrame() для отмены вызова.
      */
       // Анимируем
      function animate(highResTimestamp) {
        requestAnimationFrame(animate);
        // Анимируем что-нибудь…
        }
        // Запускаем анимацию.
        requestAnimationFrame(animate);
      /*
    ?Be able to explain difference between setTimeout and requestAnimationFrame (optional)
      requestAnimationFrame и setTimeout немного похожи. Разница в том, что setTimeout вызывается после ожидания указанного количества миллисекунд, а requestAnimationFrame вызывается каждый раз при обновлении экрана. 
        Обратите внимание, что обновление экрана здесь не означает, что страница обновляется. Метод requestAnimationFrame имеет только один параметр. Переданный метод будет вызываться при следующем обновлении экрана 
        (на самом деле он помещается в очередь вызовов, а не выполняется немедленно). Его использование примерно следующее

  +Web Storage API & cookies
    ?Cookies (concept)
      Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.
      Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.
        Один из наиболее частых случаев использования куки – это аутентификация:
          1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
          2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
          3. Таким образом, сервер понимает, кто сделал запрос.
    ?Difference between localStorage, sessionStorage, session and cookies
      Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.
      Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage).
      Но ведь у нас уже есть куки. Зачем тогда эти объекты?
        *В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Поэтому мы можем хранить гораздо больше данных. Большинство браузеров могут сохранить как минимум 2 мегабайта данных (или больше), и этот размер можно поменять в настройках.
        *Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
        *Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
        localStorage - Совместно используется между всеми вкладками и окнами с одинаковым источником. «Переживает» перезапуск браузера
        sessionStorage - Разделяется в рамках вкладки браузера, среди ифреймов из того же источника. «Переживает» перезагрузку страницы (но не закрытие вкладки)
!Typescript:

  +Ability to write concise TypeScript code using its constructs
    ?understanding TS(ES6) module system
      Модули предоставляют способ организации и классификации кода, позволяя группировать связанный код вместе. Кроме того, когда код находится внутри модуля, он извлекается из глобальной области в область модуля. 
        Это может помочь избежать конфликтов именования компонентов в глобальном пространстве имен.
        -!-Модули были реализованы в JavaScript начиная с ES6, поэтому они также поддерживаются TypeScript. До ES6 предыдущие версии TypeScript назывались "внешними модулями".
        Можно экспортировать любое объявление (например, переменную, функцию, класс, псевдоним типа или интерфейс), добавив ключевое слово export или импортировав его с помощью ключевого слова import. 
        Любой файл, содержащий import верхнего уровня или оператор export, считается модулем. 
        Оператор export явным образом делает компонент в одном модуле доступным для других модулей, а оператор import позволяет использовать этот компонент из другого модуля. 
        Модули являются декларативными; операторы import и export на уровне файлов описывают связи между ними.
    ?describing variables with primitive data types.
      Объявление переменных let и const:
        Типы с переменными можно связывать с помощью явных аннотаций типов или путем неявного определения типа. Явные аннотации типов — рекомендуемый, хотя и необязательный метод в TypeScript. 
        let x: number;   // Explicitly declares x as a number type
        let y = 1;       // Implicitly declares y as a number type
        let z;           // Declares z without initializing it как any type
      +Types and subtypes in TypeScript
        Any type: 
          any — это единственный тип, который может представлять любое значение JavaScript без ограничений. Все остальные типы делятся на примитивные, типы объектов или параметры типов.
        Primitive types:
          boolean, number, bigint, string, void | null, and undefined, а также пользовательские перечисления или типы enum. 
          Тип void нужен лишь для того, чтобы указывать на отсутствие значения, например в функции без возвращаемого значения.
          Типы null и undefined являются подтипами всех остальных типов. На типы null и undefined нельзя ссылаться явно. Можно ссылаться только на их значения с помощью литералов null и undefined.
        Object types and type parameters
          Типы объектов — это все классы, интерфейсы, массивы и литеральные типы (все, что не является примитивным типом).
          Типы классов и интерфейсов вводятся путем объявления классов и интерфейсов, а ссылаться на них следует по имени, присвоенному в объявлении.
        Any type:
          Помните, что все удобство использования any достигается за счет потери безопасности типов.  any следует использовать, только когда это действительно необходимо.
          */
          let randomValue1: any = 10;
          console.log(randomValue1.name); // any обходит любые проверки во время компиляции. Объект вычисляется во время выполнения. TS не увидит что свойства нет!
          /*
        Unknown type:
          Хотя тип any очень гибкий, он может вызывать непредвиденные ошибки. Во избежание этого в TypeScript был введен тип unknown.
          Тип unknown похож на тип any тем, что типу unknown можно присваивать любое значение. Однако вы не можете получить доступ к свойствам типа unknown, а также вызывать или создавать их.
          Основное различие между any и unknown заключается в том, что вы не можете взаимодействовать с переменной типа unknown. Это вызывает ошибку компилятора. any обходит любые проверки во время компиляции. 
          Объект вычисляется во время выполнения. Если метод или свойство существует, все будет работать нормально.
    ?using interfaces with optional properties, read-only properties, etc...
        В TypeScript интерфейсы можно использовать так же, как в традиционном объектно-ориентированном программировании. Можно также использовать интерфейсы для определения типов объектов.
        Интерфейсы можно использовать для описания объекта, именования и параметризации типов объектов, а также для составления существующих типов именованных объектов в новые.
      интерфейс не инициализирует и не реализует свойства, объявленные внутри него. Это обусловлено тем, что единственным заданием интерфейса является описание типа. Он определяет, что требует контракт кода, 
        а переменная, функция или класс, реализующие интерфейс, удовлетворяют контракту, предоставляя необходимые сведения о реализации.
      Этот простой интерфейс определяет два свойства и метод объекта Employee.
        */
      interface Employee1 {// Интерфейсы не имеют представления во время выполнения; они существуют только во время компиляции.
        firstName: string;
        lastName: string;
        fullName(): string;
      }
      let employee1: Employee1 = { // интерфейс реализуется путем объявления переменной типа Employee. Он выполняет контракт.
        firstName: "Emil",
        lastName: "Andersson",
        fullName(): string {
          return this.firstName + " " + this.lastName;
        }
      }
      //employee.firstName = 10;  //* Error - Type 'number' is not assignable to type 'string'
      /*
      +How is an interface different from a type alias( Как разница между интерфейсом и псевдонимом типа)?
        Приведенный выше интерфейс Employee можно также выразить как псевдоним типа с помощью ключевого слова type:
          */
          type Employee2 = {
            firstName: string;
            lastName: string;
            fullName(): string;
          }
          /*
        Псевдоним типа(alias) - это определение типа данных, например объединения, примитива, пересечения, кортежа или любого другого типа. 
        С другой стороны, интерфейсы - это способ описания форм данных, например, объекта. Псевдонимы типов(alias) могут действовать как интерфейсы; однако есть некоторые тонкие различия.
        Ключевое различие заключается в том, что псевдоним типа(alias) нельзя повторно открыть для добавления новых свойств, в то время как интерфейс всегда можно расширить.
        !Кроме того, вы можете описать объединение(Union) или кортеж(Tuple) только с помощью псевдонима типа(alias)!!!
        Other ways to use interfaces
      Create indexable types( Создание типов, которые могут быть индексируемыми):
        Можно использовать интерфейсы, описывающие типы массивов, в которые можно выполнять индексирование.
        Например, интерфейс IceCreamArray объявляет сигнатуру индекса как number и возвращает тип string. Эта сигнатура индекса указывает, что IceCreamArray индексируется числом и будет возвращать строку.
          */
          interface IceCreamArray {
            [index: number]: string;
          }

          let myIceCream2: IceCreamArray;
          myIceCream2 = ['chocolate', 'vanilla', 'strawberry'];
          let myStr: string = myIceCream2[0];
          console.log(myStr);
          /*
      В TypeScript можно управлять видимостью членов класса, добавив ключевое слово public, private или protected перед именем элемента:
      -public - Если модификатор доступа не указан, значение по умолчанию — public. Элемент можно также явно обозначить как общедоступный с помощью ключевого слова public.
      -private - После изменения элемента с помощью ключевого слова private доступ к нему извне невозможен.
      -protected - Модификатор protected действует так же, как модификатор private, за исключением того, что элементы, объявленные как protected, доступны также в производных классах. (Вы узнаете об этом позже из этого модуля.)
    Кроме того, с помощью модификатора readonly свойства можно обозначить как readonly. Доступные только для чтения свойства могут быть заданы только во время инициализации при объявлении или в constructor.
    ?creating custom types.
    ?types/interface differences (optional)
    ?function types.
      let addNumbers2 = (x: number, y: number): number => x + y;
      +Funcion with parameters
          Компилятор TypeScript по умолчанию предполагает, что требуются все параметры, определенные в функции. При вызове функции компилятор TypeScript проверяет следующее:
            -Значения были предоставлены для каждого параметра.
            -передаются ли только те параметры, которые необходимы функции;
            -параметры передаются в том порядке, в котором они определены в функции.
            Это отличается от JavaScript, где предполагается, что все параметры являются необязательными и позволено передавать в функцию больше (или меньше) аргументов, чем в ней определено.
        +Required parameters
          Если не указано иное, все параметры функции являются обязательными, а число аргументов, передаваемых в функцию, должно соответствовать числу обязательных параметров, которые требуются функции.
            */
          function addNumbersReq(x: number, y: number): number {
            return x + y;
          }
          addNumbersReq(1, 2); // Returns 3
          // addNumbersReq(1);    // Returns an error
          /*
      +Optional parameters
        Кроме того, можно определить необязательные параметры, добавив в конец имени параметра вопросительный знак (?). Необязательный параметр должен следовать после всех обязательных параметров в списке параметров.
        Кроме того, чтобы эта функция возвращала правильное значение, необходимо учитывать вероятность того, что y может передаваться как undefined.
          */
          function addNumbersOpt(x: number, y?: number): number {
            if (y === undefined) {
              return x;
            } else {
              return x + y;
            }
          }
          addNumbersOpt(1, 2); // Returns 3
          addNumbersOpt(1);    // Returns 1
          /*
      +Default parameters
        Если значение передается необязательному параметру в качестве аргумента, ему будет присвоено это значение. В противном случае ему присваивается значение по умолчанию.
        Как и в случае с необязательными параметрами, параметры по умолчанию должны следовать после обязательных параметров в списке параметров.
          */
          function addNumbersDef(x: number, y = 25): number {
            return x + y;
          }
          addNumbersDef(1, 2);  // Returns 3
          addNumbersDef(1);     // Returns 26
          /*
    ?utitily types (optional)
      В TypeScript есть набор типов, которые являются шорткатами преобразований других типов.
        Partial<Type> - создает новый тип, в котором все свойства типа Type являются необязательными. fieldsToUpdate: Partial<Todo>
        Required<Type> - создает новый тип, в котором все свойства типа Type являются обязательными. newTodo: Required<Todo>
        Readonly<Type> - создает новый тип, в котором все свойства типа Type являются только для чтения. readonlyTodo: Readonly<Todo>
        Pick<Type, Keys> - создает новый тип, в котором все свойства типа Type являются только для чтения. pickTodo: Pick<Todo, "title" | "description">
        !Record<Keys, Type> - создает новый тип, в котором все свойства имеют тип Type. recordTodo: Record<"todo1" | "todo2", Todo> !!!

    ?typeguards (optional)
      Защитники типа — это правила, которые помогают выводу типов определить суженый диапазон типов для значения, принадлежащего к типу Union. Другими словами, разработчику предоставлен механизм, 
        позволяющий с помощью выражений составить логические условия, проанализировав которые, вывод типов сможет сузить диапазон типов до указанного и выполнить над ним требуемые операции.
    ?generic types (concept)
      Но что если вы хотите создать компонент, который может работать с различными типами, а не только с одним? Можно использовать тип any, но вы лишитесь преимуществ системы проверки типов TypeScript.
      Универсальные шаблоны являются шаблонами кода, которые можно определять и использовать в базе кода. Они предоставляют способ указать функциям, классам или интерфейсам, какой тип вы хотите использовать при вызове.
      Это можно сравнить с аргументами, которые передаются в функцию, правда универсальный шаблон позволяет указать компоненту, какой тип он должен ждать в момент вызова.
        Create generic functions(Создайте универсальные функции, если ваш код является функцией или классом, который:)
        -Работает с различными типами данных.
          -Использует этот тип данных в нескольких местах.
        Generics can(Универсальные шаблоны могут:)
          -Обеспечить большую гибкость при работе с типами.
          -Поддержать повторное использование кода.
          -Сократить потребность в использовании типа any.

!Design patterns:

  +Intermediate knowledge of patterns and best practices:
    ?design patterns used on his project, and able to compare these patterns (optional)
    Некоторые проблемы слишком малы для выделения в архитектурный подход, но достаточно часто встречаются, чтобы породить стандартные решения. Такие стандартные решения называются паттернами или шаблонами.
      Порождающие - Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
      Структурные - Отвечают за построение удобных в поддержке иерархий классов.
      Поведенческие - Решают задачи эффективного и безопасного взаимодействия между объектами программы.
    ?KISS, DRY, YAGNI
    1. YAGNI
      You Aren’t Gonna Need It / Вам это не понадобится
        Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.
        Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.
        Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.
    2. DRY
      Don’t Repeat Yourself / Не повторяйся
        Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?
        В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, 
          что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.
        Использование SSOT позволит создать более прочную и понятную кодовую базу.
        Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.
        В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. 
        Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.
    3. KISS
      Keep It Simple, Stupid / Будь проще
        Этот принцип гласит, что простые системы будут работать лучше и надежнее. Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.
        Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.
        Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.
    ?The meaning behind SOLID principles.
    SOLID — это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion. В переводе на русский: принципы единственной ответственности, открытости / закрытости, подстановки Барбары Лисков, разделения интерфейса и инверсии зависимостей)
    Аббревиатура SOLID была предложена Робертом Мартином, автором нескольких книг, широко известных в сообществе разработчиков. Эти принципы позволяют строить на базе ООП масштабируемые и сопровождаемые программные продукты с понятной бизнес-логикой.
    Расшифровка:
      -Single responsibility — принцип единственной ответственности
      -Open-closed — принцип открытости / закрытости
      -Liskov substitution — принцип подстановки Барбары Лисков
      -Interface segregation — принцип разделения интерфейса
      -Dependency inversion — принцип инверсии зависимостей
    Принцип единственной обязанности / ответственности (single responsibility principle / SRP) обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности. Подробнее про SRP...
    Принцип открытости / закрытости (open-closed principle / OCP) декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода. Подробнее про OCP...
    Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP) в формулировке Роберта Мартина: «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом». Подробнее про LSP...
    Принцип разделения интерфейса (interface segregation principle / ISP) в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, 
      чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют. 
    Принцип инверсии зависимостей (dependency inversion principle / DIP) — модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.
!Web Communication Protocols: (optional)

  +HTTP vs HTTPS vs HTTP/2
    HTTP был разработан как протокол обмена данными между веб-сервером и веб-браузером. Это протокол прикладного уровня модели OSI, который используется для передачи между клиентом и сервером файлов HTML, CSS, JS, API, картинок, аудио, видео, введённых пользователем данных и прочего. 
      Клиент (веб-браузер) отправляет серверу (веб-серверу) запросы и получает от него ответы. Сервер в рамках протокола HTTP практически всегда занимает пассивную позицию.
    Есть три главных объекта, которые обмениваются сообщениями:
      -Клиент (user agent) — программа, которая отправляет запросы, получает и обрабатывает ответы от имени пользователя на устройстве пользователя, например, браузер.
      -Сервер (веб-сервер) — программа, которая работает на сервере, принимает и обрабатывает запросы от клиента, а затем отправляет ответы клиенту. Этой программой является веб-сервер.
      -Прокси (прокси-сервер) — программа, которая работает на сервере, пропускает через себя запросы и ответы и выступает в роли посредника между клиентом и сервером.
    Протокол HTTP не хранит состояние, поэтому количество соединений не приводит к существенному усложнению взаимодействия между объектами системы. Однако существует понятие сессии, с помощью которой можно передавать и хранить необходимые данные, относящиеся к конкретному сеансу связи. 
      Данные сессии сохраняются на клиенте и на сервере. Например, доступен идентификатор сессии, который позволяет не проводить авторизацию клиента при каждом обращении к серверу. Часто для хранения данных о сессии используются Cookie.
    Прокси-серверы осуществляют сервисные функции:
      -Кэшировать данные запроса или ответа для улучшения производительности и снижения сетевого трафика.
      -Фильтровать данные. Например, можно сканировать данные антивирусом или использовать родительский контроль.
      -Осуществлять балансировку нагрузки, распределяя запросы между разными серверами.
      -Проводить аутентификацию клиентов для управления доступом к ресурсам.
      -Хранить информацию о запросах клиентов и ответах сервера, реализуя таким образом логирование.
      -Обнаруживать некоторые типы атак на сетевой узел (например, определение подозрительного трафика или DDoS-атаки).
    Формат сообщения
      HTTP-сообщение представляет собой обычный текст. Структура сообщения строго определена:
        -Стартовая строка;
        -Заголовки, передают сервисную информацию;
        -Тело сообщения, представляет данные в текстовом виде.
        Тело сообщения — это опциональная часть сообщения, которая может отсутствовать. Например, для некоторых GET-запросов (то есть запросов со стороны клиента, в качестве метода получения данных для которого выбран метод GET) или для всех HEAD-запросов. 
          Если тело сообщения присутствует, то это обозначается заголовками Content-Length или Transfer-Encoding.
    Стартовая строка
      Стартовая строка запроса содержит информацию о методе запроса, относительном адресе и версии протокола в формате Метод URI HTTP/Версия. Стартовая строка ответа содержит версию протокола, код и статус ответа сервера в формате HTTP/Версия Код Статус.
      Когда браузер посылает запрос на открытие главной страницы сайта, стартовая строка запроса будет такой: GET / HTTP/1.1
      Если страница существует и к ней есть доступ, то стартовая строка ответа будет такой: HTTP/1.1 200 OK
    Методы запроса описывают тип обработки данных, который клиент хочет осуществить. Доступны следующие методы:
      -OPTIONS — используется для определения возможностей сервера по преобразованию данных.
      -GET — используется для получения данных от сервера.
      -HEAD — то же, что и GET, но не содержит тело в сообщении ответа.
      -POST — используется для отправки данных на сервер.
      -PUT — используется для добавления новых или изменения существующих данных на сервере.
      -PATCH — то же, что и PUT, но используется для обновления части данных.
      -DELETE — используется для удаления данных на сервере.
      -TRACE — возвращает запрос от клиента таким образом, что в ответе содержится информация о преобразованиях запроса на промежуточных серверах.
      -CONNECT — переводит текущее соединение в TCP/IP-туннель. Обычно этот метод используется для установления защищённого SSL-соединения.
    Код состояния в ответе сервера содержит информацию о результате обработки данных. Существует пять классов кодов состояний:
      1xx — обработка данных на сервере продолжается;
      2xx — успешная обработка данных;
      3xx — перенаправление запросов;
      4xx — ошибка по вине клиента;
      5xx — ошибка по вине сервера.

    HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов 
      TLS или устаревшего в 2015 году SSL[1]. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443[2].
      HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS[4].

    HTTP/2 (изначально HTTP/2.0) — вторая крупная версия сетевого протокола HTTP, используемая для доступа к World Wide Web. Браузерная поддержка HTTP/2 включает в себя HTTPS-шифрование
      HTTP/2 является первой новой версией HTTP с версии HTTP 1.1, которая была стандартизирована RFC 2616 в 1999. 
        -Протокол HTTP/2 является бинарным[13][14]. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом.
        -В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, 
          без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.
        -Также часть улучшений получена (в первом черновике HTTP/2, который представлял собой копию спецификации SPDY) за счёт мультиплексирования запросов и ответов (для преодоления проблемы «head-of-line blocking» 
          протоколов HTTP/1.x), а также за счёт сжатия передаваемых заголовков и введения явной приоритизации запросов.
  +RESTful API
    REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса. REST сейчас — один из самых распространённых стилей API в интернете.
      Отличительная особенность этого стиля — это стиль построения адресов и выбор метода. Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
        -созданию чего-либо, например, объекта пользователя (create, C); POST для создания;
        -чтению (read, R); GET для чтения;
        -обновлению (update, U); PUT, PATCH для обновления; Разница между PUT и PATCH в том, что PUT обновляет объект целиком, а PATCH — только указанное поле.
        -удалению (delete, D). DELETE для удаления.
      Адрес, как правило, остаётся почти одинаковым, а детали запроса указываются в HTTP-методе и параметрах или теле запроса.
  +HTTP methods
  +HTTP status codes groups

!Common web-security knowledge (optional)
  +Basic understanding of most common security terms (CORS, XSS) (optional)
    Веб-приложения, как и любые другие, можно «взломать». Если в приложении есть место, куда можно ввести текст, загрузить изображение, передать какую-то информацию, злоумышленники могут использовать это место для атаки.
      Уязвимостей у веб-приложений много.
    ?XSS
      Cross Site Scripting — это внедрение вредоносного кода на страницы атакуемого сервиса.
        Злоумышленник вводит <script>alert('XSS!');</script> в поле поиска;
        В нашем случае <script>alert('XSS!');</script> встраивается на страницу, и срабатывает alert().
        Конечно, вместо alert() злоумышленники могут написать более изощрённый скрипт, который будет, например, рассылать спам от имени пользователя.
        Атака выше — это пример отражённого XSS (reflected XSS). Отражённого, потому что его действие сразу же отражается на поведении страницы. Кроме него есть хранимый (stored) XSS, о нём поговорим чуть дальше.
      Как защититься
        Экранировать любой пользовательский ввод! Каким бы маленьким и незначительным ни казалось поле ввода, всё, что пользователь пишет, следует экранировать.
        Экранирование (escaping) — это замена специальных символов (например, которые браузер может принять за теги) другими, безопасными.
        При экранировании запись <script>alert('XSS!');</script> превратится в &lt;script&gt;alert('XSS!');&lt/script&gt;. Такую запись браузер не распознает как тег или скрипт.
        Для экранирования пользовательского ввода в JS следует использовать:
          -encodeURI() — чтобы кодировать URI-адрес
          -encodeURIComponent() — кодировать часть URI-адреса, например, searchQuery
          -специальные библиотеки для замены <, >, ', " и других специальных символов.
          Также на сервере следует проверять и при необходимости экранировать все данные, приходящие от клиента.
    ?CORS
      Cross-Site Request Forgery
        Межсайтовая подделка запроса (Cross-Site Request Forgery, CSRF) — атака, при которой злоумышленники могут совершать действия как бы от лица пользователя.
        Злоумышленники знают, что после логина в Switter у пользователя остаются куки, которые потом используются для аутентификации. Они могут:
          -Заманить пользователя, который был аутентифицирован в Switter, на вредоносную страницу;
          -Используя его или её куки отправить запрос к Switter с «просьбой» переслать денег на конкретный аккаунт;
          -Так как пользователь «аутентифицирован» запрос считается «валидным», пользователь теряет деньги.
        Проблемы здесь две:
          -Злоумышленники могли увидеть куки пользователя и таким образом выдать себя за него.
          -Сервису Switter достаточно аутентификации для перевода денег, он не требует авторизации запроса.
          Авторизацию не следует путать с аутентификацией.
            Аутентификация — подтверждение личности (Вася — это действительно Вася).
            Авторизация — подтверждение, что у пользователя хватает прав, чтобы выполнить какое-то действие (Марина действительно хочет перевести деньги, вот подтверждение).
      Как защититься Секция статьи "Как защититься"
        В первую очередь куки следует выставлять так, чтобы они были видны лишь для сервиса, который их выставил. Для этого можно использовать SameSite Cookie: Set-Cookie: key=value; SameSite=Strict
        Также, если с куками не должны работать клиентские скрипты, их можно спрятать: Set-Cookie: key=value; HttpOnly Это сделает куку видимой только для сервера и самого браузера (но в клиентском JS её использовать будет нельзя).
        Также можно использовать CSRF-токены для подписи каждого запроса, который необходимо авторизовать. Такой токен гарантирует, что запрос был отправлен пользователем не случайно.
        Для AJAX-запросов следует указывать CSP и CORS-политику. Cross-Origin Resource Sharing, CORS — определяет, доступ к каким ресурсам есть у запросов с другого домена (origin).
    ?OWASP Top 10
      Отчет об уязвимостях OWASP формируется на основе консенсуса мнений экспертов по безопасности со всего мира. Он ранжирует риски на основе частоты дефектов, серьезности уязвимостей и их потенциального воздействия. 
        Это дает разработчикам и специалистам по безопасности понимание наиболее серьезных рисков и позволяет им минимизировать возможные последствия эксплуатации уязвимостей злоумышленниками.
        В последнем отчете OWASP перечислены 10 основных уязвимостей:
          -Инъекции (Injections).
            Инъекционные атаки происходят, когда ненадежные данные передаются интерпретатору кода через ввод формы или с помощью другого способа отправки информации в веб-приложение.
          -Нарушенная аутентификация (Broken Authentication).
            Уязвимости аутентификации могут позволить злоумышленникам получить доступ к учетным записям пользователей, включая привилегированные, которые затем можно использовать для получения контроля над корпоративными информационными системами.
          -Раскрытие критически важных данных (Sensitive Data Exposure).
            Основная причина риска раскрытия критически важных данных связана с отсутствием шифрования или с использованием ненадежных методов генерации и управления ключами, слабых алгоритмов шифрования, ненадежных способов хранения паролей и т.д.
          -Внешние объекты XML (XXE) (XML External Entities (XXE)).
            Атаки XXE нацелены на веб-приложения, которые анализируют расширяемый язык разметки (XML). Они возникают, когда ввод содержащего ссылку на внешний объект кода XML обрабатывается синтаксическим анализатором со слабой конфигурацией.
          -Нарушенный контроль доступа (Broken Access control).
            Проблемы с контролем доступа позволяют злоумышленникам обойти заданные ограничения и получить несанкционированный доступ к системам и конфиденциальным данным, а также потенциально получить доступ к учетным записям администраторов и привилегированных пользователей.
          -Неправильная конфигурация безопасности (Security misconfigurations).
            Ошибки настройки безопасности считаются наиболее распространенной уязвимостью в рейтинге OWASP Top 10. Чаще всего они связаны с использованием стандартных настроек веб-сайтов или системы управления контентом (CMS).
          -Межсайтовый скриптинг (XSS) (Cross Site Scripting (XSS)).
            Уязвимости XSS позволяют киберпреступникам внедрять скрипты на веб-сайт и использовать его для распространения выполняющегося в браузере пользователя вредоносного кода. Как правило это нужно для перехвата пользовательских сеансов, кражи конфиденциальных данных или перенаправления пользователя на вредоносные сайты.
          -Небезопасная десериализация (Insecure Deserialization).
            В терминах хранения данных и информатики сериализация означает преобразование объектов или структур данных в байтовые строки. Десериализация означает преобразование этих байтовых строк в объекты. Небезопасная десериализация предполагает, что злоумышленники изменяют данные до того, как они будут десериализованы.
          -Использование компонентов с известными уязвимостями (Using Components with known vulnerabilities).
            Программные компоненты, такие как фреймворки и библиотеки, часто используются в веб-приложениях для обеспечения определенных функций. Однако эти компоненты могут содержать уязвимости, позволяющие злоумышленнику начать кибератаку.
          -Недостаточно подробные журналы и слабый мониторинг (Insufficient logging and monitoring).
            Успешную хакерскую атаку или утечку данных удается обнаружить далеко не всегда. Часто злоумышленники не только получают несанкционированный доступ к информационным системам, но хозяйничают в них месяцами или годами, оставаясь невидимыми. 
              Чтобы этого не произошло, необходимо регистрировать и отслеживать поведение веб-приложения, чтобы своевременно распознать подозрительную активность и либо предотвратить атаку, любо минимизировать ее последствия.
    ?Auth (JWT, OAuth, Basic, etc.)
      HTTP Basic Auth
        HTTP Basic AuthВ HTTP базовая аутентификация - это метод проверки входа в систему, который позволяет веб-браузерам или другим клиентским программам предоставлять учетные данные в виде имен пользователей и паролей по запросу. Обычно имена пользователей и чистые коды передаются через заголовки HTTP.
        Перед отправкой к имени пользователя добавляется двоеточие, затем пароль соединяется, и результирующая строка символов затем кодируется с помощью алгоритма Base64. 
        Например, если предоставленное имя пользователя - Aladdin, а пароль - «открытый кунжут», то результат после объединения - «Aladdin: открыть кунжут», а затем использовать его.Кодировка Base64Чтобы получить QWxhZGRpbjpvcGVuIHNlc2FtZQ ==. 
        Наконец, строка в кодировке Base64 отправляется, и получатель декодирует ее, чтобы получить строку имен пользователей и паролей, разделенных двоеточиями.
          Преимущество
            базовой аутентификации состоит в том, что в основном все популярные веб-браузеры поддерживают базовую аутентификацию.
          недостаток
            Поскольку имя пользователя и пароль кодируются как Base64, а кодирование Base64 является обратимым, имя пользователя и пароль можно рассматривать как обычный текст. Поэтому его можно использовать только в том случае, если соединение между клиентом и хостом сервера является безопасным и надежным.
      OAuth
        OAuth - это открытый сетевой стандарт для авторизации. Разрешить пользователям предоставлять токен вместо имени пользователя и пароля для доступа к данным, которые они передали конкретному поставщику услуг. Текущая версия - версия 2.0.
        Строго говоря, OAuth2 - это не стандартный протокол, а безопасная структура авторизации. Подробно описывается, как разные роли, пользователи, интерфейсные приложения служб (например, API-интерфейсы) и клиенты (например, веб-сайты или мобильные приложения) реализуют взаимную аутентификацию.
      Сертификация JWT
        Json web token (JWT)Согласно определению официального сайта, это открытый стандарт на основе JSON (RFC 7519), который реализован для передачи операторов между средами сетевых приложений. Токен спроектирован так, чтобы быть компактным и безопасным, и особенно подходит для одной точки распределенных сайтов. Сценарий входа в систему (SSO).
        Оператор JWT обычно используется для передачи аутентифицированной информации об идентификаторе пользователя между поставщиком идентификатора и поставщиком услуг для получения ресурсов от сервера ресурсов, а также может добавить некоторую дополнительную необходимую бизнес-логику.
        Для объявления информации токен также может использоваться для аутентификации напрямую или в зашифрованном виде.
        Особенности JWT
          -Малый размер, высокая скорость передачи
          -Различные способы передачи, могут быть переданы через URL / параметры POST / HTTP-заголовок и другие методы
          -Строго структурированный Само по себе (в полезной нагрузке) содержит все относящиеся к пользователю сообщения аутентификации, такие как доступная пользователю маршрутизация, период действия доступа и т. Д. Серверу не нужно подключаться к базе данных для проверки достоверности информации, а полезная нагрузка поддерживает настройку для вашего приложения. из.
          -Поддержка междоменной аутентификации, может применяться для единого входа.
        Принцип JWT
          JWT - это схема, предложенная Auth0 для реализации проверки авторизации путем шифрования и подписывания JSON. Закодированный JWT выглядит следующим образом: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ  
          К.Он разделен на три раздела, которые можно получить путем декодирования:
            1. Заголовок jwt содержит две части информации:
              -Тип объявления, вот JWT
              -Заявленные алгоритмы шифрования обычно используют HMAC SHA256 напрямую
              Заголовок затем шифруется с помощью base64 (шифрование может быть расшифровано симметрично) для формирования первой части. eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
            2. Полезная нагрузка - это место, где хранится действительная информация. Эта действительная информация состоит из трех частей:
              -Стандартная регистрационная выписка
              -Общественная репутация
              -Личное заявление
              */
              // Включая информацию о пользователе для передачи;
              { "iss": "Online JWT Builder", 
              "iat": 1416797419, 
              "exp": 1448333419, 
              "aud": "www.gusibi.com", 
              "sub": "uid", 
              "nickname": "goodspeed", 
              "username": "goodspeed", 
              "scopes": [ "admin", "user" ] 
              }
              /*
              -iss: используется ли эмитент этого JWT, необязательно;
              -sub: используется ли пользователь, на который нацелен этот JWT, или нет;
              -aud: используется ли сторона, получающая JWT, или нет;
              -exp (expires): когда он истекает, здесь есть метка времени Unix, использовать ли ее необязательно;
              -iat (выдан в): когда он был выпущен (время UNIX), использовать его необязательно;
            3. Третья часть jwt - это информация о визе, эта информация о визе состоит из трех частей:
              -заголовок (после base64)
              -полезная нагрузка (после base64)
              -secret
              Наконец, мы шифруем вышеприведенную строку с помощью алгоритма HS256. При шифровании нам также необходимо предоставить секрет. Если мы используемsecretВ качестве ключа мы можем получить наш зашифрованный контент:
              Три части объединяются в полную строку, образуя окончательный JWT:

!Coding tasks:

  +Function.prototype.bind implement polyfill
    */
  if (!Function.prototype.bind) {
    Function.prototype.bind = function(context, ...args) {
      let object = {...context}; // создаем объект и копируем в него контекст
      let symbol = Symbol('target'); // создаем символ уникальный
      object[symbol] = this; // добавляем в объект свойство с ключом символ и значением this
      return function(...rest) {  // возвращаем функцию 
        return object[symbol](...args, ...rest); // вызываем функцию с контекстом и аргументами
      };
    };
  }
  /*
  +Object.create implement polyfill
    */
  if (!Object.create) {
    Object.create = function(base) {
      function F() {}; // создаем функцию
      F.prototype = base; // прототип функции равен базовому объекту
      return new F(); // возвращаем новый объект
    }
  }
  /*
  +Array.flat implement polyfill
    */
  if (!Array.prototype.flat)
  Array.prototype.flat = function (depth = 1) {
    depth = isNaN(depth) ? 0 : Math.floor(depth); // проверяем на число и округляем
  if (depth < 1) return this.slice(); // если глубина меньше 1 возвращаем копию массива
  return [].concat( 
        ...(depth < 2) // если глубина меньше 2
          ? this // возвращаем массив
          : this.map(v => Array.isArray(v) ? v.flat(depth - 1) : v) // иначе рекурсивно вызываем flat
    )
  };
  /*
  +Array.reduce implement polyfill
  */
  Array.prototype.myReduce= function(callbackFn, initialValue) {
    let accumulator = initialValue;
  for (let i = 0; i < this.length; i++) {
      if (accumulator !== undefined) {
        accumulator = callbackFn.call(undefined, accumulator, this[i],   i, this); // вызываем функцию с аргументами и контекстом undefined
      } else {
        accumulator = this[i]; // если аккумулятор не определен, то присваиваем значение первого элемента
      }
    }
    return accumulator;
  }
  /*
  +'hello world'.repeating(3) -> 'hello world hello world hello world'. How to implement?
    */
  String.prototype.repeating = function (count) {
    let res = '';
    for (let i = 0; i < count; i++) {
      res += this;
    }
    return res;
  }
    /*
  +myFunc('!', 4, -10, 34, 0) -> '4!-10!34!0`. How to implement?
  */
  function myFunc() {
    let arr = [...arguments];
    let res = arr.filter((item) => typeof item === 'number').join('!');
    return res;
  }
  /*
  +five(plus(seven(minus(three())))) -> 9. How to implement?
   */
    const five = (func) => func ? func(5) : 5;
    const seven = (func) => func ? func(7) : 7;
    const three = (func) => func ? func(3) : 3;
    const minus = (num) => (num2) => num2 - num;
    const plus = (num) => (num2) => num2 + num;
    five(plus(seven(minus(three()))))
    /*
  +add(5)(9)(-4)(1) -> 11. How to implement?
    */
  function add(num) { // 
    let sum = num;  // создаем переменную и присваиваем ей значение аргумента
    function f(num2) { // создаем функцию
      sum = sum + num2; // прибавляем к сумме значение аргумента
      return f; // возвращаем функцию
    }
    f.toString = function () { // переопределяем метод toString
      return sum; // возвращаем сумму
    }
    return f; // возвращаем функцию
  }
  /*
  +periodOutput(period) method should output in the console once per every period how mach time has passed since the first function call. Example: periodOutput(100) -> 100(after 100 ms), 200(after 100 ms), 300(after 100 ms), ...
  */
  function periodOutput(period) {
    let count = 0;
    let timer = setInterval(() => {
      count = count + period;
      console.log(count);
    }, period);
    return timer;
  }
  
  // periodOutput(100);//? 
  /*
  +extendedPeriodOutput(period) method should output in the console once per period how mach time has passed since the first function call and then increase the period. Example: // extendedPeriodOutput(100) -> 100(after 100 ms), 200(after 200 ms), 300(after 300 ms)
  */
  function extendedPeriodOutput(period) {
    let count = 0;
    const tick = () => {
      let timer = setTimeout(() => {
        count = count + period;
        console.log(count);
        tick();
      }, period);
    }
    tick();
  }
  /*
*/