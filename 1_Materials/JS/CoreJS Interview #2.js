/* 
!JavaScript:

  +Advanced Expressions
    ?Hoisting
      Смысл поднятия в том, что переменные переносятся из места объявления в коде в верх их области видимости. Это механизм относится только к объявлению функций и переменных.
        -Одним из преимуществ помещения в память объявлений функций до выполнения кода то, что можно использовать функцию до её объявления. Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.
        -JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после её использования, то значение будет undefined. неявно происходит так: var a = 5; => var a; a = 5;
    ?Temporal dead zone
      TDZ: термин для описания состояния, когда переменные недоступны. Они находятся в области видимости, но не объявлены.
        -Переменные let и const существуют в TDZ с начала их объемлющей области видимости до момента их объявления.
        -Можно также сказать, что переменные существуют в TDZ с момента их привязки (когда переменная привязывается к области видимости, внутри которой она находится) до момента ее объявления (когда для этой переменной в памяти резервируется имя).
          Если бы мы обратились к переменной в блоке раньше, чем она была объявлена, это вызвало бы ошибку ReferenceError. Из-за TDZ.
      Это связано с hoisting. JS-движок, который разбирает и выполняет код, должен сделать 2 шага:
        1. Парсинг кода в абстрактное синтаксическое дерево/исполняемый байт-код, и
        2. выполнение во время исполнения.
        На шаге 1 происходит подъем, который выполняется движком JS. По сути, он перемещает все объявления переменных в верхнюю часть их области видимости.
        Единственное различие между const и let заключается в том, что когда они поднимаются, их значения не становятся по умолчанию undefiend. console.log(typeof name); => cannot acces name before initialization let name = 'test'; 
        Он знает, что имя существует (оно объявлено), но мы не можем получить к нему доступ до его инициализации.
      Почему у нас есть TDZ?
        -Она помогает нам отлавливать ошибки.
        -Пытаться получить доступ к переменной до ее объявления – это неправильный путь, и он не должен быть возможным.

  +Objects Built-in methods.
    ?Know static Object methods
      Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса. В объявлении класса они помечаются ключевым словом static.
      Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта. Синтаксис:
      */
      class MyClass {
        static property = '...';
      
        static method() {
          '...'
        }
      }
      /*
      Технически, статическое объявление – это то же самое, что и присвоение классу:
      MyClass.property = ...
      MyClass.method = ...
      Статические свойства и методы наследуются. Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.
      к статическому полю нельзя обратиться через this, только через имя класса. Поскольку статический метод относится классу в целом, а не к объекту, то мы НЕ можем обращаться в нем к нестатическим полям/свойствам и методам объекта, наподобие следующего: 
      Person.printAge();  // undefined printAge не статический метод, поэтому мы не можем обратиться к нему через имя класса, а только через объект.
      Однако мы можем использовать в статических методах слово this для обращения к статическим полям и другим статическим методам:

    ?Property flags & descriptors (student is able to set property via Object. defineProperty)
    ?Know how to create iterable objects, Symbol.iterator usage (optional)
      Перебираемые объекты
        Объекты, которые можно использовать в цикле for..of, называются итерируемыми.
          -Технически итерируемые объекты должны иметь метод Symbol.iterator.
            -Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации.
            -Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any}, где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение.
          -Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
          -Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
          -Строковый итератор знает про суррогатные пары.
        Объекты, имеющие индексированные свойства и length, называются псевдомассивами. Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.
        Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо «настоящих» массивов, потому что эти объекты более абстрактны.
        Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта или псевдомассива obj, и затем мы можем применять к нему методы массивов. Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым контекстом к каждому элементу.
        */
        let range = {
          from: 1,
          to: 5
        };
        
        // 1. вызов for..of сначала вызывает эту функцию
        range[Symbol.iterator] = function() {
        
          // ...она возвращает объект итератора:
          // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
          return {
            current: this.from,
            last: this.to,
        
            // 3. next() вызывается на каждой итерации цикла for..of
            next() {
              // 4. он должен вернуть значение в виде объекта {done:.., value :...}
              if (this.current <= this.last) {
                return { done: false, value: this.current++ };
              } else {
                return { done: true };
              }
            }
          };
        };
        
        // теперь работает!
        for (let num of range) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        // Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код.
        let range2 = {
          from: 1,
          to: 5,
        
          [Symbol.iterator]() {
            this.current = this.from;
            return this;
          },
        
          next() {
            if (this.current <= this.to) {
              return { done: false, value: this.current++ };
            } else {
              return { done: true };
            }
          }
        };
        
        for (let num of range2) {
          alert(num); // 1, затем 2, 3, 4, 5
        }
        /*

  +Object as Hash.
    Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object.
    Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть". У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений. 
    Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу. Она позволяет организовать данные ассоциативного массива удобным для хранения способом. 
    Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей. 
      Хеширование
        Любая операция внутри хеш-таблицы начинается с того, что ключ каким-то образом преобразуется в индекс обычного массива. Для получения индекса из ключа нужно выполнить два действия: найти хеш (хешировать ключ) и привести его к индексу (например, через остаток от деления).
        Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины.  Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". 
        Хеш всегда одинаковый для одних и тех же данных! console.log(hash); // => -337197338 С хешированием мы встречаемся в разработке часто. Например, идентификатор коммита в git 0481e0692e2501192d67d7da506c6e70ba41e913 не что иное, как хеш, полученный в результате хеширования данных коммита.
        После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления: const index = Math.abs(hash) % 1000; // по модулю // Это делается для того, чтобы индексы не были слишком большими
          Запись:
            const data = {}; data['key'] = 'value';Такая простая, на первый взгляд, строчка, запускает целый процесс. Ниже его грубое описание, без деталей и с упрощениями: Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне
              1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
              const internal = [];
              Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:
              2. Хеширует ключ. Результатом хеширования становится число.
              const hash = crc32.str('key');
              3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
              const index = Math.abs(hash) % 1000;
              В значение внутреннего индексированного массива, по найденному индексу, записывается ещё один массив, первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
              internal[index] = ['key', 'value'];
          Чтение: 
            1. Хешируется ключ. Результатом хеширования становится число.
            const hash = crc32.str('key');
            2. Число, полученное на предыдущем шаге преобразуется в индекс массива.
            const index = Math.abs(hash % 1000);
            3. Если индекс существует, то извлекается массив, который находился внутри, и возвращается наружу.
            return internal[index]; // ['key', 'value']
      Коллизии
        Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат работы хеш-функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.
        Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. Есть несколько способов разрешения коллизий (открытая адресация, метод цепочек), и каждому из них соответствует свой тип хеш-таблицы.
    ?Be able to loop through Object keys
    */
    const objHash = {
      'one': 1,
      'two': 2,
      'three': 3,
    }
    for (let key in objHash) {
      if (objHash.hasOwnProperty(key)) {
        console.log(`${key}: ${objHash[key]}`);
      }
    }
    const objKey = Object.keys(objHash)
    /*

  +Arrays Built-in methods
    ?Know how to copy array part
    ?Know how to flatten nested array
    */
    Array.prototype.flatten = function() {
      var ret = [];
      for(var i = 0; i < this.length; i++) {
          if(Array.isArray(this[i])) {
              ret = ret.concat(this[i].flatten());
          } else {
              ret.push(this[i]);
          }
      }
      return ret;
  };
    /*

  +Arrays Iterating, Sorting, Filtering
    ?Be able to custom sorting for Array
    */
    array.sort((x, y) => {
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
      return 0;
    });
    /*
    ?Be able to filter Array elements

  +Functional Scope
    Область видимости или Scope
      -Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области кода.
    Глобальная область видимости или Global Scope
      -В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.
    Локальная область видимости или Local Scope
      -Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.
      -Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.
      */
      // Глобальная область
        function foo1(){
       // Локальная область 1
          function foo2(){
           // Локальная область 2
          }
        }
      /*
    Область видимости функции
      -Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.
    Область видимости блока
      -Область видимости блока - это область в условиях if и switch или циклов for, и while. Вообще говоря, всякий раз, когда мы видим фигурные скобки {} - это блок. В ES6 ключевые слова const и let позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.
    Лексическая область видимости
      -Ещё один момент, о котором стоит упомянуть - это лексическая область. Лексическая область означает, что дочерняя область имеет доступ к переменным, определенным в родительской области. Дочерние функции лексически связаны с контекстом исполнения их родителей.
    Динамическая область видимости
      -Лексическая область видимости - это набор правил о том, как и где движок JavaScript может найти переменную. Ключевой характеристикой лексического контекста является то, что он определяется во время написания кода (при условии, что мы не используем eval () или with).
      -Динамическая область видимости, по понятным причинам, подразумевает, что существует модель, в которой область видимости может определяться динамически во время выполнения, а не статически во время создания. 
      */
      function foo(){
        console.log(a); // 5 В лексической области видимости указывается, что ссылка на a в foo() будет преобразована в глобальную переменную a, что приведет к выводу значения 5.
      }

      function bar(){
        var a = 10;
        foo();
      }
      
      var a = 5;
      
      bar();
      /*
      Динамическая область видимости, напротив, не связана с тем, как и где объявляются функции и области, а связана с тем, откуда они вызываются. Другими словами, цепочка областей видимости основана на стеке вызовов, а не на вложении областей видимости в коде.
      Таким образом, если бы JavaScript имел динамическую область видимости, то, когда выполняется foo(), теоретически приведенный ниже код, вместо 5 вернул бы 10 в качестве вывода.
      Когда foo() не может найти ссылку на переменную для a, вместо просмотра вложенной (лексической) цепочки областей видимости, он идет вверх по стеку вызовов, чтобы найти, откуда вызывалась функция foo(). Поскольку foo() была вызвана из bar(), он проверяет переменные в области видимости bar() и находит там a со значением 10.
      Но JavaScript, на самом деле, не имеет динамической области видимости. Он имеет только лексическую область. А вот механизм this подобен динамической области видимости.
      Вывод
        -Лексическая область - определяется во время написания кода, тогда как динамическая область (и this) - во время выполнения. Лексическая область заботится о том, где была объявлена функция, а динамическая область - о том, откуда была вызвана функция.
        -И наконец: this заботится о том, как была вызвана функция. Это показывает нам, насколько тесно механизм this связан с идеей динамической области видимости.
    ?Know global scope and functional scope
    ?Know variables visibility areas
    ?Understand nested scopes and able work with them

  +Functions Parameters / Arguments
  /here
    ?Know how to define Function parameters
    ?Know difference between parameters passing by value and by reference
      Передача параметров по значению
        Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.
        При вызове функции change ей передается число n. Однако после вызова функции мы видим, что число n не изменилось, хотя в самой функции произошло увеличение значения параметра. 
        Потому что при вызове функция change получает копию значения переменной n. И любые изменения с этой копией никак не затрагивают саму переменную n.
      Передача по ссылке
        Объекты и массивы передаются по ссылке. То есть функция получает сам объект или массив, а не их копию.
    ?Know how to handle dynamic amount of Function parameters
      Spread syntax Остаточные параметры (...)
        Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена. Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.
        Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».
        */
        function sumAll(...args) { // args — имя массива
          let sum = 0;
        
          for (let arg of args) sum += arg;
        
          return sum;
        }

        function showName(firstName, lastName, ...titles) {
          alert( firstName + ' ' + lastName ); // Юлий Цезарь
        
          // Оставшиеся параметры пойдут в массив
          // titles = ["Консул", "Император"]
          alert( titles[0] ); // Консул
          alert( titles[1] ); // Император
          alert( titles.length ); // 2
        }
        /*
        Остаточные параметры должны располагаться в конце! ...rest должен всегда быть последним.
      Объект arguments можно использовать при вызове функции с бо́льшим количеством аргументов, чем было предусмотрено в её объявлении. Такой способ удобен для функций, в которые допустимо передавать переменное количество аргументов. 
        Можно воспользоваться arguments.length, чтобы определить количество переданных в функцию аргументов, а затем обработать каждый из них с помощью объекта arguments. Чтобы определить количество параметров функции, описанных в её сигнатуре, можно использовать свойство Function.length.
        Использование оператора расширения для объекта arguments
          Как и с обычными массива-подобными объектами, для преобразования объекта arguments в обычный массив можно использовать метод Array.from() или оператор расширения: var args = Array.from(arguments); var args = [...arguments];
          Свойства:
            -arguments.callee Ссылка на функцию, которая выполняется в текущий момент.
            -arguments.caller Ссылка на функцию, которая вызвала функцию, выполняющуюся в текущий момент.
            -arguments.length Количество переданных в функцию аргументов.
            -arguments[@@iterator]  Возвращает новый объект Array Iterator, содержащий значения для каждого индекса в массиве.
      
  +ECMAScript Intermediate
    ?Function default parameters
      Параметры по умолчанию (Default parameters)
        В JavaScript параметры функции по умолчанию имеют значение undefined. Однако в некоторых ситуация может быть полезным поменять значение по умолчанию. В таких случаях default parameters могут быть весьма кстати.
        В прошлом для этого было необходимо в теле функции проверять значения параметров на undefined и в положительном случае менять это значение на дефолтное (default).
        С параметрами по умолчанию проверка наличия значения параметра в теле функции не нужна. Теперь вы можете просто указать значение по умолчанию для параметра b в объявлении функции:
        */
        function multiply(a, b = 1) {
          return a * b;
        }
        /*
    ?ECMA script modules
      По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». Модуль обычно содержит класс или библиотеку с функциями.
      -AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
      -CommonJS – модульная система, созданная для сервера Node.js.
      -UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.
      Система модулей на уровне языка появилась в стандарте JavaScript в 2015 году и постепенно эволюционировала.
        1. Что такое модуль? 
          Модуль – это просто файл. Один скрипт – это один модуль. Чтобы работал import/export, нужно для браузеров указывать атрибут <script type="module">.
          Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
            -export отмечает переменные и функции, которые должны быть доступны вне текущего модуля. export function sayHi(user) {}
            -import позволяет импортировать функциональность из других модулей. import {sayHi} from './sayHi.js';
          У модулей есть ряд особенностей:
            -Отложенное (deferred) выполнение по умолчанию.
              Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer (описан в главе Скрипты: async, defer). Это верно и для внешних и встроенных скриптов-модулей.
                -загрузка внешних модулей, таких как <script type="module" src="...">, не блокирует обработку HTML.
                -модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.
                -сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
            -Атрибут async работает во встроенных скриптах.
            -Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
            -Дублирующиеся внешние скрипты игнорируются.
        2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
          Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
          Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.
          Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.
        3. В модулях всегда включена директива use strict.
        4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.
          Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
          📁 alert.js
          alert("Модуль выполнен!");

          Импорт одного и того же модуля в разных файлах
          📁 1.js
          import `./alert.js`; // Модуль выполнен!
          📁 2.js
          import `./alert.js`; // (ничего не покажет)
          На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.
          Ещё раз заметим – модуль выполняется только один раз. Генерируется экспорт и после передаётся всем импортёрам, поэтому, если что-то изменится в объекте admin, то другие модули тоже увидят эти изменения.
          Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.
        В модуле «this» не определён
        Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.
      Экспорт
        -Экспорт до объявления
          export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        -Экспорт отдельно от объявления 
          Также можно написать export отдельно. export {sayHi, sayBye}; // список экспортируемых переменных
        -Экспортировать «как» export {sayHi as hi, sayBye as bye}; Теперь hi и bye – официальные имена для внешнего кода, их нужно использовать при импорте:
        -Экспорт по умолчанию
          На практике модули встречаются в основном одного из двух типов:
            -Модуль, содержащий библиотеку или набор функций, как say.js выше.
            -Модуль, который объявляет что-то одно, например модуль user.js экспортирует только class User. (default export)
          export default class User {} Заметим, в файле может быть не более одного export default. …И потом импортируем без фигурных скобок: import User from './user.js'; // не {User}, просто User
          Так как в файле может быть максимум один export default, то экспортируемая сущность не обязана иметь имя.
            экспортируем значение, не создавая переменную export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; Это нормально, потому что может быть только один export default на файл, так что import без фигурных скобок всегда знает, что импортировать.
          Имя «default»
            чтобы экспортировать функцию отдельно от её объявления: export {sayHi as default};
      Импорт
        Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так: import {sayHi, sayBye} from './say.js';
        Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например: import * as say from './say.js'; 
          1. Предположим, мы добавили в наш проект стороннюю библиотеку say.js с множеством функций: Теперь, если из этой библиотеки в проекте мы используем только одну функцию:
            …Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
          2. Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: sayHi() вместо say.sayHi().
          3. Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.
        Импорт «как» 
          Мы также можем использовать as, чтобы импортировать под другими именами. import {sayHi as hi, sayBye as bye} from './say.js';
    ?Know how to use spread operator for Function arguments
      Остаточные параметры (Rest parameters)
        Остаточные параметры предоставляют нам массив неопределённых аргументов. В примере мы используем остаточные параметры, чтобы собрать аргументы с индексами со 2-го до последнего. 
        Затем мы умножим каждый из них на значение первого аргумента. В этом примере используется стрелочная функция (Arrow functions), о которой будет рассказано в следующей секции.
        */
        function multiply(multiplier, ...theArgs) {
          return theArgs.map(x => multiplier * x);
        }
        
        var arr = multiply(2, 1, 2, 3);
        console.log(arr); // [2, 4, 6]
        /*
    ?Be able to compare arguments and rest parameters
      Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments. Этот способ всё ещё работает, мы можем найти его в старом коде.
      Но у него есть один недостаток. Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).
      К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.
      Соответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.
      Стрелочные функции не имеют "arguments"
    ?Spread operator for Array
      Оператор расширения
        Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное. Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.
        Для Math.max:
        */
        let arr = [3, 5, 1];
        alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
        // Мы даже можем комбинировать оператор расширения с обычными значениями:
        let arr1 = [1, -2, 3, 4];
        let arr2 = [8, 3, -8, 1];
              
        alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
        /*
    ?Understand and able to use spread operator for Array concatenation Destructuring assignment
      Оператор расширения можно использовать и для слияния массивов:
      */
      let arr = [3, 5, 1];
      let arr3 = [8, 9, 15];
      let merged = [0, ...arr, 2, ...arr3]; // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
      /*
      В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.
      Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:
      */
      let str = "Привет";
      alert( [...str] ); // П,р,и,в,е,т
      /*
      Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, чтобы перебирать элементы. Так же, как это делает for..of.
      Цикл for..of перебирает строку как последовательность символов, поэтому из ...str получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи стандартного объявления массива: [...str].
      Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив: Array.from(str)
        Но между Array.from(obj) и [...obj] есть разница: 
          -Array.from работает как с псевдомассивами, так и с итерируемыми объектами 
          -Оператор расширения работает только с итерируемыми объектами
      Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.
        Как отличить их друг от друга:
          Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
          Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
    ?Be able to discover destructuring assignment concept
      Деструктурирующее присваивание
          Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.
          Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
        Деструктуризация массива
          у нас есть массив с именем и фамилией let arr = ["Ilya", "Kantor"] деструктурирующее присваивание записывает firstName = arr[0]  и surname = arr[1] let [firstName, surname] = arr;
          Отлично смотрится в сочетании со split или другими методами, возвращающими массив: let [firstName, surname] = "Ilya Kantor".split(' ');
          -Деструктуризация» не означает «разрушение».
            «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.
            Это просто короткий вариант записи: let firstName = arr[0]; let surname = arr[1];
          -Пропускайте элементы, используя запятые: 
            Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой: let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
          -Работает с любым перебираемым объектом с правой стороны
            На самом деле мы можем использовать любой перебираемый объект, не только массивы: let [a, b, c] = "abc";  let [one, two, three] = new Set([1, 2, 3]);
          -Присваивайте чему угодно с левой стороны
            Мы можем использовать что угодно «присваивающее» с левой стороны. Например, можно присвоить свойству объекта: let user = {}; [user.name, user.surname] = "Ilya Kantor".split(' ');
          -Цикл с .entries()
            Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:
            */
            let user = {
              name: "John",
              age: 30
            };
            
            // цикл по ключам и значениям
            for (let [key, value] of Object.entries(user)) {
              alert(`${key}:${value}`); // name:John, затем age:30
            }
            /*
          -Трюк обмена переменных
            Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего присваивания: 
              let guest = "Jane"; let admin = "Pete"; [guest, admin] = [admin, guest];
              Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.Таким образом, мы можем поменять местами даже более двух переменных.
          -Остаточные параметры «…»
            Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):
            let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]; Переменная rest является массивом из оставшихся элементов.
          -Значения по умолчанию
            Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:
            Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =: let [name = "Guest", surname = "Anonymous"] = ["Julius"];
            Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют. let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
        Деструктуризация объекта
          let {var1, var2} = {var1:…, var2:…} У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}. 
              let {title, width, height} = options; Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения.
            -Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
              Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие: let {width: w, height: h, title} = options; // width -> w // height -> h // title -> title
              Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.
            -Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь: let {width = 100, height = 200, title} = options;
              Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.
            -Мы также можем совмещать : и =:
              let {width: w = 100, height: h = 200, title} = options;
          -Остаток объекта «…»
            Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
            let options = {
              title: "Menu",
              height: 200,
              width: 100
            };
            let {title, ...rest} = options;
            сейчас title="Menu", rest={height: 200, width: 100}
              В примерах выше переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох.
                Вот так не будет работать:
                  let title, width, height;
                  {title, width, height} = {title: "Menu", width: 200, height: 100};
                  Проблема в том, что JavaScript обрабатывает {...} в основном потоке кода (не внутри другого выражения) как блок кода. Такие блоки кода могут быть использованы для группировки операторов.
                  Так что здесь JavaScript считает, что видит блок кода, отсюда и ошибка. На самом-то деле у нас деструктуризация.  Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки (...):
                  ({title, width, height} = {title: "Menu", width: 200, height: 100});
          -Вложенная деструктуризация
            Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.
        Умные параметры функций
          Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов.  На помощь приходит деструктуризация!
          Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
            */
              // мы передаём объект в функцию
              let options = {
                title: "My menu",
                items: ["Item1", "Item2"]
              };

              // ...и она немедленно извлекает свойства в переменные
              function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
                // title, items – взято из options,
                // width, height – используются значения по умолчанию
                alert( `${title} ${width} ${height}` ); // My Menu 200 100
                alert( items ); // Item1, Item2
              }

              showMenu(options);
            /*
            Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
            showMenu({}); // ок, все значения - по умолчанию  showMenu(); // так была бы ошибка
            Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {}
            В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.
    ?Understand variables and Function arguments destructuring assignment
      См выше
    ?String templates
      Шаблонные строки
        Шаблонные строки — это ещё один способ создания строк, наравне с одинарными или двойными кавычками. Шаблонные строки объявляются с помощью обратных кавычек.
        Шаблонная строка может быть многострочной, все переносы строк в ней будут сохранены. В шаблонной строке с помощью синтаксиса ${ } можно использовать любые выражения JavaScript. Любой нестроковый результат (например, объект) будет приведён к строке.
        `строка текста ${выражение} строка текста`
      Экранирование символов
        const doubleQuotes = "\"Я вам запрещаю!\" – Джейсон Стэтхем." => const doubleQuotes = `"Я вам запрещаю!" – Джейсон Стэтхем.`
      Переносы строк Секция статьи "Переносы строк"
        const str = 'Я первая строка\n' + 'А я вторая строка\n' + 'Ну и так далее'
        Выглядит не очень удобно, даже если записать их на отдельных строках в редакторе. В шаблонных строках можно делать переносы строк, как в обычном тексте, и все они сохранятся.
        В этой строке будут так же сохранены все пробелы и табуляции в начале строк. Это может быть удобно для написания html-разметки в строке.
      Динамические строки
        В обычных строках, чтобы подставить значение в строку, необходимо использовать конкатенацию через оператор +. const url = 'https://' + host + '/?search=' + query
        В итоге получается нужная нам строка, но для каждого такого динамического значения необходимо явно добавлять оператор сложения + и дробить строку на части, если между динамическими частями есть статические.
        const url = `https://${host}/?search=${query}`
      Будьте осторожны при написании HTML внутри шаблонных строк. Шаблонные строки, так же как и обычные, не экранируют спецсимволы. Это значит что использование ненадёжного HTML из шаблонной строки может привести к различным атакам.
    ?Know how for..of loop works (optional)
      Оператор for...of относится к типу оператора for, который циклически повторяет итерируемые объекты ( iterable objects)), пока не достигнет конца строки. for(let a of arr) {log(a)}
        Цикл for...of через массив arr выполнен с меньшим количеством кода, чем при использовании цикла for.
      Итерируемые объекты и итераторы
        По словам разработчика Mozilla, “Благодаря итерируемому протоколу объекты JavaScript могут определять или настраивать поведение итерации, например, какие значения повторяются циклически в конструкции for..of.” и “чтобы быть итерируемым, 
        объект реализует метод @@iterator, означающий, что объект (или один из объектов в цепочке прототипов) должен иметь свойство с ключом @@iterator, которое доступно через константу Symbol.iterator.”
        Протокол Iterator определяет способ, с помощью которого поток значений возвращается из объекта. Итератор реализует метод next. Метод next обладает следующим рядом правил:
          -Он должен возвращать объект со свойствами done, value {done, value}
          -done относится к типу Boolean и указывает на достижение конца потока.
          -value содержит значение текущего цикла.
      Примеры итерируемых объектов:  (String Map TypedArray Array Set Generator) Объект не является итерируемым. Если использовать цикл через свойства объекта с помощью конструкции for…of:
  +Advanced Functions
    ?this scope
      В JavaScript this — это текущий контекст исполнения функции. Поскольку функцию можно вызвать четырьмя способами:
        -вызов функции: alert('Hello World!'),
        -вызов метода: console.log('Hello World!'),
        -вызов конструктора: new RegExp('\\d'),
        -непрямой вызов: alert.call(undefined, 'Hello World!'),
        и каждый из них определяет свой контекст, поведение this слегка не соответствует ожиданиям начинающих разработчиков. Кроме того, strict mode также влияет на контекст исполнения.
      Прежде чем мы начнём, давайте познакомимся с несколькими терминами:
        -Вызов — это исполнение кода тела функции. Например, вызовом функции parseInt будет parseInt('15').
        -Контекстом вызова является значение this в теле функции.
        -Область видимости функции — это набор переменных, объектов и функций, к которым можно получить доступ из тела функции.
      Вызов функции
        Вызов функции совершается, когда за выражением, являющимся объектом функции, следуют открывающая скобка (, разделённый запятыми список аргументов и закрывающая скобка ), например, parseInt('18').
        Выражение не может быть аксессором myObject.myFunction, который совершает вызов метода. Например, [1,5].join(',') — это вызов не функции, а метода.
        this при вызове функции
          this — это глобальный объект при вызове функции. Глобальный объект определяется средой исполнения. В веб-браузере это объект window. В вызове функции контекстом исполнения является глобальный объект.
          Когда this используется вне области видимости какой-либо функции (самая внешняя область видимости: контекст глобального исполнения), он также относится к глобальному объекту: console.log(this === window); // => true
        this при вызове функции в strict mode
          Strict mode был введён в ECMAScript 5.1 и представляет собой более надёжную систему защиты и проверки ошибок. Этот режим влияет на контекст исполнения, заставляя this быть undefined. Контекст исполнения перестаёт быть глобальным объектом, в отличие от предыдущего случая.
          Strict mode активен не только в текущей области видимости, но и во всех вложенных: 
          Один файл JavaScript может содержать как «строгие», так и «нестрогие» функции. Поэтому возможно иметь в одном скрипте разные контексты исполнения для одного типа вызова:
        Ловушка: this во внутренней функции
          Обычной ошибкой при работе с вызовом функции является уверенность в том, что this во внутренней функции такой же, как и во внешней. Вообще-то контекст внутренней функции зависит только от вызова, а не от контекста внешней функции.
          Чтобы получить ожидаемый this, модифицируйте контекст внутренней функции при помощи непрямого вызова (используя .call() или .apply(), об этом позже) или создайте связанную функцию (используя .bind(), об этом тоже поговорим позже).
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                // this is window or undefined in strict mode
                console.log(this === numbers); // => false
                return this.numberA + this.numberB;
              }
              return calculate();
            }
          };
         console.log(numbers.sum()); // => NaN or throws TypeError in strict mode
          /*
          numbers.sum() — это вызов метода объекта, поэтому контекстом sum является объект numbers. Функция calculate определена внутри sum, поэтому вы можете ожидать, что this — это объект numbers и в calculate(). 
          Тем не менее, calculate() — это вызов функции, а не метода, и поэтому его this — это глобальный объект window или undefined в strict mode. Даже если контекстом внешней функции sum является объект numbers, у него здесь нет власти.
          Для решения проблемы функция calculate должна быть исполнена в том же контексте, что и метод sum, чтобы получить доступ к значениям numberA и numberB. Это можно сделать при помощи метода .call():
          */
          var numbers = {
            numberA: 5,
            numberB: 10,
            sum: function() {
              console.log(this === numbers); // => true
              function calculate() {
                console.log(this === numbers); // => true
                return this.numberA + this.numberB;
              }
              // use .call() method to modify the context
              return calculate.call(this);
            }
          };
         console.log(numbers.sum()); // => 15
          /* calculate.call(this) исполняет функцию calculate, но дополнительно модифицирует контекст в соответствии с первым параметром.
        Вызов метода
          Метод — это функция, хранящаяся в объекте. helloFunction — это метод в myObject. Для доступа к методу нужно использовать аксессор: myObject.helloFunction.
          Вызов метода совершается, когда за выражением в виде аксессора, расценивающемся как объект функции, следует пара скобок и разделенный запятыми список аргументов между ними.
          В прошлом примере myObject.helloFunction() — это вызов метода helloFunction объекта myObject. Также вызовами метода являются: [1, 2].join(',') или /\s/.test('beautiful world').
          Важно отличать вызов функции от вызова метода. Главным отличием является то, что для вызова метода необходим аксессор (<expression>.functionProperty() или <expression>['functionProperty']()), а для вызова функции — нет (<expression>()).
          this при вызове метода
            this — это объект, которому принадлежит метод. При вызове метода, принадлежащего объекту, this становится этим объектом.
            Вызов calc.increment() сделает контекстом функции increment объект calc. Поэтому можно спокойно использовать this.num.
            Объект JavaScript наследует метод своего прототипа. Когда вызывается метод, унаследованный от объекта, контекстом всё равно является сам объект:
            */
            var myDog = Object.create({
              sayName: function() {
                 console.log(this === myDog); // => true
                  return this.name;
              }
            });
            myDog.name = 'Milo';
            // method invocation. this is myDog
            console.log(myDog.sayName()); // => 'Milo'
            /*
            Object.create() создаёт новый объект myDog и создаёт прототип. Объект myDog наследует метод sayName. Когда исполняется myDog.sayName(), myDog является контекстом исполнения.
            В синтаксисе ECMAScript 6 class контекст вызова метода — тоже сам объект:
           */
            class Planet {
              constructor(name) {
                this.name = name;
              }
              getName() {
                console.log(this === earth); // => true
                return this.name;
              }
            }
            var earth = new Planet('Earth');
            // method invocation. the context is earth
            console.log(earth.getName()); // => 'Earth'
            /*
          Ловушка: отделение метода от его объекта
            Метод объекта можно переместить в отдельную переменную. При вызове метода с использованием этой переменной вы можете подумать, что this — это объект, в котором определён метод.
            На самом деле, если метод вызван без объекта, происходит вызов функции, и this становится глобальным объектом window или undefined. Создание связанной функции исправляет контекст — им становится объект, в котором содержится метод.
            Следующий пример создаёт конструктор Animal и его экземпляр — myCat. Затем через 1 секунду setTimeout() логирует информацию об объекте myCat:
            */
            function Animal(type, legs) {
              this.type = type;
              this.legs = legs;
              this.logInfo = function() {
                console.log(this === myCat); // => false
                console.log('The ' + this.type + ' has ' + this.legs + ' legs');
              };
            }
            var myCat = new Animal('Cat', 4);
            // logs "The undefined has undefined legs"
            // or throws a TypeError, in strict mode
            setTimeout(myCat.logInfo, 1000); // setTimeout(myCat.logInfo.bind(myCat), 1000);
            /*
            Вы можете подумать, что setTimeout вызовет myCat.logInfo(), которая запишет информацию об объекте myCat. Но метод отделяется от объекта, когда передаётся в качестве параметра: setTimout(myCat.logInfo), и через секунду происходит вызов функции.
            Когда logInfo вызывается как функция, this становится глобальным объектом или undefined (но не объектом myCat), поэтому информация об объекте выводится некорректно. 
            myCat.logInfo.bind(myCat) возвращает новую функцию, исполняемую в точности как logInfo, но this которой остаётся myCat даже в случае вызова функции.
          Вызов конструктора
            Вызов конструктора совершается, когда за ключевым словом new следует выражение, расцениваемое как объект функции, и пара скобок с разделённым запятыми списком аргументов. Пример: new RegExp('\\d').
            В этом примере объявляется функция Country, которая затем вызывается в качестве конструктора:
            */
            function Country(name, traveled) {
              this.name = name ? name : 'United Kingdom';
              this.traveled = Boolean(traveled); // transform to a boolean
            }
            Country.prototype.travel = function() {
              this.traveled = true;
            };
           // Constructor invocation
            var france = new Country('France', false);
           // Constructor invocation
            var unitedKingdom = new Country;
            
           france.travel(); // Travel to France
            /*
            new Country('France', false) — это вызов конструктора функции Country. Результатом исполнения является новые объект, чьё поле name равняется 'France'. Если конструктор вызван без аргументов, скобки можно опустить: new Country.
            Начиная с ECMAScript 6, JavaScript позволяет определять конструкторы ключевым словом class.
            */
            class City {
              constructor(name, traveled) {
                this.name = name;
                this.traveled = false;
              }
              travel() {
                this.traveled = true;
              }
            }
            // Constructor invocation
            var paris = new City('Paris', false);
            paris.travel();
            /*
            new City('Paris') — это вызов конструктора. Инициализация объекта управляется специальным методом класса: constructor, this которого является только что созданным объектом.
            Вызов конструктора создаёт новый пустой объект, наследующий свойства от прототипа конструктора. Ролью функции-конструктора является инициализация объекта. Как вы уже знаете, контекст этого типа вызова называется экземпляром.
            Когда перед аксессором myObject.myFunction идёт ключевое слово new, JavaScript совершит вызов конструктора, а не метода. Возьмём в качестве примера new myObject.myFunction(): 
            сперва при помощи аксессора extractedFunction = myObject.myFunction функция извлекается, а затем вызывается как конструктор для создания нового объекта: new extractedFunction().
            this в вызове конструктора
              this — это только что созданный объект. Контекстом вызова конструктора является только что созданный объект. Он используется для инициализации объекта данными из аргументом функции-конструктора.
              Когда исполняется new Dog(), JavaScript создаёт пустой объект и делает его контекстом метода constructor. Теперь вы можете добавлять свойства, используя this: this.property = 'Default Value'.
          Непрямой вызов
            Непрямой вызов производится, когда функция вызывается методами .call() или .apply(). Функции в JavaScript — объекты первого класса, то есть функция — это объект типа Function.
            Из списка методов этой функции два, .call() и .apply(), используются для вызова функции с настраиваемым контекстом:
              -Метод .call(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова, а список аргументов arg1, arg2, ... передаётся вызываемой функции.
              -Метод .apply(thisArg, [args]) принимает в качестве первого аргумента thisArg контекст вызова, а array-like объект [args] передаётся вызываемой функции в качестве аргумента.
              */
              function increment(number) {
                return ++number;
              }
              console.log(increment.call(undefined, 10));    // => 11
              console.log(increment.apply(undefined, [10])); // => 11
              /*
              increment.call() и increment.apply() оба вызывают функцию-инкремент с аргументом 10. Главным отличием между ними является то, что .call() принимает список аргументов, 
              например, myFunction.call(thisValue, 'value1', 'value2'), а .apply() принимает эти значения в виде array-like объекта: myFunction.apply(thisValue, ['value1', 'value2']).
              this при непрямом вызове
                this — это первый аргумент .call() или .apply()
              Непрямой вызов может пригодиться, когда функцию нужно вызвать в особом контексте, например, решить проблему при вызове функции, где this — всегда window или undefined. Его также можно использовать для симуляции вызова метода объекта.
          Связанная функция
            Связанная функция — это функция, связанная с объектом. Обычно она создаётся из обычной функции при помощи метода .bind(). У двух функций совпадают тела и области видимости, но различаются контексты.
            Метод .bind(thisArg[, arg1[, arg2[, ...]]]) принимает в качестве первого аргумента thisArg контекст вызова связанной функции, а необязательный список аргументов arg1, arg2, ... передаётся вызываемой функции. Он возвращает новую функцию, связанную с thisArg.
            Следующий код создаёт связанную функцию и вызывает её:
            */ 
            function multiply(number) {
              'use strict';
              return this * number;
            }
            // create a bound function with context
            var double = multiply.bind(2);
            // invoke the bound function
            console.log(double(3));  // => 6
            console.log(double(10)); // => 20
            /*
            multiply.bind(2) возвращает новый объект функции double, который связан с числом 2. Код и область видимости у multiply и double совпадают. В отличие от методов .apply() и .call(), сразу вызывающих функцию, метод .bind() возвращает новую функцию, которую впоследствии нужно будет вызвать с уже заданным this.
            this в связанной функции
              this — это первый аргумент .bind() Ролью .bind() является создание новой функции, чей вызов будет иметь контекст, заданный в первом аргументе .bind(). Это — мощный инструмент, позволяющий создавать функции с заранее определённым значением this.
              */
              var numbers = {
                array: [3, 5, 10],
                getNumbers: function() {
                  return this.array;
                }
              };
              // Create a bound function
              var boundGetNumbers = numbers.getNumbers.bind(numbers);
              console.log(boundGetNumbers()); // => [3, 5, 10]
              // Extract method from object
              var simpleGetNumbers = numbers.getNumbers;
              console.log(simpleGetNumbers()); // => undefined or throws an error in strict mode
              /*
              numbers.getNumbers.bind(numbers) возвращает функцию boundGetNumbers, которая связана с объектом numbers. Затем boundGetNumbers() вызывается с this, равным numbers, и возвращает корректный объект.
          Стрелочная функция
            Стрелочная функция не создаёт свой контекст исполнения, а заимствует this из внешней функции, в которой она определена. 
            */
            class Point {
              constructor(x, y) {
                this.x = x;
                this.y = y;
              }
              log() {
                console.log(this === myPoint);
                setTimeout(()=> {
                  console.log(this === myPoint);      // => true
                  console.log(this.x + ':' + this.y); // => '95:165'
                }, 1000);
              }
            }
            var myPoint = new Point(95, 165);
            myPoint.log();
            /*
            setTimeout вызывает стрелочную функцию в том же контексте (метод myPoint), что и метод log(). Как мы видим, стрелочная функция «наследует» контекст той функции, в которой определена.
            Если попробовать использовать в этом примере обычную функцию, она создаст свой контекст (window или undefined). Поэтому для того, чтобы код работал корректно, нужно вручную привязать контекст: setTimeout(function() {...}.bind(this)). Это громоздко, поэтому проще использовать стрелочную функцию.
            Если стрелочная функция определена вне всех функций, её контекст — глобальный объект. Стрелочная функция связывается с лексическим контекстом раз и навсегда. this нельзя изменить даже при помощи метод смены контекста:
            Ловушка: определение метода стрелочной функцией
              Вы можете захотеть использовать стрелочную функцию для объявления метода. Справедливо: их объявления гораздо короче по сравнению с обычным выражением: (param) => {...} вместо function(param) {..}.
              Так как format — стрелочная функция, определённая в глобальном контексте, её this — это объект window. Даже если format исполняется в качестве метода объекта walkPeriod.format(), window остаётся контекстом вызова. Так происходит, потому что стрелочная функция имеет статический контекст, не изменяемый другими типами вызовов.
              this — это window, поэтому this.hours и this.minutes становятся undefined. Метод возвращает строку 'undefined hours and undefined minutes', что не является желаемым результатом.
          Заключение 
            Поскольку вызов функции имеет наибольшее влияние на this, отныне не спрашивайте: Откуда берется this?  а спрашивайте: Как функция вызывается? А в случае со стрелочной функцией спросите: Каков this там, где объявлена стрелочная функция?
    ?Reference Type & losing this
    ?Understand difference between function and method
    ?Understand how this works, realize this possible issues
    ?Manage this scope
    ?Be able to replace this scope
    ?Be able to use call and apply Function built-in methods

  +Functional Patterns
    ?Immediately invoked functional expression (IIFE) (optional)
      IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.
        (function () {
        statements
        })();
        Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. 
        Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
        Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.
      Функция становится мгновенно выполняющимся функциональным выражением. Переменные внутри функции не могут быть использованы за пределами её области видимости.
      Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.
      */
      var result = (function () {
        var name = "Barry";
        return name;
      })();
      // Immediately creates the output:
      result; // "Barry"
      /*
    ?Know IIFE pattern (optional)
      Управлять областью видимости переменных в JavaScript можно, пользуясь паттерном «Модуль». Для того чтобы создать приватную область видимости, можно воспользоваться замыканием. Как известно, функции создают собственные области видимости, содержимое которых отделено от глобальной области видимости:
        (function () {
         // здесь находится приватная область видимости
        })();
        Подобные функции удобно использовать для того, чтобы решить некую задачу, которую нужно решить лишь один раз, не оставляя при этом ничего лишнего в глобальной области видимости. Внутри этой функции (как, впрочем, и внутри других функций) создаётся приватная область видимости, недоступная извне. 
        То есть, если объявить внутри этой области видимости другую функцию, то, после того, как IIFE выполнится, доступ к ней получить не удастся.
      Как сделать так, чтобы к функции, объявленной внутри другой функции, всё же, можно было бы обратиться? Собственно говоря, то, о чём мы сейчас будем говорить, и есть паттерн «Модуль». Рассмотрим следующий пример.
      Объект, возвращаемый из IIFE — это обычный объект, у которого может быть множество методов и свойств. Они формируют общедоступный интерфейс или API модуля.
      */
      // Объявим модуль
      var Module = (function () {
        return {
          myMethod: function () {
          
          },
          someOtherMethod: function () {
          
          }
        };
      })();
      
      // Вызовем функцию как метод объекта
      Module.myMethod();
      Module.someOtherMethod();
      /*
    ?Callback (Function as argument)
      Фу́нкция вы́сшего поря́дка — в программировании функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. 
      Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных. Использование функций высшего порядка приводит к абстрактным и компактным программам, принимая во внимание сложность производимых ими вычислений.[1]
      Функции — это объекты
        Чтобы понимать callback-функции, нужно понимать обычные функции. Это может показаться банальностью, но функции в Javascript'е — немного странные штуки.
        Функции в Javascript'е — на самом деле объекты. А именно, объекты класса Function, создаваемые конструктором Function. В объекте Function содержится строка с JS-кодом данной функции. 
        Если вы перешли с языка C или Java, это может показаться странным (как код может быть строкой?!), но, вообще говоря, в Javascript'е такое сплошь и рядом. Различие между кодом и данными иногда размывается.
        Преимущество концепции «функция-как-объект» заключается в том, что код можно передавать в другую функцию точно так же, как обычную переменную или объект (потому что в буквальном понимании код — всего лишь объект).
        Вместо того чтобы дожидаться, пока функция закончит выполняться и вернёт значение, мы можем использовать callback-функции, чтобы получить его асинхронно. Это полезно для случаев, когда требуется много времени для завершения, например, при AJAX-запросах, ведь мы не можем приостановить браузер.
    ?Know callback pattern
    ?Understand callback limitations (callback hell) (optional)
      Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо ... у нас код, содержащий другие цепочки вызовов, условия и т.д. Иногда это называют «адом колбэков» или «адской пирамидой колбэков».
    ?Binding, binding one function twice
      bind returns a new function which keeps the context of the original function intact when called. In essence it does this:
      */
      function bind(originalFunction, context) {
        return function () {
            originalFunction.call(context);
        };
      }
      /*
    ?Know how to bind this scope to function
      */
    let user55 = {
      firstName: "Вася"
    };
    
    function func() {
      alert(this.firstName);
    }
    
    let funcUser = func.bind(user55);
    funcUser(); // Вася
    /*
    Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user. Все аргументы передаются исходному методу func как есть
    ?Carrying and partial functions
      Каррирование – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках. Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
        Каррирование не вызывает функцию. Оно просто трансформирует её.
        */
        function curry(f) { // curry(f) выполняет каррирование
          return function(a) {
            return function(b) {
              return f(a, b);
            };
          };
        }
        // использование
        function sum(a, b) {
          return a + b;
        }

        let curriedSum = curry(sum);

        alert( curriedSum(1)(2) ); // 3
        /*
        Как вы видите, реализация довольна проста: это две обёртки.
        Результат curry(func) – обёртка function(a).
        Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
        Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.
      Что такое каррирование? 
        Каррированная функция - это функция, которая может принимать несколько аргументов, но по одному за раз. Способность принимать по одному аргументу за раз, называется унарностью. Унарность, это обязательное свойство каррированных функций.
      Что такое частичное применение?
        Частичное применение - это функция, которая принимает за раз столько аргументов, сколько пожелает, но не все. Все каррированные функции возвращают частичное применение, для хранения введенных аргументов.
        */
        const add = x => y => x + y;
        const inc10 = add(10);
        const inc20 = add(20);

        inc10(3); // => 13
        inc20(3); // => 23
        /*
  +Network requests
    ?Fetch (with usage)
      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
        По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера
        Типичный запрос с помощью fetch состоит из двух операторов await:
          */
        let response = await fetch(url, options); // завершается с заголовками ответа
        let result = await response.json(); // читать тело ответа в формате JSON
        /*
        Или, без await:
        */
        fetch(url, options)
          .then(response => response.json())
          .then(result => {/* обрабатываем результат */});
        /*
        Параметры ответа:
          response.status – HTTP-код ответа,
          response.ok – true, если статус ответа в диапазоне 200-299.
          response.headers – похожий на Map объект с HTTP-заголовками.
        Методы для получения тела ответа:
          response.text() – возвращает ответ как обычный текст,
          response.json() – преобразовывает ответ в JSON-объект,
          response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
          response.blob() – возвращает объект как Blob (бинарные данные с типом),
          response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
        Опции fetch, которые мы изучили на данный момент:
          method – HTTP-метод,
          headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
          body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
    ?XMLHTTPRequest (concept) (optional)
      XMLHttpRequest – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.
      В современной веб-разработке XMLHttpRequest используется по трём причинам:
        -По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.
        -Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).
        -Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.
      Типичный код GET-запроса с использованием XMLHttpRequest:
      */
      let xhr = new XMLHttpRequest();

      xhr.open('GET', '/my/url');
      
      xhr.send();
      
      xhr.onload = function() {
        if (xhr.status != 200) { // HTTP ошибка?
          // обработаем ошибку
          alert( 'Ошибка: ' + xhr.status);
          return;
        }
      
        // получим ответ из xhr.response
      };
      
      xhr.onprogress = function(event) {
        // выведем прогресс
        alert(`Загружено ${event.loaded} из ${event.total}`);
      };
      
      xhr.onerror = function() {
        // обработаем ошибку, не связанную с HTTP (например, нет соединения)
      };
      /*
    ?WebSocket (concept) (optional)
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. 
        Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
      WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws: let socket = new WebSocket("ws://javascript.info");
      WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.
        -Нет ограничений, связанных с кросс-доменными запросами.
        -Имеют хорошую поддержку браузерами.
        -Могут отправлять/получать как строки, так и бинарные данные.
      
  +Web components
    ?Web components, shadow DOM (concept) (optional)
      Веб-компоненты
        Веб-компоненты - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях.
        Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
        Модель веб-компонентов подразумевает инкапсуляцию и совместимость отдельных HTML-элементов.
        На данный момент частичная поддержка существует в браузерах Chrome, Firefox, Opera и Safari. Для браузеров не поддерживающих веб-компоненты реализованы полифилы.
          -Веб-компоненты включают три технологии, каждая из которых может использоваться отдельно от других:
          -Custom Elements — API для создания собственных HTML элементов.
          -HTML Templates — тег <template> позволяет реализовывать изолированные DOM-элементы.
          -Shadow DOM — изолирует DOM и стили в разных элементах.

  +Date & time
    ?Timezones (optional)
      Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после "get" вставляется "UTC".
      Если ваше локальное время сдвинуто относительно UTC, то следующий код покажет разные часы:
        // текущая дата
        var date = new Date();
        // час в текущей временной зоне
        alert( date.getHours() );
        // сколько сейчас времени в Лондоне?
        // час в зоне GMT+0
        alert( date.getUTCHours() );
      Кроме описанных выше, существуют два специальных метода без UTC-варианта:
        getTimezoneOffset()
        Возвращает разницу между местным и UTC-временем, в минутах.
        alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60
    ?Internationalization js (Intl) (optional)
      Общая проблема строк, дат, чисел в JavaScript – они «не в курсе» языка и особенностей стран, где находится посетитель.
        Строки
          При сравнении сравниваются коды символов, а это неправильно, к примеру, в русском языке оказывается, что "ё" > "я" и "а" > "Я", хотя всем известно, что я – последняя буква алфавита и это она должна быть больше любой другой.
        Даты
          В разных странах принята разная запись дат. Где-то пишут 31.12.2014 (Россия), а где-то 12/31/2014 (США), где-то иначе.
        Числа
          В одних странах выводятся цифрами, в других – иероглифами, длинные числа разделяются где-то пробелом, где-то запятой.
        Все современные браузеры, кроме IE10 (но есть библиотеки и для него) поддерживают стандарт ECMA 402, предназначенный решить эти проблемы навсегда.
      Основные объекты
        Intl.Collator - Умеет правильно сравнивать и сортировать строки.
        Intl.DateTimeFormat - Умеет форматировать дату и время в соответствии с нужным языком.
        Intl.NumberFormat - Умеет форматировать числа в соответствии с нужным языком.
      Локаль
        Локаль – первый и самый важный аргумент всех методов, связанных с интернационализацией. Локаль описывается строкой из трёх компонентов, которые разделяются дефисом:
          -Код языка.
          -Код способа записи.
          -Код страны.
        Все методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения. Если локаль не указана или undefined – берётся локаль по умолчанию, установленная в окружении (браузере).
  +Closures Advanced
    https://learn.javascript.ru/closure#leksicheskoe-okruzhenie
    ?Context (lexical environment)
      Контекст выполнения (Execution Context)
          Контекст выполнения - это среда, в которой выполняется оценка текущего кода.
          Так как Javascript является однопоточным (single-threaded), в любой момент времени может быть запущен только один контекст выполнения!
          Каждый раз, когда запускаем функцию, мы добавляем скобки {}, а затем выполняем или запускаем её.
          */
         // глобальный контекст выполнения
        function printMyName () {
          // новый контекст выполнения
          return `Alex`;
        }

        function sayMyName () {
          // новый контекст выполнения
          return printMyName();
        }

        sayMyName();

        // глобальный контекст выполнения
          /*
        Как только движок JavaScript увидит эти скобки {}, он создаст контекст выполнения.
        Первое, что сделает движок JavaScript - создаст глобальный контекст выполнения, и тем самым даст нам две вещи: глобальный объект (global object), и ключевое слово this. В браузере глобальный объект и this являются window.
        У нас есть доступ к этим двум вещам, потому что браузер создал для нас глобальный контекст выполнения. Это самый первый шаг, который движок JavaScript делает для нас и эти два объекта будут равны друг другу.
        Если мы используем что-то вроде NodeJS, глобальный объект не будет window. Вместо этого он будет называться global.
        Поэтому, как только в нашем движке JavaScript будет сделана первая фаза - фаза создания, наступит вторая - фаза исполнения, в которой мы, фактически, запустим наш код.
    Лексическая среда (Lexical Environment)
      Лексическая среда означает, место где код был написан. Каждый раз, когда мы создаем контекст выполнения, он проверяет, где были написаны слова (функции) и их местоположение.
      Если у нас функция, которая объявлена внутри другой функции printMyName, вторая функция написана в другой лексической среде - лексической среды первой функции printMyName.
      */
      // глобальная лексическая среда
      function printMyName() {
        // лексическая среда функции printMyName
        function() {
            console.log('Alex')
        }
      }
      /*
      Мне нравится думать об этом так: в javascript каждый раз, когда у нас есть функция, она создает для нас новый “мир” внутри этой функции. Мы попадаем в этот “мир” каждый раз, когда добавляем его в стек вызовов, и внутри этого “мира” мы можем делать разные вещи, иметь разную информацию. \
      Также, эти “миры” могут общаться друг с другом по-разному. Контекст выполнения говорит нам, какая лексическая среда работает в данный момент.
      Лексическая среда - это место, в котором написан код. Таким образом лексическая область (lexical scope), представляет собой доступные данные и переменные, для которых была определена функция. То есть то место, где мы пишем функцию, определяет являются ли доступные ей переменные. 
      Так что важно где мы создаем функцию, а не где мы её вызываем.
      Заключение
        -лексическая среда означает, место где код был написан;
        -глобальная среда является родительской средой для всех других сред, созданных в коде;
        -в браузере глобальная среда называется window;
        -в NodeJS глобальная среда называется global.
    ?Understand function creation context (lexical environment)
    ?Be able to explain difference between scope and context
      Scope – область видимости. Область видимости определяет, есть ли у вас доступ к переменной. До введения let и const область видимости в JavaScript определялась функцией (у var функциональная область видимости). Переменные объявленные вне функции записывались в глобальную область видимости.
      Context – контекст выполнения (this) Контекст описывает окружение в котором выполняется код (любой код имеет контекст выполнения). В каждый момент времени только один контекст выполнения выполняет код. Несколько популярных видов контекста:
        -Global контекст 
        -Function контекст
        -Стрелочные функции
        -В методе объекта
        -В конструкторе
        -В методах call, apply и bind
        В браузере:
        -Как обработчик событий DOM 
        -В инлайновом обработчике событий
      Одна и та же функция может быть вызвана с разным контекстом. Контекстом еще часто называют значение переменной this внутри функции.  Значение переменной this чаще всего определяется тем, как вызывается функция. 
    ?Inner/outer lexical environment
      У внутреннего лексического окружения есть ссылка outer на внешнее. Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального. 
      Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
    ?Understand lexical environment traversing mechanism
    ?Understand connection between function and lexical environment

  +Object Oriented Programming
    ?new keyword
      Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее. Это можно сделать при помощи функции-конструктора и оператора "new".
    ?Understand how new keyword works
    ?Function constructor
      Функция-конструктор
        Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
          -Имя функции-конструктора должно начинаться с большой буквы.
          -Функция-конструктор должна выполняться только с помощью оператора "new".
      Когда функция вызывается как new User(...), происходит следующее: 
        1. Создаётся новый пустой объект, и он присваивается this.
        2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
        3. Возвращается значение this.
    ?Know function constructor concept
    ?Able to create constructor functions
    */
    function User(name) {
      // this = {};  (неявно)
    
      // добавляет свойства к this
      this.name = name;
      this.isAdmin = false;
    
      // return this;  (неявно)
    }
    /*
    Это и является основной целью конструкторов – реализовать код для многократного создания однотипных объектов.
    ?Public, private, static members
      Публичные поля классов
        Новый синтаксис для публичных полей позволяет упростить определение класса:
        */
        class IncreasingCounter {
          _count = 0;
          get value() {
            console.log('Getting the current value!');
            return this._count;
          }
          increment() {
            this._count++;
          }
        }
        /*
        Свойство _count теперь лаконично объявлено в начале класса. Нам больше не нужен конструктор только для того, чтобы определить некоторые поля. Отлично!
      Приватные поля классов
        Именно здесь на помощь приходят приватные поля. Новый синтаксис для приватных полей схож с синтаксисом публичных полей, за исключением того, что Вы помечаете их как приватные, используя символ #. Вы можете думать, что # — это просто часть имени поля:
        */
        class IncreasingCounter {
          #count = 0;
          get value() {
            console.log('Getting the current value!');
            return this.#count;
          }
          increment() {
            this.#count++;
          }
        }
        // Приватные поля недоступны вне тела класса:
        const counter = new IncreasingCounter();
        counter.#count;
        // → SyntaxError
        counter.#count = 42;
        // → SyntaxError
        /*
      Статические свойства
        Синтаксис полей классов может быть использован для создания публичных и приватных статических свойств и методов, как показано ниже:
        */
        class FakeMath {
          // `PI` is a static public property.
          static PI = 22 / 7; // Close enough.
        
          // `#totallyRandomNumber` is a static private property.
          static #totallyRandomNumber = 4;
        
          // `#computeRandomNumber` is a static private method.
          static #computeRandomNumber() {
            return FakeMath.#totallyRandomNumber;
          }
        
          // `random` is a static public method (ES2015 syntax)
          // that consumes `#computeRandomNumber`.
          static random() {
            console.log('I heard you like random numbers…')
            return FakeMath.#computeRandomNumber();
          }
        }
        
        FakeMath.PI;
        // → 3.142857142857143
        FakeMath.random();
        // logs 'I heard you like random numbers…'
        // → 4
        //FakeMath.#totallyRandomNumber;
        // → SyntaxError
        //FakeMath.#computeRandomNumber();
        // → SyntaxError
        /*
    ?Know how to create public members
    ?Know how to create private members
    ?Know how to create static members
    ?Understand OOP emulation patterns and conventions

  +Prototypal Inheritance Basics
    ?__proto__ property
    ?Understand __proto__ object property
    ?Able to use [Object.create] and define __proto__ explicitly
    ?Able to set / get object prototype (optional)
    ?prototype property
    ?Know function prototype property
    ?Understand dependency between function constructor prototype and instance __proto__
    ?Able to create 'class' methods using function prototype property

  +ECMAScript Classes
    ?Class declaration
    ?Know class declaration syntax
    ?Understand difference between class and constructor function
    ?Getter/setter
    ?What does super() do and where we have to use it?

  +ECMAScript Data Types & Expressions
    ?Object keys/values
    ?Object calculated props
    ?Set/Map data types
    ?WeakSet/WeakMap data types

  +JavaScript Errors
    ?try..catch statement
    ?Know how to handle errors
    ?Custom errors (optional)

  +ECMAScript Advanced
    ?Garbage collector (concept) (optional)
    ?Promises
    ?Promise states
    ?Promise Chaining
    ?Promise static methods
    ?Be able to compare promise and callback patterns (optional)
    ?Be able to handle errors in promises
    ?event loop
    ?async/await

!JavaScript in Browser:

  +Global object window
    ?Location
    ?Know browser location structure
    ?History API (Global object window)
    ?Know browser History APIconcept
    ?Be able to navigate within browser history
    ?Be able to use history state (optional)
    ?Navigator (optional)
    ?Know how to parse user agent (optional)
    ?Know how to discover client platform, browser
    ?Cookies

  +Page Lifecycle
    ?Parsing
    ?Reflow
    ?Repaint

  +Events Basics
    ?Be able to explain difference between capturing and bubbling
    ?Know Event concept
    ?Custom events (optional)

  +Events Propagation / Preventing
    ?Know Event propagation cycle
    ?Know how to stop Event propagation
    ?Know how to prevent Event default browser behavior
    ?Delegating
    ?Understand Event delegating concept
    ?Understand Event delegating benefits and drawbacks

  +Timers
    ?clearTimeout
    ?requestAnimationFrame (optional)
    ?Be able to explain difference between setTimeout and requestAnimationFrame (optional)

  +Web Storage API & cookies
    ?Cookies (concept)
    ?Difference between localStorage, sessionStorage, session and cookies

!Typescript:

  +Ability to write concise TypeScript code using its constructs
    ?understanding TS(ES6) module system
    ?describing variables with primitive data types.
    ?using interfaces with optional properties, read-only properties, etc...
    ?creating custom types.
    ?types/interface differences (optional)
    ?function types.
    ?utitily types (optional)
    ?typeguards (optional)
    ?generic types (concept)

!Design patterns:

  +Intermediate knowledge of patterns and best practices:
    ?design patterns used on his project, and able to compare these patterns (optional)
    ?KISS, DRY, YAGNI
    ?The meaning behind SOLID principles.

!Web Communication Protocols: (optional)

  +HTTP vs HTTPS vs HTTP/2
  +RESTful API
  +HTTP methods
  +HTTP status codes groups

!Common web-security knowledge (optional)

  +Basic understanding of most common security terms (CORS, XSS) (optional)
    ?XSS
    ?CORS
    ?OWASP Top 10
    ?Auth (JWT, OAuth, Basic, etc.)

!Coding tasks:

  +Function.prototype.bind implement polyfill
  +Object.create implement polyfill
  +Array.flat implement polyfill
  +Array.reduce implement polyfill
  +'hello world'.repeating(3) -> 'hello world hello world hello world'. How to implement?
  +myFunc('!', 4, -10, 34, 0) -> '4!-10!34!0`. How to implement?
  +five(plus(seven(minus(three())))) -> 9. How to implement?
  +add(5)(9)(-4)(1) -> 11. How to implement?
  +periodOutput(period) method should output in the console once per every period how mach time has passed since the first function call. Example: periodOutput(100) -> 100(after 100 ms), 200(after 100 ms), 300(after 100 ms), ...
  +extendedPeriodOutput(period) method should output in the console once per period how mach time has passed since the first function call and then increase the period. Example: // extendedPeriodOutput(100) -> 100(after 100 ms), 200(after 200 ms), 300(after 300 ms)
*/