/* 
! Cookie 
  Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.
  Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.
    Один из наиболее частых случаев использования куки – это аутентификация:
      1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
      2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
      3. Таким образом, сервер понимает, кто сделал запрос.
    Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie.
  + Чтение из document.cookie:
    Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.
      Чтобы найти определённое куки, достаточно разбить строку из document.cookie по ;, и затем найти нужный ключ. Для этого мы можем использовать как регулярные выражения, так и функции для обработки массивов.
  + Запись в document.cookie:
    Мы можем писать в document.cookie. Но это не просто свойство данных, а акcессор (геттер/сеттер). Присваивание к нему обрабатывается особым образом.
    ?Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.
    */
    //Например, этот вызов установит куки с именем user и значением John:
        document.cookie = "user=John"; // обновляем только куки с именем 'user'
        alert(document.cookie); // показываем все куки
    //Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать встроенную функцию encodeURIComponent:
        // специальные символы (пробелы), требуется кодирование
        let name = "my name";
        let value = "John Smith"

        // кодирует в my%20name=John%20Smith
        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

        alert(document.cookie); // ...; my%20name=John%20Smith
    /*
    Существует несколько ограничений:
      -После encodeURIComponent пара name=value не должна занимать более 4Кб. Таким образом, мы не можем хранить в куки большие данные.
      -Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.
  + У куки есть ряд настроек, многие из которых важны и должны быть установлены.
    Эти настройки указываются после пары ключ=значение и отделены друг от друга разделителем ;, вот так:
    */
      document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"
    /*
    + path=/mypath
      URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.
      Если куки установлено с path=/admin, то оно будет доступно на страницах /admin и /admin/something, но не на страницах /home или /adminpage.
      Как правило, указывают в качестве пути корень path=/, чтобы наше куки было доступно на всех страницах сайта.
    + domain=site.com
      Домен определяет, где доступен файл куки. Однако на практике существуют определённые ограничения. Мы не можем указать здесь какой угодно домен.
      Нет никакого способа разрешить доступ к файлам куки из другого домена 2-го уровня, поэтому other.com никогда не получит куки, установленный по адресу site.com.
      Это ограничение безопасности, позволяющее нам хранить конфиденциальные данные в файлах куки, которые должны быть доступны только на одном сайте.
      По умолчанию куки доступны лишь тому домену, который его установил.
      Пожалуйста, обратите внимание, что по умолчанию файл куки также не передаётся поддомену, например forum.site.com.
      Если мы хотим разрешить поддоменам типа forum.site.com получать куки, установленные на site.com, это возможно.
      Чтобы это произошло, при установке файла куки в site.com, мы должны явно установить параметр domain для корневого домена: domain=site.com. После этого все поддомены увидят такой файл cookie.
      */
        // находясь на странице site.com
        // сделаем куки доступным для всех поддоменов *.site.com:
        document.cookie = "user=John; domain=site.com"

        // позже

        // на forum.site.com
        alert(document.cookie); // есть куки user=John
      /*
    + expires, max-age
      По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными («session cookies»).
      Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций expires или max-age. 
      Дата истечения срока действия куки, когда браузер удалит его автоматически.
        ? expires
          Дата должна быть точно в этом формате, во временной зоне GMT. Мы можем использовать date.toUTCString, чтобы получить правильную дату. Например, мы можем установить срок действия куки на 1 день.
          */
            // 1 день от текущей даты
            let date = new Date(Date.now() + 86400e3);
            date = date.toUTCString();
            document.cookie = "user=John; expires=" + date;
          /* 
          Если мы установим в expires прошедшую дату, то куки будет удалено.
        ? max-age
          Альтернатива expires, определяет срок действия куки в секундах с текущего момента. Если задан ноль или отрицательное значение, то куки будет удалено:
          */
            // куки будет удалено через 1 час
            document.cookie = "user=John; max-age=3600";
          /*  
    + secure
      Куки следует передавать только по HTTPS-протоколу.
      По умолчанию куки, установленные сайтом http://site.com, также будут доступны на сайте https://site.com и наоборот.
      То есть, куки, по умолчанию, опираются на доменное имя, они не обращают внимания на протоколы.
      С этой настройкой, если куки будет установлено на сайте https://site.com, то оно не будет доступно на том же сайте с протоколом HTTP, как http://site.com. 
      Таким образом, если в куки хранится конфиденциальная информация, которую не следует передавать по незашифрованному протоколу HTTP, то нужно установить этот флаг.
      */
        // предполагается, что сейчас мы на https://
        // установим опцию secure для куки (куки доступно только через HTTPS)
        document.cookie = "user=John; secure";
      /*
    + samesite (более подробно на https://learn.javascript.ru/cookie)
      Параметр куки samesite предоставляет ещё один способ защиты от таких атак, который (теоретически) не должен требовать «токенов защиты xsrf».
      У него есть два возможных значения:
        -samesite=strict (или, что то же самое, samesite без значения)
          Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта.
          Если куки имеют настройку samesite, то атака XSRF не имеет шансов на успех, потому что отправка с сайта evil.com происходит без куки. Таким образом, сайт bank.com не распознает пользователя и не произведёт платёж.
        -samesite=lax
          Это более мягкий вариант, который также защищает от XSRF и при этом не портит впечатление от использования сайта.
          Режим Lax так же, как и strict, запрещает браузеру отправлять куки, когда запрос происходит не с сайта, но добавляет одно исключение.
    + httpOnly
      Веб-сервер использует заголовок Set-Cookie для установки куки. И он может установить настройку httpOnly.
      Эта настройка запрещает любой доступ к куки из JavaScript. Мы не можем видеть такое куки или манипулировать им с помощью document.cookie.
      Эта настройка используется в качестве меры предосторожности от определённых атак, когда хакер внедряет свой собственный JavaScript-код в страницу и ждёт, когда пользователь посетит её. 
      Это вообще не должно быть возможным, хакер не должен быть в состоянии внедрить свой код на ваш сайт, но могут быть ошибки, которые позволят хакеру сделать это.
      Обычно, если такое происходит, и пользователь заходит на страницу с JavaScript-кодом хакера, то этот код выполняется и получает доступ к document.cookie, и тем самым к куки пользователя, которые содержат аутентификационную информацию. Это плохо.
      Но если куки имеет настройку httpOnly, то document.cookie не видит его, поэтому такое куки защищено.
  + Приложение: Функции для работы с куки
    Вот небольшой набор функций для работы с куки, более удобных, чем ручная модификация document.cookie.
    Для этого существует множество библиотек, так что они, скорее, в демонстрационных целях. Но при этом полностью рабочие.
      ? Функция getCookie(name) возвращает куки с указанным name:
        */
          // возвращает куки с указанным name,
          // или undefined, если ничего не найдено
          function getCookie(name) {
            let matches = document.cookie.match(new RegExp(
              "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
            ));
            return matches ? decodeURIComponent(matches[1]) : undefined;
          }
          // Здесь new RegExp генерируется динамически, чтобы находить ; name=<value>.
          // Обратите внимание, значение куки кодируется, поэтому getCookie использует встроенную функцию decodeURIComponent для декодирования.
        /*
      ? setCookie(name, value, options)
        */
          function setCookie(name, value, options = {}) {
          
            options = {
              path: '/',
              // при необходимости добавьте другие значения по умолчанию
              ...options
            };
          
            if (options.expires instanceof Date) {
              options.expires = options.expires.toUTCString();
            }
          
            let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
          
            for (let optionKey in options) {
              updatedCookie += "; " + optionKey;
              let optionValue = options[optionKey];
              if (optionValue !== true) {
                updatedCookie += "=" + optionValue;
              }
            }
          
            document.cookie = updatedCookie;
          }

          // Пример использования:
          setCookie('user', 'John', { secure: true, 'max-age': 3600 });
        /*
      ? deleteCookie(name)
        Чтобы удалить куки, мы можем установить отрицательную дату истечения срока действия:
          */
            function deleteCookie(name) {
              setCookie(name, "", {
                'max-age': -1
              })
            }
          /*
  + Сторонние куки (более подробно на https://learn.javascript.ru/cookie)
  + Приложение: GDPR 
    В Европе существует законодательство под названием GDPR, которое устанавливает для сайтов ряд правил, обеспечивающих конфиденциальность пользователей. И одним из таких правил является требование явного разрешения от пользователя на использование отслеживающих куки.
    Обратите внимание, это относится только к куки, используемым для отслеживания/идентификации/авторизации.

! LocalStorage, sessionStorage
  Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.
  Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage).
  Но ведь у нас уже есть куки. Зачем тогда эти объекты?
    *В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Поэтому мы можем хранить гораздо больше данных. Большинство браузеров могут сохранить как минимум 2 мегабайта данных (или больше), и этот размер можно поменять в настройках.
    *Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
    *Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
  ? localStorage - Совместно используется между всеми вкладками и окнами с одинаковым источником. «Переживает» перезапуск браузера
  ? sessionStorage - Разделяется в рамках вкладки браузера, среди ифреймов из того же источника. «Переживает» перезагрузку страницы (но не закрытие вкладки)
  API:
      -setItem(key, value) – сохранить пару ключ/значение.
      -getItem(key)        – получить данные по ключу key.
      -removeItem(key)     – удалить значение по ключу key.
      -clear()             – удалить всё.
      -key(index)          – получить ключ на заданной позиции.
      -length              – количество элементов в хранилище.
      -Используйте Object.keys для получения всех ключей.
      -Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событиеstorage не срабатывает.
  ?Как видим, интерфейс похож на Map (setItem/getItem/removeItem), но также запоминается порядок элементов, и можно получить доступ к элементу по индексу – key(index).
  + Доступ как к обычному объекту
    Также можно получать/записывать данные, как в обычный объект: localStorage.test = 2;
    Это возможно по историческим причинам и, как правило, работает, но обычно не рекомендуется, потому что:
      1. Можем записать что угодно
      2 Не сработае событие storage
  + Перебор ключей
    Методы, которые мы видим, позволяют читать/писать/удалять данные. А как получить все значения или ключи?
    К сожалению, объекты веб-хранилища нельзя перебрать в цикле, они не итерируемы.
      */
        // Но можно пройти по ним, как по обычным массивам:
        for (let i = 0; i < localStorage.length; i++) {
          let key = localStorage.key(i);
          console.log(`${key}: ${localStorage.getItem(key)}`);
        }
        // Другой способ – использовать цикл, как по обычному объекту for key in localStorage.
        // Здесь перебираются ключи, но вместе с этим выводятся несколько встроенных полей, которые нам не нужны
        // bad try
        for (let key in localStorage) {
          console.log(key); // покажет getItem, setItem и другие встроенные свойства
        }
        // …Либо просто получить «собственные» ключи с помощью Object.keys, а затем при необходимости вывести их при помощи цикла:
        // Последнее работает, потому что Object.keys возвращает только ключи, принадлежащие объекту, игнорируя прототип.
        let keys = Object.keys(localStorage);
        for (let key of keys) {
          console.log(`${key}: ${localStorage.getItem(key)}`);
        }
      /*
  + Только строки
    Обратите внимание, что ключ и значение должны быть строками.
    Если мы используем любой другой тип, например число или объект, то он автоматически преобразуется в строку: alert(sessionStorage.user); // [object Object]
    Мы можем использовать JSON для хранения объектов:
      */
        sessionStorage.user = JSON.stringify({ name: "John" });
              
        // немного позже
        let user = JSON.parse(sessionStorage.user);
        console.log(user.name); // John
              
        // Также возможно привести к строке весь объект хранилища, например для отладки:
        // для JSON.stringify добавлены параметры форматирования, чтобы объект выглядел лучше
        console.log(JSON.stringify(localStorage, null, 2));
      /*
  + Событие storage
    ?Важно: событие срабатывает на всех остальных объектах window, где доступно хранилище, кроме того окна, которое его вызвало.
    Когда обновляются данные в localStorage или sessionStorage, генерируется событие storage со следующими свойствами:
      -event.key           – ключ, который обновился (null, если вызван .clear()).
      -event.oldValue      – старое значение (null, если ключ добавлен впервые).
      -event.newValue      – новое значение (null, если ключ был удалён).
      -event.url           – url документа, где произошло обновление.
      -event.storageArea   – объект localStorage или sessionStorage, где произошло обновление.
      Важно: событие срабатывает на всех остальных объектах window, где доступно хранилище, кроме того окна, которое его вызвало.
        */
          // срабатывает при обновлениях, сделанных в том же хранилище из других документов
          window.onstorage = event => {
            if (event.key != 'now') return;
            alert(event.key + ':' + event.newValue + " at " + event.url);
          };

          localStorage.setItem('now', Date.now());
        /*
        Обратите внимание, что событие также содержит: event.url – url-адрес документа, в котором данные обновились.
    Событие storage:
      -Срабатывает при вызове setItem, removeItem, clear.
      -Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.
      -Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).
*/