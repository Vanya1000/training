/* 
!Общий обзор
  +Архитектура приложения
    Архитектура приложения — это набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром. Архитектура включает в себя подходы: ограничения, правила и эвристики, которым надо следовать при написании кода.
  +Паттерн проектирования
    Паттерн проектирования — шаблонное решение частой архитектурной проблемы. Область ответственности паттернов проектирования меньше, чем у архитектуры в целом. Паттерны помогают нам решать проблемы на более «низком уровне», ближе к непосредственно коду. Архитектура же решает проблемы проектирования всей системы в целом.
  Если упростить, то архитектура — это инструкция «Как построить дом в общем», она охватывает целый проект. А паттерны — инструкции для конкретных задач: «Как забить сваи», «Как замешать цемент», «Как проложить проводку».
!Архитектура во фронтенде
  Грамотная архитектура помогает спроектировать и развивать систему так, чтобы её было проще и удобнее расширять и изменять.
    -Если общение между модулями регламентировано, их реализацию проще заменить на другую.
    -Если общение с внешним миром регламентировано, меньше шансов для утечки данных.
    -Если код разделён грамотно, программу проще тестировать.
    -Если код организован понятно, уходит меньше времени на добавление новых фич и поиск багов в старых.
    -Если архитектура широко известна, погружение в проект проходит быстрее.
  +Архитектурные подходы
    Мы можем условно разделить архитектурные подходы по их целям и зоне действия. 
      ?Часть подходов распределяют ответственность между модулями. Они определяют, какие модули и за что будут отвечать.
        Model-View-Controller (MVC) — это один из самых популярных подходов. Он разделяет приложение на три слоя: модель, представление и контроллер. Каждый слой отвечает за свою часть приложения. Модель отвечает за данные, представление за отображение данных, а контроллер за логику приложения.
      ?Другие определяют, насколько каждый из модулей близок к бизнес-логике. Таким подходам важно, какая часть кода занимается непосредственно задачей приложения, а какая — инфраструктурными задачами.
        В зависимости от степени близости к бизнес-логике такие подходы делят код на «слои». Самый распространённый подход среди таких — это трёхслойная архитектура. Она разделяет код на слои: представление, бизнес-логику и хранилище данных.
      ?Третьи управляют потоками данных в приложении. Они определяют, как модули общаются друг с другом: напрямую, опосредованно или с помощью специальных сервисов типа шины событий.
        Flux — это один из самых популярных подходов. Он определяет, как модули общаются друг с другом. В Flux модули общаются напрямую, но только через специальные объекты — хранилища.  Это пример однонаправленного потока данных. Хранилища хранят состояние приложения и оповещают об изменениях подписчиков.
        Кроме него используют двунаправленный поток, например, реактивные обновления данных. 
      ?Другие подходы определяют компоновку приложения. Будет это одна большая программа (монолит) или набор нескольких программ поменьше (микросервисов).
  +Минусы архитектуры 
    Создание, организация и следование архитектуре всегда требует ресурсов: времени, денег, умственных затрат. Выбор следует делать после сравнения издержек и выгод каждого из подходов-кандидатов.
!Паттерны проектирования
  Некоторые проблемы слишком малы для выделения в архитектурный подход, но достаточно часто встречаются, чтобы породить стандартные решения. Такие стандартные решения называются паттернами или шаблонами.
  Например, сервер присылает нам данные в виде: { some_data: ["Name", "Lastname"] } А мы хотим их видеть такими: { someData: "Name Lastname" }
  Для решения такой проблемы есть паттерн «Адаптер». Он делает несовместимое стороннее API подходящим для нашего приложения.
  */
  function serverToClientAdapter(data) {
    return {
      someData: data.some_data.join(" "),
    }
  }
  /* 
  Таких стандартных решений много. Мы можем разделить их на несколько групп.
  +Порождающие паттерны
    Порождающие паттерны помогают решать задачи с созданием сущностей или групп похожих сущностей. Они убирают лишнее дублирование, делают процесс создания объектов короче и прямолинейнее. Среди порождающих паттернов мы можем выделить:
      ?Factory Method
        Cоздаёт объект, избавляя нас от необходимости знать детали создания. Фабрика в программировании принимает от нас сигнал, что надо создать объект, и создаёт его, инкапсулируя логику создания внутри себя.
        В примере мы возвращаем объект гитары из функции-фабрики createGuitar(). Функция принимает количество струн как аргумент и подставляет его в качестве значения для поля strings. Все остальные поля она заполняет самостоятельно.
        */
        function createGuitar(stringsCount = 6) {
          return {
            strings: stringsCount,
            frets: 24,
            fretBoardMaterial: 'кедр',
            boardMaterial: 'клён',
          }
        }
        const sixStringsGuitar = createGuitar(6) 
        /*  
        Преимущество фабрики в том, что знание о том, как создать объект, находится в одном месте — внутри фабрики. Если схема (интерфейс) объекта поменяется, то изменить код нам нужно будет только в одном месте — в фабрике.
        Места, где мы на самом деле создаём объекты, то есть вызываем фабрику, остаются без изменений. Это позволяет нам избежать дублирования кода.
        Также мы защищены от ситуации, когда вместо простого объекта нам становится нужно возвращать экземпляры класса:
        */
        function createGuitar(stringsCount = 6) {
          return new Guitar({
            strings: stringsCount,
            frets: 24,
            fretBoardMaterial: 'пихта',
            boardMaterial: 'клён',
          })
        }        
        /*
        Весь остальной код остаётся таким же, как был до этого.
        Когда использовать?
          Используйте фабрику, если создание объекта сложнее, чем 1–2 строки кода. Особенно полезно использовать этот шаблон, когда для создания объекта требуется применить расчёты или получить дополнительные данные:
        */
          function createGuitar(strings = 6, maxWeight = 5) {
            const fretBoardMaterial = maxWeight <= 5 ? 'пихта' : 'кедр'
            return {
              strings,
              frets: 24,
              fretBoardMaterial,
              boardMaterial: 'клён',
            }
          }
        /*
        В примере выше мы выбираем материал грифа в зависимости от максимально разрешённого веса. Когда для создания объекта требуется какая-то логика, её лучше сразу инкапсулировать в фабрике, чем повторять код в разных местах кодовой базы.
      ?Abstract Factory
        
      ?Builder
      ?Singleton
  +Структурные паттерны
    Структурные паттерны помогают решать задачи по совмещению и сочетанию сущностей. Они заботятся о том, как сущности могут использовать друг друга. Простыми словами — отвечают на вопрос «Как составить программный компонент?» Среди структурных паттернов мы можем выделить:
      «Адаптер»;
      «Декоратор»;
      «Фасад»;
      «Прокси».
  +Поведенческие паттерны
    Поведенческие паттерны распределяют ответственность между модулями и определяют, как именно будет происходить общение. Простыми словами — отвечают на вопрос «Как организовать поведение программного компонента?» Среди поведенческих паттернов мы можем выделить:
      -«Цепочку ответственности»;
      -«Стратегию»;
      -«Команду»;
      -«Наблюдателя».



















*/