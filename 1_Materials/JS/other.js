/* 
+Генераторы
    Обычные функции возвращают только одно-единственное значение (или ничего). Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.
    Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.
    Основным методом генератора является next(). При вызове он запускает выполнение кода до ближайшей инструкции yield <значение> (значение может отсутствовать, в этом случае оно предполагается равным undefined). 
    По достижении yield выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:
    */
    function* generateSequence() {
      yield 1;
      yield 2;
      return 3;
    }

    let generator = generateSequence();

    let one = generator.next();

    alert(JSON.stringify(one)); // {value: 1, done: false} Результатом метода next() всегда является объект с двумя свойствами
    /*
    Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield
    Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true}.
    function* f(…) или function *f(…)? Нет разницы, оба синтаксиса корректны.
  Перебор генераторов
    генераторы являются перебираемыми объектами. Возвращаемые ими значения можно перебирать через for..of:
    …Но обратите внимание: пример выше выводит значение 1, затем 2. Значение 3 выведено не будет!
  Мы можем использовать функцию-генератор для итерации, указав её в Symbol.iterator.
    Вот тот же range, но с гораздо более компактным итератором:
    */
    let range = {
      from: 1,
      to: 5,
    
      *[Symbol.iterator]() { // краткая запись для [Symbol.iterator]: function*()
        for(let value = this.from; value <= this.to; value++) {
          yield value;
        }
      }
    };
    
    alert( [...range] ); // 1,2,3,4,5
    /*
    Это работает, потому что range[Symbol.iterator]() теперь возвращает генератор, и его методы – в точности то, что ожидает for..of:
      -у него есть метод .next()
      -который возвращает значения в виде {value: ..., done: true/false}
    Это не совпадение, конечно. Генераторы были добавлены в язык JavaScript, в частности, с целью упростить создание перебираемых объектов.
+AbortController
  Интерфейс AbortController представляет объект контроллера, который позволяет вам при необходимости обрывать один и более DOM запросов.
  Вы можете создать новый объект AbortController используя конструктор AbortController.AbortController(). Взаимодействие с DOM запросами сделано с использованием объекта AbortSignal.
  Конструктор
    AbortController.AbortController() - Создаёт новый экземпляр AbortController.
  Свойства
    AbortController.signal Только для чтения - Возвращает экземпляр AbortSignal, который может быть использован для коммуникаций/останова DOM запросов.
  Методы
    AbortController.abort() - Прерывает DOM запрос до момента его завершения. Это даёт возможность обрывать fetch запросы, потребителей любых ответов с Body и потоки.
    */
    var controller = new AbortController();
    var signal = controller.signal;

    var downloadBtn = document.querySelector('.download');
    var abortBtn = document.querySelector('.abort');

    downloadBtn.addEventListener('click', fetchVideo);

    abortBtn.addEventListener('click', function() {
      controller.abort();
      console.log('Download aborted');
    });

    function fetchVideo() {
      ...
      fetch(url, {signal}).then(function(response) {
        ...
      }).catch(function(e) {
        reports.textContent = 'Download error: ' + e.message;
      })
    }
    /*
?cors
  Если браузер отображает страницу с <img>, он должен запросить этот тег из источника. Если браузер запрашивает тег из источника, который отличается от получателя по схеме, в полностью определенному 
      имени хоста или порту, то это и есть запрос между различными источниками (cross-origin request).
    Источник идентифицируется следующей тройкой параметров: схема, полностью определенное имя хоста и порт. Например, <http://example.com> и <https://example.com> имеют разные источники
      первый использует схему http, а второй https. Вдобавок, портом для http по умолчанию является 80, тогда как для https — 443. Следовательно, в данном примере 2 источника отличаются схемой и портом, тогда как хост один и тот же (example.com).
    Таким образом, если хотя бы один из трех элементов у двух ресурсов отличается, то источник ресурсов также считается разным.
  Политика одинакового источника
    Политика одинакового источника предотвращает cross-origin атаки, блокируя доступ для прочтения загружаемых ресурсов из другого источника. Такая политика все еще разрешает нескольким тегам вроде <img> загружать ресурсы из других источников.
    Введена Netscape Navigator 2.02 в 1995 году, изначально для защищенного cross-origin доступа к Объектной модели документа (DOM).
    Политика одинакового источника решает много проблем, но она довольно ограничительная. В век одностраничных приложений и сайтов, нагруженных медиа-контентом, эта политика не дает ни воздуха разработчикам, ни легко играться настройками.
    CORS же появился с целью смягчения политики одинакового источника и для тонкой настройки доступа между различными источниками.
?Testing
  Анатомия теста:
    Наш тест состоит из 3 строк AAA: Arrange, Act и Assert(Подготовка, Выполнение, Проверка):
      const result = add(10, 5)
      const expected = 15
      expect(result).toEqual(expected)
      -Подготовка (Arrange)
        На стадии подготовки мы готовим исходные данные для функции и ожидаемый результат. В более сложных тестах на этой стадии мы бы готовили зависимости для функции и фиктивные объекты.
      -Выполнение (Act)
        На второй стадии мы запускаем функцию, чтобы получить результат. В этот момент мы отрабатываем тестируемый сценарий и получаем значение, которое потом будем проверять.
      -Проверка (Assert)
        На стадии проверки мы сверяем полученный результат с ожидаемым. Хотя проверка может состоять из нескольких утверждений, хорошей практикой считается внутри одного теста проверять только одно предположение.
  */
  describe('When given 2 numbers', () => {
    it('returns the sum of those 2 numbers', () => {
      const result = add(10, 5)
      const expected = 15

      expect(result).toEqual(expected)
    })
  })
  /*
  Разберём по строкам:
    1. На первой строке мы указываем описание теста — в каких условиях мы собираемся тестировать функцию.
    2. На второй строке указываем само предположение о результате — что функция должна нам вернуть.
    3. На строчках 3–6 выполняем сам тест.
    Функция expect() помогает избежать работы с ошибками напрямую и предоставляет удобные методы для сравнения аргументов друг с другом.
    Обвязка из describe() и it() помогает нам описать тест в виде самого настоящего текстового предположения, которое код теста проверит.
  Идеальный тест:
    -Идеальный тест состоит из всех трёх стадий ПВП. Часто — такой тест даже состоит из 3 строчек.
    -Кроме этого, идеальный тест проверяет только одно утверждение. Для проверки разных утверждений лучше написать отдельные тесты.
    -Идеальный тест не зависит от других тестов. Если тесты зависят друг от друга, они могут влиять и на результаты проверки друг друга. Правильно написанный тест можно запустить где и как угодно, и его результат не изменится.











*/