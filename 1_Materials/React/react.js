/* 
+JSX — расширение языка JavaScript. JSX производит «элементы» React.
  JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, 2 + 2, user.firstName и formatName(user) являются допустимыми выражениями.
  JSX это тоже выражение. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
  Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
  */
  function getGreeting(user) {
    if (user) {
      return <h1>Здравствуй, {formatName(user)}!</h1>;
    }
    return <h1>Здравствуй, незнакомец.</h1>;
  }
  /*
  Использование атрибутов JSX
    Чтобы использовать строковый литерал в качестве значения атрибута, используются кавычки:
    Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
    */
    const element = <a href="https://www.reactjs.org"> link </a>;
    const element = <img src={user.avatarUrl}></img>;
    /* 
    Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в значении атрибута. Следует либо применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
    Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. class становится className в JSX, а tabindex становится tabIndex.
  Использование дочерних элементов в JSX
    Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:
    Но JSX-теги могут и содержать дочерние элементы:
  JSX предотвращает атаки, основанные на инъекции кода
    По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
    Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).
  JSX представляет собой объекты
    Babel компилирует JSX в вызовы React.createElement().
    */
    const element = (
      <h1 className="greeting">
        Привет, мир!
      </h1>
    );
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Привет, мир!'
    );
    // React.createElement() проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой:
    // Примечание: этот код несколько упрощён.
    const element = {
      type: 'h1',
      props: {
        className: 'greeting',
        children: 'Привет, мир!'
      }
    };
    // Эти объекты называются React-элементами.
    /*
+Рендеринг элемента 
  В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.
  Рендеринг элемента в DOM
    Для рендеринга React-элемента, сперва передайте DOM-элемент в ReactDOM.createRoot(), далее передайте с React-элементом в root.render():
    */
    const root = ReactDOM.createRoot(
      document.getElementById('root')
    );
    const element = <h1>Hello, world</h1>;
    root.render(element);
    /*
  Обновление элементов на странице
    Элементы React иммутабельны. После создания элемента нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.
  React обновляет только то, что необходимо
    React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.
+Компоненты и пропсы
  Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.
  Функциональные и классовые компоненты
    Проще всего объявить React-компонент как функцию:
    */
    function Welcome(props) {
      return <h1>Привет, {props.name}</h1>;
    }
    /*
      Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.
    Ещё компоненты можно определять как классы ES6:
    */
    class Welcome extends React.Component {
      render() {
        return <h1>Привет, {this.props.name}</h1>;
      }
    }
    /*
  Как отрендерить компонент
    элементы могут описывать и наши собственные компоненты: const element = <Welcome name="Алиса" />;
      Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).
      */
      function Welcome(props) {
        return <h1>Привет, {props.name}</h1>;
      }
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      const element = <Welcome name="Алиса" />;
      root.render(element);
      /*
      Давайте разберём, что именно здесь происходит:
        1. Мы вызываем root.render() c React-элементом <Welcome name="Алиса" />.
        2. React вызывает наш компонент Welcome с пропсами {name: 'Алиса'}.
        3. Наш компонент Welcome возвращает элемент <h1>Привет, Алиса</h1> в качестве результата.
        4. React DOM делает минимальные изменения в DOM, чтобы получилось <h1>Привет, Алиса</h1>.
        Примечание: Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег.
  Композиция компонентов
    Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения.
  Извлечение компонентов
    Извлечение компонентов может сначала показаться неблагодарной работой. Тем не менее, в больших приложениях очень полезно иметь палитру компонентов, которые можно многократно использовать.
    Если вы не уверены, извлекать компонент или нет, вот простое правило. Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная (App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.
  Пропсы можно только читать
    Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    React достаточно гибкий, но есть одно правило, которое нельзя нарушать:
    React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
      Состояние даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая чистоту компонента.
+Состояние и жизненный цикл
  */
  class Clock extends React.Component {
    constructor(props) { 
      super(props); // Обратите внимание, что мы передаём props базовому (родительскому) конструктору: Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.
      this.state = {date: new Date()}; // Добавим конструктор класса, в котором укажем начальное состояние в переменной this.state:
    }
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
  
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
  
    tick() {
      this.setState({
        date: new Date()
      });
    }

    render() { // Метод render будет вызываться каждый раз, когда происходит обновление. Так как мы рендерим <Clock /> в один и тот же DOM-контейнер, мы используем единственный экземпляр класса Clock — поэтому мы можем задействовать внутреннее состояние и методы жизненного цикла.
      return (
        <div>
          <h1>Привет, мир!</h1>
          <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
        </div>
      );
    }
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<Clock />);
  /*
  Добавим методы жизненного цикла в класс
    В приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы, когда компоненты удаляются.
      -Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting). Нам нужно устанавливать таймер всякий раз, когда это происходит.
      -Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
      Эти методы называются «методами жизненного цикла» (lifecycle methods).
    Метод componentDidMount() запускается после того, как компонент отрендерился в DOM — здесь мы и установим таймер:
    */
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
    /*
    Обратите внимание, что мы сохраняем ID таймера в this (this.timerID).
    Поля this.props и this.state в классах — особенные, и их устанавливает сам React. Вы можете вручную добавить новые поля, если компоненту нужно хранить дополнительную информацию (например, ID таймера).
    Теперь нам осталось сбросить таймер в методе жизненного цикла componentWillUnmount():
    */
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
    /*
    Наконец, реализуем метод tick(). Он запускается таймером каждую секунду и вызывает this.setState().
    Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:
      1. Когда мы передаём <Clock /> в root.render(), React вызывает конструктор компонента. Clock должен отображать текущее время, поэтому мы задаём начальное состояние this.state объектом с текущим временем. Позже мы обновим это состояние.
      2. React вызывает метод render() компонента Clock. Таким образом React узнаёт, что отобразить на экране. Далее React обновляет DOM так, чтобы он соответствовал выводу рендера Clock.
      3. Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock указывает браузеру установить таймер, который будет вызывать tick() раз в секунду.
      4. Таймер вызывает tick() ежесекундно. Внутри tick() мы просим React обновить состояние компонента, вызывая setState() с текущим временем. React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM. Таким образом компонент Clock каждую секунду обновляет UI.
      5. Если компонент Clock когда-либо удалится из DOM, React вызовет метод жизненного цикла componentWillUnmount() и сбросит таймер.
  Как правильно использовать состояние
    Важно знать три детали о правильном применении setState().
      -Не изменяйте состояние напрямую this.state.comment = 'Привет'; Не делайте этого! Вместо этого используйте this.setState({comment: 'Привет'});
        Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.
      -Обновления состояния могут быть асинхронными
        React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
        Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
        Например, следующий код может не обновить счётчик:
        */ // Неправильно
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
        /*
        Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект.
        */
        // Правильно
        this.setState((state, props) => ({ // Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
          counter: state.counter + props.increment
        }));
        /*
      -Обновления состояния объединяются
        Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием.
        */ // Например, состояние может состоять из нескольких независимых полей:
        constructor(props) {
          super(props);
          this.state = {
            posts: [],
            comments: []
          };
        }
        // Их можно обновлять по отдельности с помощью отдельных вызовов setState():
        componentDidMount() {
          fetchPosts().then(response => {
            this.setState({
              posts: response.posts
            });
          });
      
          fetchComments().then(response => {
            this.setState({
              comments: response.comments
            });
          });
        }
        /* Состояния объединяются поверхностно, поэтому вызов this.setState({comments}) оставляет this.state.posts нетронутым, но полностью заменяет this.state.comments.
  Однонаправленный поток данных
    В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.
    Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
    Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов: <FormattedDate date={this.state.date} />. Они будут доступны как this.props.date в FormattedDate компоненте.
    Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:
    Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.
    Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.
    В React-приложениях, имеет ли компонент состояние или нет — это внутренняя деталь реализации компонента, которая может меняться со временем. Можно использовать компоненты без состояния в компонентах с состоянием, и наоборот.
+Обработка событий
  Обработка событий в React-элементах очень похожа на обработку событий в DOM-элементах. Но есть несколько синтаксических отличий:
    -События в React именуются в стиле camelCase вместо нижнего регистра.
    -С JSX вы передаёте функцию как обработчик события вместо строки. <button onClick={activateLasers}>Activate Lasers</button>
    -Ещё одно отличие — в React нельзя предотвратить обработчик события по умолчанию, вернув false. Нужно явно вызвать preventDefault.
    */
    function Form() {
      function handleSubmit(e) {
        e.preventDefault();
        console.log('Отправлена форма.');
      }
    
      return (
        <form onSubmit={handleSubmit}>
          <button type="submit">Отправить</button>
        </form>
      );
    }
    /*
    В приведённом выше коде e — это синтетическое событие. React определяет синтетические события в соответствии со спецификацией W3C, поэтому не волнуйтесь о кроссбраузерности.
    При использовании React обычно не нужно вызывать addEventListener, чтобы добавить обработчики в DOM-элемент после его создания. Вместо этого добавьте обработчик сразу после того, как элемент отрендерился.
    В компоненте, определённом с помощью ES6-класса, в качестве обработчика события обычно выступает один из методов класса. Например, этот компонент Toggle рендерит кнопку, которая позволяет пользователю переключать состояния между «Включено» и «Выключено»:
    */
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
    
        // Эта привязка обязательна для работы `this` в колбэке.
        this.handleClick = this.handleClick.bind(this);
      }
    
      handleClick() {
        this.setState(prevState => ({
          isToggleOn: !prevState.isToggleOn
        }));
      }
    
      render() {
        return (
          <button onClick={this.handleClick}>
            {this.state.isToggleOn ? 'Включено' : 'Выключено'}
          </button>
        );
      }
    }
    /*
    При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. Если вы забудете привязать метод this.handleClick и передать его в onClick, значение this будет undefined в момент вызова функции.
    Если вам не по душе bind, существует два других способа. Вы можете использовать синтаксис публичных полей класса чтобы правильно привязать колбэки:
    */ // Такой синтаксис доступен в Create React App по умолчанию.
    class LoggingButton extends React.Component {
      // Такой синтаксис гарантирует, что `this` привязан к handleClick.
      handleClick = () => {
        console.log('значение this:', this);
      };
      render() {
        return (
          <button onClick={this.handleClick}>
            Нажми на меня
          </button>
        );
      }
    }
    // Если вы не пользуетесь синтаксисом полей, можете попробовать стрелочные функции в колбэке:
    class LoggingButton extends React.Component {
      handleClick() {
        console.log('значение this:', this);
      }
    
      render() {
        // Такой синтаксис гарантирует, что `this` привязан к handleClick.
        return (
          <button onClick={() => this.handleClick()}>
            Нажми на меня
          </button>
        );
      }
    }
    /*
    Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
    Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
    Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
    */
    <>
  /*
  Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
  Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
  Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
  */
  <button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
  <button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button></>
  /*
  Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.
  В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются автоматически.
+ Условный рендеринг
  React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или прятать в зависимости от текущего состояния.
  Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. 
    В таких ситуациях используйте условный оператор JavaScript или выражения подобные if.
    Можно создать компонент Greeting, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:
    */ // В этом примере рендерится различное приветствие в зависимости от значения пропа isLoggedIn.
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
        return <UserGreeting />;
      }
      return <GuestGreeting />;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root')); 
    // Попробуйте заменить на isLoggedIn={true}:
    root.render(<Greeting isLoggedIn={false} />);
    /*
  Встроенные условия if с логическим оператором &&
    Вы можете внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор && языка JavaScript, которым можно удобно вставить элемент в зависимости от условия:
    {unreadMessages.length > 0 && <h2>У вас {unreadMessages.length} непрочитанных сообщений.</h2>}
    Приведённый выше вариант работает корректно, потому что в JavaScript-выражение true && expression всегда вычисляется как expression, а выражение false && expression — как false.
    То есть, если условие истинно (true), то элемент, идущий непосредственно за &&, будет передан на вывод. Если же оно ложно (false), то React проигнорирует и пропустит его.
    Обратите внимание, что ложное выражение, как ожидается, пропустит элемент после &&, но при этом выведет результат этого выражения. В примере ниже метод render вернёт <div>0</div>.
    */
    render() {
      const count = 0;
      return (
        <div>
          {count && <h1>Количество сообщений: {count}</h1>}
        </div>
      );
    }
    /*
  Встроенные условия if-else с тернарным оператором
    Есть ещё один способ писать условия прямо в JSX. Вы можете воспользоваться тернарным оператором condition ? true : false.
    Вот как этот метод можно использовать, чтобы отрендерить кусочек текста.
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          Пользователь <b>{isLoggedIn ? 'сейчас' : 'не'}</b> на сайте.
        </div>
      );
    }
    /*
    Этот метод можно использовать и с выражениями покрупнее, но это может сделать код менее очевидным:
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          {isLoggedIn
            ? <LogoutButton onClick={this.handleLogoutClick} />
            : <LoginButton onClick={this.handleLoginClick} />
          }
        </div>
      );
    }
    /* Как в JavaScript, так и в React выбор синтаксиса зависит от ваших предпочтений и принятого в команде стиля. Не забывайте, что если какое-то условие выглядит очень сложным, возможно пришло время извлечь часть кода в отдельный компонент.
  Предотвращение рендеринга компонента
    В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните null вместо того, что обычно возвращается на рендеринг.
    Например, будет ли содержимое <WarningBanner /> отрендерено, зависит от значения пропа под именем warn. Если значение false, компонент ничего не рендерит:
    Сам факт возврата null из метода render компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, componentDidUpdate будет всё равно вызван.
    */
    function WarningBanner(props) {
      if (!props.warn) {
        return null;
      }
    
      return (
        <div className="warning">
          Предупреждение!
        </div>
      );
    }
    /*
+ Списки и ключи
  Рендер нескольких компонентов
    Вы можете создать коллекцию элементов и встроить её в JSX с помощью фигурных скобок {}. К примеру, пройдём по массиву numbers, используя функцию JavaScript map(), и вернём элемент <li> в каждой итерации. Получившийся массив элементов сохраним в listItems:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li>{number}</li>
    );
    // Теперь мы включим массив listItems внутрь элемента <ul>:
    <ul>{listItems}</ul>
    /*
  Ключи
    Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li key={number.toString()}>
        {number}
      </li>
    );
    /*
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:
    Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:
    Мы не рекомендуем использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента.
    Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.
    Извлечение компонентов с ключами
      Ключи нужно определять непосредственно внутри массивов. Например, если вы извлекаете компонент ListItem, то нужно указывать ключ для <ListItem /> в массиве, а не в элементе <li> внутри самого ListItem.
      */
      function ListItem(props) {
        const value = props.value;
        return (
          // Неправильно! Нет необходимости задавать здесь ключ:
          <li key={value.toString()}>
            {value}
          </li>
        );
      }
      
      function NumberList(props) {
        const numbers = props.numbers;
        const listItems = numbers.map((number) =>
          // Неправильно! Ключ необходимо определить здесь:
          <ListItem value={number} /> // <ListItem key={number.toString()} value={number} />
        );
        return (
          <ul>
            {listItems}
          </ul>
        );
      }
      /*
    Ключи должны быть уникальными среди соседних элементов
      Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.
      Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты. Если в компоненте нужно то же самое значение, то передайте его явно через проп с другим именем:
  Встраивание map() в JSX
    JSX позволяет встроить любое выражение в фигурные скобки, так что мы можем включить результат выполнения map():
    */
    function NumberList(props) {
      const numbers = props.numbers;
      return (
        <ul>
          {numbers.map((number) =>
            <ListItem key={number.toString()}
                      value={number} />
          )}
        </ul>
      );
    }
    /* Иногда это приводит к более чистому коду, но бывает и наоборот. Как и в любом JavaScript-коде, вам придётся самостоятельно решать, стоит ли извлекать код в переменную ради читабельности.
+ Формы
  В React HTML-элементы формы ведут себя немного иначе по сравнению с DOM-элементами, так как у элементов формы изначально есть внутреннее состояние. К примеру, в эту HTML-форму можно ввести имя:
    */
    <form>
      <label>
        Имя:
        <input type="text" name="name" />
      </label>
      <input type="submit" value="Отправить" />
    </form>
    /*
    По умолчанию браузер переходит на другую страницу при отправке HTML-форм, в том числе и этой. Если вас это устраивает, то не надо ничего менять, в React формы работают как обычно. 
      Однако чаще всего форму удобнее обрабатывать с помощью JavaScript-функции, у которой есть доступ к введённым данным. Стандартный способ реализации такого поведения называется «управляемые компоненты».
  Управляемые компоненты
    В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
    Мы можем скомбинировать оба подхода и сделать состояние React-компонента «единственным источником правды». Тогда React-компонент будет рендерить форму и контролировать её поведение в ответ на пользовательский ввод. 
      Значение элемента формы input в этом случае будет контролировать React, а сам элемент будет называться «управляемый компонент».
      */
      class NameForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: ''};
      
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Отправленное имя: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Имя:
                <input type="text" value={this.state.value} onChange={this.handleChange} />
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      А так как каждое нажатие клавиши вызывает handleChange, который обновляет состояние React-компонента, значение в поле будет обновляться по мере того, как пользователь печатает.
      В управляемом компоненте значение поля ввода всегда определяется состоянием React. Хотя это означает, что вы должны написать немного больше кода, теперь вы сможете передать значение и другим UI-элементам или сбросить его с других обработчиков событий.
    Тег textarea
      В React <textarea> использует атрибут value. Таким образом, форму с <textarea> можно написать почти тем же способом, что и форму с однострочным <input>:
    Тег select
      */
      class FlavorForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: 'coconut'};
        
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Ваш любимый вкус: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Выберите ваш любимый вкус:
                <select value={this.state.value} onChange={this.handleChange}>
                  <option value="grapefruit">Грейпфрут</option>
                  <option value="lime">Лайм</option>
                  <option value="coconut">Кокос</option>
                  <option value="mango">Манго</option>
                </select>
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      Подводя итог, <input type="text">, <textarea>, и <select> работают очень похоже. Все они принимают атрибут value, который можно использовать, чтобы реализовать управляемый компонент.
      В атрибут value можно передать массив, что позволит выбрать несколько опций в теге select: <select multiple={true} value={['Б', 'В']}>
  Загрузка файла
    Так как значение такого элемента доступно только для чтения, это неуправляемый React-компонент.
  Обработка нескольких элементов input
    Если вам нужны несколько управляемых элементов input, вы можете назначить каждому из них атрибут name, что позволит функции-обработчику решать, что делать, основываясь на значении event.target.name.
    */
    class Reservation extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          isGoing: true,
          numberOfGuests: 2
        };
    
        this.handleInputChange = this.handleInputChange.bind(this);
      }
    
      handleInputChange(event) {
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;
    
        this.setState({
          [name]: value
        });
      }
    
      render() {
        return (
          <form>
            <label>
              Пойдут:
              <input
                name="isGoing"
                type="checkbox"
                checked={this.state.isGoing}
                onChange={this.handleInputChange} />
            </label>
            <br />
            <label>
              Количество гостей:
              <input
                name="numberOfGuests"
                type="number"
                value={this.state.numberOfGuests}
                onChange={this.handleInputChange} />
            </label>
          </form>
        );
      }
    }
    /* Кроме того, setState() автоматически производит слияние части состояния с текущим состоянием, то есть нам нужно передать в него только ту часть state, которую хотим изменить.
  Значение null управляемого компонента
    Если установить управляемому компоненту проп value, то пользователь не сможет изменить его значение без вашего желания. Если вы установили value, а поле ввода по-прежнему можно редактировать, то, возможно, вы случайно задали value, равный undefined или null.
  Альтернативы управляемым компонентам
    Использование управляемых компонентов иногда может быть утомительным. В такой ситуации могут пригодиться неуправляемые компоненты — альтернативная техника реализации ввода данных в форму. https://ru.reactjs.org/docs/uncontrolled-components.html
  Полноценные решения 
    react hook form
+ Подъём состояния
  Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. Давайте посмотрим, как это работает.
  В React совместное использование состояния достигается перемещением его до ближайшего предка компонентов, которым оно требуется. Это называется «подъём состояния». 
  */
  class Calculator extends React.Component {
    constructor(props) {
      super(props);
      this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
      this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
      this.state = {temperature: '', scale: 'c'};
    }
  
    handleCelsiusChange(temperature) {
      this.setState({scale: 'c', temperature});
    }
  
    handleFahrenheitChange(temperature) {
      this.setState({scale: 'f', temperature});
    }
  
    render() {
      const scale = this.state.scale;
      const temperature = this.state.temperature;
      const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
      const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
  
      return (
        <div>
          <TemperatureInput
            scale="c"
            temperature={celsius}
            onTemperatureChange={this.handleCelsiusChange} />
          <TemperatureInput
            scale="f"
            temperature={fahrenheit}
            onTemperatureChange={this.handleFahrenheitChange} />
          <BoilingVerdict
            celsius={parseFloat(celsius)} />
        </div>
      );
    }
  }
  /*
  Теперь, независимо от того, какое поле ввода вы редактируете, this.state.temperature и this.state.scale в Calculator обновляются. Одно из полей ввода получает значение как есть, поэтому введённые пользователем данные сохраняются, а значение другого поля ввода всегда пересчитывается на их основе.
    Давайте посмотрим, что происходит, когда вы редактируете поле ввода:
      -React вызывает функцию, указанную в onChange на DOM-элементе <input>. В нашем случае это метод handleChange() компонента TemperatureInput.
      -Метод handleChange() в компоненте TemperatureInput вызывает this.props.onTemperatureChange() с новым требуемым значением. Его пропсы, включая onTemperatureChange, были предоставлены его родительским компонентом — Calculator.
      -Когда Calculator рендерился ранее, он указал, что onTemperatureChange в компоненте TemperatureInput по шкале Цельсия — это метод handleCelsiusChange в компоненте Calculator, а onTemperatureChange компонента TemperatureInput по шкале Фаренгейта — это метод handleFahrenheitChange в компоненте Calculator. Поэтому один из этих двух методов Calculator вызывается в зависимости от того, какое поле ввода редактируется.
      -Внутри этих методов компонент Calculator указывает React сделать повторный рендер себя, используя вызов this.setState() со значением нового поля ввода и текущей шкалой.
      -React вызывает метод render() компонента Calculator, чтобы узнать, как должен выглядеть UI. Значения обоих полей ввода пересчитываются исходя из текущей температуры и шкалы. В этом методе выполняется конвертация температуры.
      -React вызывает методы render() конкретных компонентов TemperatureInput с их новыми пропсами, переданными компонентом Calculator. Он узнает, как должен выглядеть UI.
      -React вызывает метод render() компонента Boiling Verdict, передавая температуру в градусах Цельсия как проп.
      -React DOM обновляет DOM, чтобы привести его в соответствие с нужными нам значениями в полях ввода. Отредактированное нами только что поле ввода получает его текущее значение, а другое поле ввода обновляется конвертированным значением температуры.
      -Каждое обновление проходит через одни и те же шаги, поэтому поля ввода остаются синхронизированными.
  Извлечённые уроки
    Для любых изменяемых данных в React-приложении должен быть один «источник истины». Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.
      Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка. Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на однонаправленный поток данных.
    Для подъёма состояния приходится писать больше «шаблонного» кода, чем при подходах с двусторонней привязкой данных, но мы получаем преимущество в виде меньших затрат на поиск и изолирование багов.
      Так как любое состояние «живёт» в каком-нибудь компоненте, и только этот компонент может его изменить, количество мест с возможными багами значительно уменьшается. 
      Кроме того, вы можете реализовать любую пользовательскую логику для отклонения или преобразования данных, введённых пользователем.
    Если что-то может быть вычислено из пропсов или из состояния, то скорее всего оно не должно находиться в состоянии. Например, вместо сохранения celsiusValue и fahrenheitValue, мы сохраняем только последнюю введённую температуру (temperature) и её шкалу (scale). Значение другого поля ввода можно всегда вычислить из них в методе render().
      Это позволяет очистить или применить округление к значению другого поля, не теряя при этом точности значений, введённых пользователем.
    Когда вы видите, что в UI что-то отображается неправильно, то можете воспользоваться расширением React Developer Tools. С помощью него можно проверить пропсы и перемещаться по дереву компонентов вверх до тех пор, пока не найдёте тот компонент, который отвечает за обновление состояния. 
      Это позволяет отследить источник багов:
+ Композиция против наследования
  React имеет мощную модель композиции, поэтому для повторного использования кода между компонентами мы рекомендуем использовать композицию вместо наследования.
    В этой главе мы рассмотрим несколько проблем, которые новички в React решают наследованием и попробуем решить их с помощью композиции.
    Вставка
      Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.
      Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
      */
      function FancyBorder(props) {
        return (
          <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
          </div>
        );
      }
      // Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
      function WelcomeDialog() {
        return (
          <FancyBorder color="blue">
            <h1 className="Dialog-title">
              Добро пожаловать
            </h1>
            <p className="Dialog-message">
              Спасибо, что посетили наш космический корабль!
            </p>
          </FancyBorder>
        );
      }
      /*
      Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри <div>, все переданные элементы отображаются в конечном выводе.
      Иногда в компоненте необходимо иметь несколько мест для вставки. В таком случае можно придумать свой формат, а не использовать children:
      */
      function SplitPane(props) {
        return (
          <div className="SplitPane">
            <div className="SplitPane-left">
              {props.left}
            </div>
            <div className="SplitPane-right">
              {props.right}
            </div>
          </div>
        );
      }
      
      function App() {
        return (
          <SplitPane
            left={
              <Contacts />
            }
            right={
              <Chat />
            } />
        );
      }
      /* // Такие React-элементы, как <Contacts /> и <Chat /> являются просто объектами, поэтому их можно передать в виде пропсов, как и любые другие данные.
  Специализация
    Некоторые компоненты можно рассматривать как «частные случаи» других компонентов. Например, WelcomeDialog может быть частным случаем Dialog.
    В React это можно сделать через композицию, где «частный» вариант компонента рендерит более «общий» и настраивает его с помощью пропсов:
  Так что насчёт наследования?
    Пропсы и композиция дают вам всю гибкость, необходимую для настройки внешнего вида и поведения компонента явным и безопасным способом. Помните, что компоненты могут принимать произвольные пропсы, включая примитивные значения, React-элементы или функции.
    Если вы хотите повторно использовать не связанную с внешним видом функциональность между компонентами, извлеките её в отдельный JavaScript-модуль.
    Импортируйте его в компонент и используйте эту функцию, объект или класс, не расширяя их.
+ Введение в хуки
  Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
  Мотивация
    1. Трудно повторно использовать логику состояний между компонентами
      В React нет способа «присоединить» повторно используемое поведение к компоненту (например, подключение к хранилищу). Если вы работали с React какое-то время, то вам могут быть знакомы такие паттерны, как рендер-пропсы и компоненты 
      высшего порядка, которые пытаются решить эту проблему. Но эти паттерны заставляют вас изменять структуру компонентов, что делает код громоздким и трудным в поддержке. Если вы посмотрите на типичное React-приложение в React DevTools, 
      то увидите «ад обёрток» из компонентов, окружённых провайдерами, консьюмерами, компонентами высшего порядка, рендер-пропсами и другими абстракциями.
    -С помощью хуков вы можете извлечь логику состояния из компонента, чтобы её протестировать или повторно использовать. Хуки позволяют вам повторно использовать логику состояния, не затрагивая дерево компонентов. 
      Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с сообществом.
    2. Сложные компоненты становятся трудными для понимания
      Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в неуправляемый беспорядок, состоящий из логики состояния и побочных эффектов.
      Каждый метод жизненного цикла часто содержит смесь несвязанной логики. Например, компоненты могут загружать данные в componentDidMount и componentDidUpdate. Однако тот же метод componentDidMount может содержать несвязанную логику, 
      которая добавляет обработчики события с отменой подписки в componentWillUnmount. Взаимосвязанный код, который изменяется вместе, разделяется, но совершенно несвязанный код в конечном итоге объединяется в один метод. Это легко приводит 
      к багам и несоответствиям в приложении. В некоторых случаях невозможно разбить компоненты на более мелкие, потому что логика состояния раскидана повсюду. Такие компоненты сложно тестировать. Это одна из причин, по которой люди предпочитают 
      использовать в React отдельную библиотеку для управления состоянием. Однако, это добавляет множество абстракций, заставляет прыгать между разными файлами и усложняет повторное использование компонентов.
    -Чтобы решить эту проблему, хуки позволяют разбить один компонент на маленькие функции по их назначению (например, подписке или загрузке данных), а не на основе методов жизненного цикла. Вы также можете контролировать внутреннее состояние 
      с помощью редюсера, чтобы поведение было более предсказуемым.
    3. Классы путают как людей, так и машины
      Вдобавок к усложнению организации кода и его повторного использования, классы создают существенный барьер в изучении React. Нужно понимать, как работает this в JavaScript, поведение которого отличается от большинства языков.
      Приходится помнить про привязку контекста для обработчиков событий. Без использования ES2022 публичных полей класса, код становится многословным. Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, 
      но всё равно путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда их использовать, приводят к разногласиям даже между опытными React-разработчиками. Однако мы заметили, что классовые 
      компоненты могут приводить к ненамеренным паттернам, сводящим оптимизации на нет. Классы создают сложности для инструментов и сегодня. Например, классы плохо минифицируются, а горячая перезагрузка (hot reloading) ненадёжна и 
      часто ломает их. Наша цель — предоставить API, который повысит вероятность того, что код можно будет оптимизировать.
    -Чтобы решить эти проблемы, хуки позволяют использовать больше возможностей React без написания классов. Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к функционалу, но не обесценивают опыт использования React.
      Хуки предоставляют императивные лазейки и не требуют от вас изучения сложных функциональных или реактивных подходов.
+ useState
  Что такое хук?
    Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. 
  Когда применить хук? 
    Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента.
  Что делает вызов useState?
    Он объявляет «переменную состояния». Мы называли переменную count, но могли дать ей любое имя, хоть банан. Таким образом мы можем «сохранить» некоторые значения между вызовами функции. useState — это новый способ использовать те же возможности, 
    что даёт this.state в классах. Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не относится, потому что их сохраняет React.
  Какие аргументы передавать useState?
    Единственный аргумент useState — это исходное состояние. В отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так удобно.
  Что возвращается из useState?
    Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. Поэтому мы пишем const [count, setCount] = useState().
  Теперь мы знаем, что делает useState, и пример должен быть ясен:
  */
  import React, { useState } from 'react';

  function Example() {
    // Объявление новой переменной состояния «count»
    const [count, setCount] = useState(0);
  /*
  Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить count, мы вызовем setCount.
  
  1. useState асинхронно менякт значение! И новое значение мы сможем увидеть только при следующем рендере! Даже если мы 2 раза вызовем setCount(counter + 1), то значение count изменится только один раз!
    И если нужно использовать новое значение сразу, то нужно использовать функцию в качестве аргумента! setCount((prevCount) => prevCount + 1);
  2. Обратите внимание, что, в отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.
    */ // так же и с массивом!
    const [state, setState] = useState({ count: 0, theme: 'blue' });
    setState(prevState => {
      return { ...prevState, count: prevState.count + 1 }
    }
    /*
  3. Инициализационное значение хоть и отбрасывается, но все равно создается при каждом рендере. И если там сложное вычисление, то лучше передавать не вычисленное значение, а функцию, которая будет вычислять это значение только тогда, когда оно действительно понадобится.
    Пример: const [count, setCount] = useState(() => 10);
+ useEffect
  Хук эффекта даёт вам возможность выполнять побочные эффекты в функциональном компоненте.
    Побочными эффектами в React-компонентах могут быть: загрузка данных, оформление подписки и изменение DOM вручную. Неважно, называете ли вы эти операции «побочными эффектами» (или просто «эффектами») или нет, скорее всего вам доводилось ранее использовать их в своих компонентах.
    Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют сброса. Давайте рассмотрим оба примера более детально.
  Эффекты без сброса
    Иногда мы хотим выполнить дополнительный код после того, как React обновил DOM. Сетевые запросы, изменения DOM вручную, логирование — всё это примеры эффектов, которые не требуют сброса.
    После того, как мы запустили их, можно сразу забыть о них, ведь больше никаких дополнительных действий не требуется.
    Что же делает useEffect? 
      Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM.
      В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.
    Почему же мы вызываем useEffect непосредственно внутри компонента?
      Это даёт нам доступ к переменной состояния count (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. 
      Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
    Выполняется ли useEffect после каждого рендера?
      Разумеется! По умолчанию он будет выполняться после каждого рендера и обновления. 
      Вместо того, чтобы воспринимать это с позиции «монтирования» и «обновления», мы советуем просто иметь в виду, что эффекты выполняются после каждого рендера. React гарантирует, что он запустит эффект только после того, как DOM уже обновился.
    Подробное объяснение
      Опытные JavaScript-разработчики могут подметить, что функция, которую мы передаём в useEffect, будет меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что даёт нам возможность получать актуальную версию 
      переменной count изнутри эффекта, не беспокоясь о том, что её значение устареет. Каждый раз при повторном рендере, мы ставим в очередь новый эффект, который заменяет предыдущий. В каком-то смысле, это включает поведение эффектов как часть результата рендера, 
      то есть каждый эффект «принадлежит» определённому рендеру.
      (Совет) В отличие от componentDidMount или componentDidUpdate, эффекты, запланированные с помощью useEffect, не блокируют браузер при попытке обновить экран. Ваше приложение будет быстрее реагировать на действия пользователя, даже когда эффект ещё не закончился.
        Большинству эффектов не нужно работать в синхронном режиме. Есть редкие случаи, когда им всё же нужно это делать (например, измерять раскладку), но для этого мы разработали специальный хук useLayoutEffect с точно таким же API, как и у useEffect.
  Эффекты со сбросом
    Например, нам может потребоваться установить подписку на какой-нибудь внешний источник данных. В этом случае очень важно выполнять сброс, чтобы не случилось утечек памяти!
    Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.
    */
    function FriendStatus(props) {
      const [isOnline, setIsOnline] = useState(null);
    
      useEffect(() => {
        function handleStatusChange(status) {
          setIsOnline(status.isOnline);
        }
        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
        // Указываем, как сбросить этот эффект:
        return function cleanup() {
          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
        };
      });
    
      if (isOnline === null) {
        return 'Загрузка...';
      }
      return isOnline ? 'В сети' : 'Не в сети';
    }
    /*
    Зачем мы вернули функцию из нашего эффекта?
      Это необязательный механизм сброса эффектов. Каждый эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
    Когда именно React будет сбрасывать эффект? 
      React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий. 
      Мы рассмотрим почему это позволяет избежать багов и как отказаться от этой логики, если это вызывает проблемы с производительностью
  Советы по использованию эффектов
    используйте разные хуки для разных задач
      С помощью хуков, мы можем разделить наш код основываясь на том, что он делает, а не по принципам методов жизненного цикла. React будет выполнять каждый используемый эффект в компоненте, согласно порядку их объявления.
    ?Объяснение: почему эффекты выполняются при каждом обновлении
      Если вы привыкли пользоваться классами, вам может быть не совсем ясно, почему этап сброса эффекта происходит после каждого последующего рендера, а не один лишь раз во время размонтирования. 
      Давайте рассмотрим на практике, почему такой подход помогает создавать компоненты с меньшим количеством багов.
      Ранее на этой странице, мы рассматривали пример с компонентом FriendStatus, который отображает в сети наш друг или нет. Наш класс берёт friend.id из this.props, подписывается на статус друга после того, как компонент смонтировался, и отписывается во время размонтирования.
      */
      componentDidMount() {
        ChatAPI.subscribeToFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }
    
      componentWillUnmount() {
        ChatAPI.unsubscribeFromFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }
      /*
      Но что же произойдёт, если проп friend поменяется, пока компонент все ещё находится на экране? Наш компонент будет отображать статус в сети уже какого-нибудь другого друга. Это как раз таки баг. Это также может привести к утечке памяти или вообще к вылету нашего приложения при размонтировании, 
      так как метод отписки будет использовать неправильный ID друга, от которого мы хотим отписаться. В классовом компоненте нам бы пришлось добавить componentDidUpdate, чтобы решить эту задачу
      Не использовать componentDidUpdate надлежащим образом — это один из самых распространённых источников багов в приложениях React.
      Теперь давайте рассмотрим версию этого же компонента, но уже написанного с использованием хуков:
      */
      function FriendStatus(props) {
        // ...
        useEffect(() => {
          // ...
          ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
          return () => {
            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
          };
        });
        /*
      Здесь нет никакого особого кода для решения проблем с обновлениями, так как useEffect решает их по умолчанию. Он сбрасывает предыдущие эффекты прежде чем выполнить новые. Чтобы показать это на практике, давайте рассмотрим последовательность подписок и отписок, 
        которые этот компонент может выполнить в течение некоторого времени.
      */
       // Монтируем с пропсами { friend: { id: 100 } } 
      ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Выполняем первый эффект

      // Обновляем с пропсами { friend: { id: 200 } }
      ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Сбрасываем предыдущий эффект
      ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Выполняем следующий эффект

      // Обновляем с пропсами { friend: { id: 300 } }
      ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Сбрасываем предыдущий эффект
      ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Выполняем следующий эффект

      // Размонтируем
      ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Сбрасываем последний эффект
      /*
      Эта логика по умолчанию гарантирует согласованность выполняемых нами действий и исключает баги, распространённые в классовых компонентах из-за упущенной логики обновления.
  Совет: оптимизация производительности за счёт пропуска эффектов
    В некоторых случаях сброс или выполнение эффекта при каждом рендере может вызвать проблему с производительностью. В классовых компонентах, мы можем решить это используя дополнительное сравнение prevProps или prevState внутри componentDidUpdate:
    */
    componentDidUpdate(prevProps, prevState) {
      if (prevState.count !== this.state.count) {
        document.title = `Вы нажали ${this.state.count} раз`;
      }
    }
    /*
    Эту логику приходится использовать довольно часто, поэтому мы решили встроить её в API хука useEffect. Вы можете сделать так, чтобы React пропускал вызов эффекта, если определённые значения остались без изменений между последующими рендерами. 
      Чтобы сделать это, передайте массив в useEffect вторым необязательным аргументом.
      */
      useEffect(() => {
        document.title = `Вы нажали ${count} раз`;
      }, [count]); // Перезапускать эффект только если count поменялся
      /*
      В этом примере, мы передаём [count] вторым аргументом. Что это вообще значит? Это значит, что если count будет равен 5 и наш компонент повторно рендерится с тем же значением count = 5, React сравнит [5] из предыдущего рендера и [5] из следующего рендера. 
        Так как, все элементы массива остались без изменений (5 === 5), React пропустит этот эффект. Это и есть оптимизация данного процесса.
      Когда при следующем рендере наша переменная count обновится до 6, React сравнит элементы в массиве [5] из предыдущего рендера и элементы массива [6] из следующего рендера. На этот раз, React выполнит наш эффект, так как 5 !== 6. Если у вас будет несколько элементов в массиве, 
        React будет выполнять наш эффект, в том случае, когда хотя бы один из них будет отличаться.
  Примечание
    Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом.
    В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров.
+ Правила хуков
  Используйте хуки только на верхнем уровне
    Не вызывайте хуки внутри циклов, условных операторов или вложенных функций. Вместо этого всегда используйте хуки только внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой 
    последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами useState и useEffect.
  Вызывайте хуки только из React-функций
    Не вызывайте хуки из обычных функций JavaScript. Вместо этого можно:
      ✅ Вызывать хуки из функционального компонента React.
      ✅ Вызывать хуки из пользовательского хука (мы научимся делать это на следующей странице).
+ Пользовательские хуки
  Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки. Например, функция useFriendStatus ниже — это наш первый пользовательский хук:
  */
  import { useState, useEffect } from 'react';

  function useFriendStatus(friendID) {
    const [isOnline, setIsOnline] = useState(null);
  
    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }
  
      ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
      };
    });
  
    return isOnline;
  }
  /*
  В отличие от React-компонента, пользовательский хук не обязательно должен иметь конкретную сигнатуру. Мы можем решить, что он принимает в качестве аргументов, и должен ли он что-либо возвращать. 
  Другими словами, всё как в обычных функциях. Имя функции-хука всегда следует начинать с use, чтобы вы могли сразу увидеть, что к ней применяются правила хуков.
  Цель нашего хука useFriendStatus — подписать нас на статус друга. Поэтому он принимает в качестве аргумента friendID и возвращает статус друга в сети:
  Использование пользовательского хука
  */
  function FriendStatus(props) {
    const isOnline = useFriendStatus(props.friend.id);
  
    if (isOnline === null) {
      return 'Загрузка...';
    }
    return isOnline ? 'В сети' : 'Не в сети';
  }
  /*
  Код будет работать как раньше? 
    Да, он работает точно так же. Если вы посмотрите внимательно, вы заметите, что мы не вносили никаких изменений в логику. Всё, что мы сделали, это извлекли общий код в отдельную функцию. 
    Пользовательские хуки — это скорее соглашение, соответствующее дизайну хуков, нежели чем возможность самого React.
  У хука, используемого в двух компонентах, одинаковое состояние?
    Пользовательские хуки — это механизм повторного использования логики с состоянием (например, установка подписки и сохранение текущего значения), но каждый раз, когда вы используете пользовательский хук, всё состояние и эффекты внутри него полностью изолированы.
  Как пользовательский хук получает изолированное состояние?
    Каждый вызов хука получает изолированное состояние. Поскольку мы вызываем useFriendStatus напрямую, с точки зрения React наш компонент просто вызывает useState и useEffect. И как мы узнали ранее, мы можем вызывать 
    useState и useEffect много раз в одном компоненте, и они будут полностью независимы.
  Совет: Передача информации между хуками
    Поскольку хуки являются функциями, мы можем передавать информацию между ними.
  используйтеВоображение()
    Пользовательские хуки предлагают гибкую логику совместного использования, которая раньше была невозможна в React-компонентах. Вы можете написать собственные хуки, которые охватывают широкий спектр вариантов использования, таких как обработка форм, 
    анимация, декларативные подписки, таймеры и, возможно, многих других, которые мы не рассматривали. Более того, вы можете создавать хуки, которые также просты в использовании, как и встроенные функции React.
+ useContext
  const value = useContext(MyContext);
    Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.
    Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext.
    Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext.
    Запомните, аргументом для useContext должен быть непосредственно сам объект контекста: useContext(MyContext)
    Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации.
  Совет
    Если вы были знакомы с API контекстов до появления хуков, то вызов useContext(MyContext) аналогичен выражению static contextType = MyContext в классе, либо компоненту <MyContext.Consumer>.
    useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста.
    */
    const themes = {
      light: {
        foreground: "#000000",
        background: "#eeeeee"
      },
      dark: {
        foreground: "#ffffff",
        background: "#222222"
      }
    };
    
    const ThemeContext = React.createContext(themes.light);
    
    function App() {
      return (
        <ThemeContext.Provider value={themes.dark}>
          <Toolbar />
        </ThemeContext.Provider>
      );
    }
    
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }
    
    function ThemedButton() {
      const theme = useContext(ThemeContext);
      return (
        <button style={{ background: theme.background, color: theme.foreground }}>
          Я стилизован темой из контекста!
        </button>
      );
    }
    /*
+ useReducer
  const [state, dispatch] = useReducer(reducer, initialArg, init);
  Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. (Если вы знакомы с Redux, вы уже знаете, как это работает.)
  Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. useReducer также 
    позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать dispatch вместо колбэков.
  Вот пример счётчика из раздела useState, переписанный для использования редюсера:
  */
  const initialState = {count: 0};

  function reducer(state, action) {
    switch (action.type) {
      case 'increment':
        return {count: state.count + 1};
      case 'decrement':
        return {count: state.count - 1};
      default:
        throw new Error();
    }
  }
  
  function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    return (
      <>
        Count: {state.count}
        <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        <button onClick={() => dispatch({type: 'increment'})}>+</button>
      </>
    );
  }
  /*
  React гарантирует, что идентичность функции dispatch стабильна и не изменяется при повторных рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков useEffect и useCallback.
  Указание начального состояния
    Существует два разных способа инициализации состояния useReducer. Вы можете выбрать любой из них в зависимости от ситуации. Самый простой способ — передать начальное состояние в качестве второго аргумента:
    */ const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
    );
    /*
    Примечание
      React не использует соглашение об аргументах state = initialState, популярное в Redux. Начальное значение иногда должно зависеть от пропсов и поэтому указывается вместо вызова хука.
      Если вы сильно в этом уверены, вы можете вызвать useReducer(reducer, undefined, reducer), чтобы эмулировать поведение Redux, но это не рекомендуется.
    Ленивая инициализация
      ?Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию init в качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова init(initialArg).
      Это позволяет извлечь логику для расчёта начального состояния за пределы редюсера. Это также удобно для сброса состояния позже в ответ на действие:
      */
      function init(initialCount) {
        return {count: initialCount};
      }
      
      function reducer(state, action) {
        switch (action.type) {
          case 'increment':
            return {count: state.count + 1};
          case 'decrement':
            return {count: state.count - 1};
          case 'reset':
            return init(action.payload);
          default:
            throw new Error();
        }
      }
      
      function Counter({initialCount}) {
        const [state, dispatch] = useReducer(reducer, initialCount, init);
        return (
          <>
            Count: {state.count}
            <button
              onClick={() => dispatch({type: 'reset', payload: initialCount})}>
              Reset
            </button>
            <button onClick={() => dispatch({type: 'decrement'})}>-</button>
            <button onClick={() => dispatch({type: 'increment'})}>+</button>
          </>
        );
      }
      /*
      Досрочное прекращение dispatch
      Если вы вернёте то же значение из редюсера хука, что и текущее состояние, React выйдет без перерисовки дочерних элементов или запуска эффектов. (React использует алгоритм сравнения Object.is.)
+ useRef 
  const refContainer = useRef(initialValue);
  useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.
  Обычный случай использования — это доступ к потомку в императивном стиле:
  */
  function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
      // `current` указывает на смонтированный элемент `input`
      inputEl.current.focus();
    };
    return (
      <>
        <input ref={inputEl} type="text" />
        <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
      </>
    );
  }
  /*
  По сути, useRef похож на «коробку», которая может содержать изменяемое значение в своём свойстве .current.
  Возможно, вы знакомы с рефами в основном как со способом получить доступ к DOM. Если вы передадите React объект рефа с помощью подобного выражения <div ref={myRef}/>, React установит собственное 
    свойство .current на соответствующий DOM-узел при каждом его изменении.
  Но хук useRef() полезен не только установкой атрибута с рефом. Он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах.
    Это возможно, поскольку useRef() создаёт обычный JavaScript-объект. Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере.
    Имейте в виду, что useRef не уведомляет вас, когда изменяется его содержимое. Мутирование свойства .current не вызывает повторный рендер. Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, 
    вы можете использовать колбэк-реф вместо этого.
    Также мы можем сохранять предыдущее состояние  используя хук useRef:
+ useMemo
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.
  Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo.
  Если массив не был передан, новое значение будет вычисляться при каждом рендере.
  Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов 
  вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.
  

  */
  function complexCompute(num) {
    console.log('complexCompute')
    let i = 0
    while (i < 1000000000) i++
    return num * 2
  }

  function App() {
    const [number, setNumber] = useState(42)
    const [colored, setColored] = useState(false)

    const styles = useMemo(() => ({ // можно закэшировать объект стилей и тогда useEffect не будет вызываться при каждом рендере, а только при изменении цвета
      color: colored ? 'darkred' : 'black' // т.к  на каждом рендере будет создаваться новый объект, то useEffect будет вызываться при каждом рендере
    }), [colored])

    const computed = useMemo(() => { // useMemo - кеширует результат вызова функции
      return complexCompute(number)
    }, [number]) // и вызывает функцию только если изменился number

    useEffect(() => {
      console.log('Styles changed')
    }, [styles])

    return (
      <>
        <h1 style={styles}>Вычисляемое свойство: {computed}</h1>
        <button className={'btn btn-success'} onClick={() => setNumber(prev => prev + 1)}>Добавить</button>
        <button className={'btn btn-danger'} onClick={() => setNumber(prev => prev - 1)}>Убрать</button>
        <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button>
      </>
    )
  }
  /*
+ useCallback
  */
  const memoizedCallback = useCallback(
    () => {
      doSomething(a, b);
    },
    [a, b],
  );
  /* Возвращает мемоизированный колбэк.
  Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. 
  Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).
  useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).
  */
  function App() {
    const [colored, setColored] = useState(false)
    const [count, setCount] = useState(1)
  
    const styles = {
      color: colored ? 'darkred' : 'black'
    }
  
    const generateItemsFromAPI = useCallback((indexNumber) => {
      return new Array(count).fill('').map((_, i) => `Элемент ${i + indexNumber}`)
    }, [count])
  
    return (
      <>
        <h1 style={styles}>Количество элементов: {count}</h1>
        <button className={'btn btn-success'} onClick={() => setCount(prev => prev + 1)}>Добавить</button>
        <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button> Предотвращает ререндер дочерних компонентов если мы именили цвет
  
        <ItemsList getItems={generateItemsFromAPI} />
      </>
    )
  }

  export default function ItemsList({ getItems }) {
    const [items, setItems] = useState([])
  
    useEffect(() => {
      const newItems = getItems(42)
      setItems(newItems)
      console.log('render')
    }, [getItems])
  
    return (
      <ul>
        { items.map(i => <li key={i}>{i}</li>) }
      </ul>
    )
  }  
  /*
+ useLayoutEffect
  Сигнатура идентична useEffect, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, 
    запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.
  Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений.
  При useEffect наоснове return создается виртуальное дерево => далее оно отдается на отрисовку в браузер и только после этого вызывается функция переданная в useEffect 










  */