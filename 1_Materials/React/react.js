/* 
+JSX — расширение языка JavaScript. JSX производит «элементы» React.
  JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, 2 + 2, user.firstName и formatName(user) являются допустимыми выражениями.
  JSX это тоже выражение. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
  Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
  */
  function getGreeting(user) {
    if (user) {
      return <h1>Здравствуй, {formatName(user)}!</h1>;
    }
    return <h1>Здравствуй, незнакомец.</h1>;
  }
  /*
  Использование атрибутов JSX
    Чтобы использовать строковый литерал в качестве значения атрибута, используются кавычки:
    Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
    */
    const element = <a href="https://www.reactjs.org"> link </a>;
    const element = <img src={user.avatarUrl}></img>;
    /* 
    Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в значении атрибута. Следует либо применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
    Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. class становится className в JSX, а tabindex становится tabIndex.
  Использование дочерних элементов в JSX
    Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:
    Но JSX-теги могут и содержать дочерние элементы:
  JSX предотвращает атаки, основанные на инъекции кода
    По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
    Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).
  JSX представляет собой объекты
    Babel компилирует JSX в вызовы React.createElement().
    */
    const element = (
      <h1 className="greeting">
        Привет, мир!
      </h1>
    );
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Привет, мир!'
    );
    // React.createElement() проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой:
    // Примечание: этот код несколько упрощён.
    const element = {
      type: 'h1',
      props: {
        className: 'greeting',
        children: 'Привет, мир!'
      }
    };
    // Эти объекты называются React-элементами.
    /*
+Рендеринг элемента 
  В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.
  Рендеринг элемента в DOM
    Для рендеринга React-элемента, сперва передайте DOM-элемент в ReactDOM.createRoot(), далее передайте с React-элементом в root.render():
    */
    const root = ReactDOM.createRoot(
      document.getElementById('root')
    );
    const element = <h1>Hello, world</h1>;
    root.render(element);
    /*
  Обновление элементов на странице
    Элементы React иммутабельны. После создания элемента нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.
  React обновляет только то, что необходимо
    React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.
+Компоненты и пропсы
  Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.
  Функциональные и классовые компоненты
    Проще всего объявить React-компонент как функцию:
    */
    function Welcome(props) {
      return <h1>Привет, {props.name}</h1>;
    }
    /*
      Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.
    Ещё компоненты можно определять как классы ES6:
    */
    class Welcome extends React.Component {
      render() {
        return <h1>Привет, {this.props.name}</h1>;
      }
    }
    /*
  Как отрендерить компонент
    элементы могут описывать и наши собственные компоненты: const element = <Welcome name="Алиса" />;
      Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).
      */
      function Welcome(props) {
        return <h1>Привет, {props.name}</h1>;
      }
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      const element = <Welcome name="Алиса" />;
      root.render(element);
      /*
      Давайте разберём, что именно здесь происходит:
        1. Мы вызываем root.render() c React-элементом <Welcome name="Алиса" />.
        2. React вызывает наш компонент Welcome с пропсами {name: 'Алиса'}.
        3. Наш компонент Welcome возвращает элемент <h1>Привет, Алиса</h1> в качестве результата.
        4. React DOM делает минимальные изменения в DOM, чтобы получилось <h1>Привет, Алиса</h1>.
        Примечание: Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег.
  Композиция компонентов
    Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения.
  Извлечение компонентов
    Извлечение компонентов может сначала показаться неблагодарной работой. Тем не менее, в больших приложениях очень полезно иметь палитру компонентов, которые можно многократно использовать.
    Если вы не уверены, извлекать компонент или нет, вот простое правило. Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная (App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.
  Пропсы можно только читать
    Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    React достаточно гибкий, но есть одно правило, которое нельзя нарушать:
    React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
      Состояние даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая чистоту компонента.
+Состояние и жизненный цикл
  */
  class Clock extends React.Component {
    constructor(props) { 
      super(props); // Обратите внимание, что мы передаём props базовому (родительскому) конструктору: Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.
      this.state = {date: new Date()}; // Добавим конструктор класса, в котором укажем начальное состояние в переменной this.state:
    }
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
  
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
  
    tick() {
      this.setState({
        date: new Date()
      });
    }

    render() { // Метод render будет вызываться каждый раз, когда происходит обновление. Так как мы рендерим <Clock /> в один и тот же DOM-контейнер, мы используем единственный экземпляр класса Clock — поэтому мы можем задействовать внутреннее состояние и методы жизненного цикла.
      return (
        <div>
          <h1>Привет, мир!</h1>
          <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
        </div>
      );
    }
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<Clock />);
  /*
  Добавим методы жизненного цикла в класс
    В приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы, когда компоненты удаляются.
      -Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting). Нам нужно устанавливать таймер всякий раз, когда это происходит.
      -Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
      Эти методы называются «методами жизненного цикла» (lifecycle methods).
    Метод componentDidMount() запускается после того, как компонент отрендерился в DOM — здесь мы и установим таймер:
    */
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
    /*
    Обратите внимание, что мы сохраняем ID таймера в this (this.timerID).
    Поля this.props и this.state в классах — особенные, и их устанавливает сам React. Вы можете вручную добавить новые поля, если компоненту нужно хранить дополнительную информацию (например, ID таймера).
    Теперь нам осталось сбросить таймер в методе жизненного цикла componentWillUnmount():
    */
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
    /*
    Наконец, реализуем метод tick(). Он запускается таймером каждую секунду и вызывает this.setState().
    Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:
      1. Когда мы передаём <Clock /> в root.render(), React вызывает конструктор компонента. Clock должен отображать текущее время, поэтому мы задаём начальное состояние this.state объектом с текущим временем. Позже мы обновим это состояние.
      2. React вызывает метод render() компонента Clock. Таким образом React узнаёт, что отобразить на экране. Далее React обновляет DOM так, чтобы он соответствовал выводу рендера Clock.
      3. Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock указывает браузеру установить таймер, который будет вызывать tick() раз в секунду.
      4. Таймер вызывает tick() ежесекундно. Внутри tick() мы просим React обновить состояние компонента, вызывая setState() с текущим временем. React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM. Таким образом компонент Clock каждую секунду обновляет UI.
      5. Если компонент Clock когда-либо удалится из DOM, React вызовет метод жизненного цикла componentWillUnmount() и сбросит таймер.
  Как правильно использовать состояние
    Важно знать три детали о правильном применении setState().
      -Не изменяйте состояние напрямую this.state.comment = 'Привет'; Не делайте этого! Вместо этого используйте this.setState({comment: 'Привет'});
        Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.
      -Обновления состояния могут быть асинхронными
        React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
        Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
        Например, следующий код может не обновить счётчик:
        */ // Неправильно
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
        /*
        Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект.
        */
        // Правильно
        this.setState((state, props) => ({ // Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
          counter: state.counter + props.increment
        }));
        /*
      -Обновления состояния объединяются
        Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием.
        */ // Например, состояние может состоять из нескольких независимых полей:
        constructor(props) {
          super(props);
          this.state = {
            posts: [],
            comments: []
          };
        }
        // Их можно обновлять по отдельности с помощью отдельных вызовов setState():
        componentDidMount() {
          fetchPosts().then(response => {
            this.setState({
              posts: response.posts
            });
          });
      
          fetchComments().then(response => {
            this.setState({
              comments: response.comments
            });
          });
        }
        /* Состояния объединяются поверхностно, поэтому вызов this.setState({comments}) оставляет this.state.posts нетронутым, но полностью заменяет this.state.comments.
  Однонаправленный поток данных
    В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.
    Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
    Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов: <FormattedDate date={this.state.date} />. Они будут доступны как this.props.date в FormattedDate компоненте.
    Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:
    Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.
    Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.
    В React-приложениях, имеет ли компонент состояние или нет — это внутренняя деталь реализации компонента, которая может меняться со временем. Можно использовать компоненты без состояния в компонентах с состоянием, и наоборот.
+Обработка событий
  Обработка событий в React-элементах очень похожа на обработку событий в DOM-элементах. Но есть несколько синтаксических отличий:
    -События в React именуются в стиле camelCase вместо нижнего регистра.
    -С JSX вы передаёте функцию как обработчик события вместо строки. <button onClick={activateLasers}>Activate Lasers</button>
    -Ещё одно отличие — в React нельзя предотвратить обработчик события по умолчанию, вернув false. Нужно явно вызвать preventDefault.
    */
    function Form() {
      function handleSubmit(e) {
        e.preventDefault();
        console.log('Отправлена форма.');
      }
    
      return (
        <form onSubmit={handleSubmit}>
          <button type="submit">Отправить</button>
        </form>
      );
    }
    /*
    В приведённом выше коде e — это синтетическое событие. React определяет синтетические события в соответствии со спецификацией W3C, поэтому не волнуйтесь о кроссбраузерности.
    При использовании React обычно не нужно вызывать addEventListener, чтобы добавить обработчики в DOM-элемент после его создания. Вместо этого добавьте обработчик сразу после того, как элемент отрендерился.
    В компоненте, определённом с помощью ES6-класса, в качестве обработчика события обычно выступает один из методов класса. Например, этот компонент Toggle рендерит кнопку, которая позволяет пользователю переключать состояния между «Включено» и «Выключено»:
    */
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
    
        // Эта привязка обязательна для работы `this` в колбэке.
        this.handleClick = this.handleClick.bind(this);
      }
    
      handleClick() {
        this.setState(prevState => ({
          isToggleOn: !prevState.isToggleOn
        }));
      }
    
      render() {
        return (
          <button onClick={this.handleClick}>
            {this.state.isToggleOn ? 'Включено' : 'Выключено'}
          </button>
        );
      }
    }
    /*
    При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. Если вы забудете привязать метод this.handleClick и передать его в onClick, значение this будет undefined в момент вызова функции.
    Если вам не по душе bind, существует два других способа. Вы можете использовать синтаксис публичных полей класса чтобы правильно привязать колбэки:
    */ // Такой синтаксис доступен в Create React App по умолчанию.
    class LoggingButton extends React.Component {
      // Такой синтаксис гарантирует, что `this` привязан к handleClick.
      handleClick = () => {
        console.log('значение this:', this);
      };
      render() {
        return (
          <button onClick={this.handleClick}>
            Нажми на меня
          </button>
        );
      }
    }
    // Если вы не пользуетесь синтаксисом полей, можете попробовать стрелочные функции в колбэке:
    class LoggingButton extends React.Component {
      handleClick() {
        console.log('значение this:', this);
      }
    
      render() {
        // Такой синтаксис гарантирует, что `this` привязан к handleClick.
        return (
          <button onClick={() => this.handleClick()}>
            Нажми на меня
          </button>
        );
      }
    }
    /*
    Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
    Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
    Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
    */
    <>
  /*
  Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
  Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
  Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
  */
  <button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
  <button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button></>
  /*
  Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.
  В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются автоматически.
+ Условный рендеринг
  React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или прятать в зависимости от текущего состояния.
  Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. 
    В таких ситуациях используйте условный оператор JavaScript или выражения подобные if.
    Можно создать компонент Greeting, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:
    */ // В этом примере рендерится различное приветствие в зависимости от значения пропа isLoggedIn.
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
        return <UserGreeting />;
      }
      return <GuestGreeting />;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root')); 
    // Попробуйте заменить на isLoggedIn={true}:
    root.render(<Greeting isLoggedIn={false} />);
    /*
  Встроенные условия if с логическим оператором &&
    Вы можете внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор && языка JavaScript, которым можно удобно вставить элемент в зависимости от условия:
    {unreadMessages.length > 0 && <h2>У вас {unreadMessages.length} непрочитанных сообщений.</h2>}
    Приведённый выше вариант работает корректно, потому что в JavaScript-выражение true && expression всегда вычисляется как expression, а выражение false && expression — как false.
    То есть, если условие истинно (true), то элемент, идущий непосредственно за &&, будет передан на вывод. Если же оно ложно (false), то React проигнорирует и пропустит его.
    Обратите внимание, что ложное выражение, как ожидается, пропустит элемент после &&, но при этом выведет результат этого выражения. В примере ниже метод render вернёт <div>0</div>.
    */
    render() {
      const count = 0;
      return (
        <div>
          {count && <h1>Количество сообщений: {count}</h1>}
        </div>
      );
    }
    /*
  Встроенные условия if-else с тернарным оператором
    Есть ещё один способ писать условия прямо в JSX. Вы можете воспользоваться тернарным оператором condition ? true : false.
    Вот как этот метод можно использовать, чтобы отрендерить кусочек текста.
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          Пользователь <b>{isLoggedIn ? 'сейчас' : 'не'}</b> на сайте.
        </div>
      );
    }
    /*
    Этот метод можно использовать и с выражениями покрупнее, но это может сделать код менее очевидным:
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          {isLoggedIn
            ? <LogoutButton onClick={this.handleLogoutClick} />
            : <LoginButton onClick={this.handleLoginClick} />
          }
        </div>
      );
    }
    /* Как в JavaScript, так и в React выбор синтаксиса зависит от ваших предпочтений и принятого в команде стиля. Не забывайте, что если какое-то условие выглядит очень сложным, возможно пришло время извлечь часть кода в отдельный компонент.
  Предотвращение рендеринга компонента
    В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните null вместо того, что обычно возвращается на рендеринг.
    Например, будет ли содержимое <WarningBanner /> отрендерено, зависит от значения пропа под именем warn. Если значение false, компонент ничего не рендерит:
    Сам факт возврата null из метода render компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, componentDidUpdate будет всё равно вызван.
    */
    function WarningBanner(props) {
      if (!props.warn) {
        return null;
      }
    
      return (
        <div className="warning">
          Предупреждение!
        </div>
      );
    }
    /*
+ Списки и ключи
  Рендер нескольких компонентов
    Вы можете создать коллекцию элементов и встроить её в JSX с помощью фигурных скобок {}. К примеру, пройдём по массиву numbers, используя функцию JavaScript map(), и вернём элемент <li> в каждой итерации. Получившийся массив элементов сохраним в listItems:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li>{number}</li>
    );
    // Теперь мы включим массив listItems внутрь элемента <ul>:
    <ul>{listItems}</ul>
    /*
  Ключи
    Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li key={number.toString()}>
        {number}
      </li>
    );
    /*
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:
    Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:
    Мы не рекомендуем использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента.
    Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.
    Извлечение компонентов с ключами
      Ключи нужно определять непосредственно внутри массивов. Например, если вы извлекаете компонент ListItem, то нужно указывать ключ для <ListItem /> в массиве, а не в элементе <li> внутри самого ListItem.
      */
      function ListItem(props) {
        const value = props.value;
        return (
          // Неправильно! Нет необходимости задавать здесь ключ:
          <li key={value.toString()}>
            {value}
          </li>
        );
      }
      
      function NumberList(props) {
        const numbers = props.numbers;
        const listItems = numbers.map((number) =>
          // Неправильно! Ключ необходимо определить здесь:
          <ListItem value={number} /> // <ListItem key={number.toString()} value={number} />
        );
        return (
          <ul>
            {listItems}
          </ul>
        );
      }
      /*
    Ключи должны быть уникальными среди соседних элементов
      Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.
      Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты. Если в компоненте нужно то же самое значение, то передайте его явно через проп с другим именем:
  Встраивание map() в JSX
    JSX позволяет встроить любое выражение в фигурные скобки, так что мы можем включить результат выполнения map():
    */
    function NumberList(props) {
      const numbers = props.numbers;
      return (
        <ul>
          {numbers.map((number) =>
            <ListItem key={number.toString()}
                      value={number} />
          )}
        </ul>
      );
    }
    /* Иногда это приводит к более чистому коду, но бывает и наоборот. Как и в любом JavaScript-коде, вам придётся самостоятельно решать, стоит ли извлекать код в переменную ради читабельности.
+ Формы
  В React HTML-элементы формы ведут себя немного иначе по сравнению с DOM-элементами, так как у элементов формы изначально есть внутреннее состояние. К примеру, в эту HTML-форму можно ввести имя:
    */
    <form>
      <label>
        Имя:
        <input type="text" name="name" />
      </label>
      <input type="submit" value="Отправить" />
    </form>
    /*
    По умолчанию браузер переходит на другую страницу при отправке HTML-форм, в том числе и этой. Если вас это устраивает, то не надо ничего менять, в React формы работают как обычно. 
      Однако чаще всего форму удобнее обрабатывать с помощью JavaScript-функции, у которой есть доступ к введённым данным. Стандартный способ реализации такого поведения называется «управляемые компоненты».
  Управляемые компоненты
    В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
    Мы можем скомбинировать оба подхода и сделать состояние React-компонента «единственным источником правды». Тогда React-компонент будет рендерить форму и контролировать её поведение в ответ на пользовательский ввод. 
      Значение элемента формы input в этом случае будет контролировать React, а сам элемент будет называться «управляемый компонент».
      */
      class NameForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: ''};
      
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Отправленное имя: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Имя:
                <input type="text" value={this.state.value} onChange={this.handleChange} />
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      А так как каждое нажатие клавиши вызывает handleChange, который обновляет состояние React-компонента, значение в поле будет обновляться по мере того, как пользователь печатает.
      В управляемом компоненте значение поля ввода всегда определяется состоянием React. Хотя это означает, что вы должны написать немного больше кода, теперь вы сможете передать значение и другим UI-элементам или сбросить его с других обработчиков событий.
    Тег textarea
      В React <textarea> использует атрибут value. Таким образом, форму с <textarea> можно написать почти тем же способом, что и форму с однострочным <input>:
    Тег select
      */
      class FlavorForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: 'coconut'};
        
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Ваш любимый вкус: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Выберите ваш любимый вкус:
                <select value={this.state.value} onChange={this.handleChange}>
                  <option value="grapefruit">Грейпфрут</option>
                  <option value="lime">Лайм</option>
                  <option value="coconut">Кокос</option>
                  <option value="mango">Манго</option>
                </select>
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      Подводя итог, <input type="text">, <textarea>, и <select> работают очень похоже. Все они принимают атрибут value, который можно использовать, чтобы реализовать управляемый компонент.
      В атрибут value можно передать массив, что позволит выбрать несколько опций в теге select: <select multiple={true} value={['Б', 'В']}>
  Загрузка файла
    Так как значение такого элемента доступно только для чтения, это неуправляемый React-компонент.
  Обработка нескольких элементов input
    Если вам нужны несколько управляемых элементов input, вы можете назначить каждому из них атрибут name, что позволит функции-обработчику решать, что делать, основываясь на значении event.target.name.
    */
    class Reservation extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          isGoing: true,
          numberOfGuests: 2
        };
    
        this.handleInputChange = this.handleInputChange.bind(this);
      }
    
      handleInputChange(event) {
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;
    
        this.setState({
          [name]: value
        });
      }
    
      render() {
        return (
          <form>
            <label>
              Пойдут:
              <input
                name="isGoing"
                type="checkbox"
                checked={this.state.isGoing}
                onChange={this.handleInputChange} />
            </label>
            <br />
            <label>
              Количество гостей:
              <input
                name="numberOfGuests"
                type="number"
                value={this.state.numberOfGuests}
                onChange={this.handleInputChange} />
            </label>
          </form>
        );
      }
    }
    /* Кроме того, setState() автоматически производит слияние части состояния с текущим состоянием, то есть нам нужно передать в него только ту часть state, которую хотим изменить.
  Значение null управляемого компонента
    Если установить управляемому компоненту проп value, то пользователь не сможет изменить его значение без вашего желания. Если вы установили value, а поле ввода по-прежнему можно редактировать, то, возможно, вы случайно задали value, равный undefined или null.
  Альтернативы управляемым компонентам
    Использование управляемых компонентов иногда может быть утомительным. В такой ситуации могут пригодиться неуправляемые компоненты — альтернативная техника реализации ввода данных в форму. https://ru.reactjs.org/docs/uncontrolled-components.html
  Полноценные решения 
    react hook form
+ Подъём состояния
  Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. Давайте посмотрим, как это работает.
  В React совместное использование состояния достигается перемещением его до ближайшего предка компонентов, которым оно требуется. Это называется «подъём состояния». 
  */
  class Calculator extends React.Component {
    constructor(props) {
      super(props);
      this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
      this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
      this.state = {temperature: '', scale: 'c'};
    }
  
    handleCelsiusChange(temperature) {
      this.setState({scale: 'c', temperature});
    }
  
    handleFahrenheitChange(temperature) {
      this.setState({scale: 'f', temperature});
    }
  
    render() {
      const scale = this.state.scale;
      const temperature = this.state.temperature;
      const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
      const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
  
      return (
        <div>
          <TemperatureInput
            scale="c"
            temperature={celsius}
            onTemperatureChange={this.handleCelsiusChange} />
          <TemperatureInput
            scale="f"
            temperature={fahrenheit}
            onTemperatureChange={this.handleFahrenheitChange} />
          <BoilingVerdict
            celsius={parseFloat(celsius)} />
        </div>
      );
    }
  }
  /*
  Теперь, независимо от того, какое поле ввода вы редактируете, this.state.temperature и this.state.scale в Calculator обновляются. Одно из полей ввода получает значение как есть, поэтому введённые пользователем данные сохраняются, а значение другого поля ввода всегда пересчитывается на их основе.
    Давайте посмотрим, что происходит, когда вы редактируете поле ввода:
      -React вызывает функцию, указанную в onChange на DOM-элементе <input>. В нашем случае это метод handleChange() компонента TemperatureInput.
      -Метод handleChange() в компоненте TemperatureInput вызывает this.props.onTemperatureChange() с новым требуемым значением. Его пропсы, включая onTemperatureChange, были предоставлены его родительским компонентом — Calculator.
      -Когда Calculator рендерился ранее, он указал, что onTemperatureChange в компоненте TemperatureInput по шкале Цельсия — это метод handleCelsiusChange в компоненте Calculator, а onTemperatureChange компонента TemperatureInput по шкале Фаренгейта — это метод handleFahrenheitChange в компоненте Calculator. Поэтому один из этих двух методов Calculator вызывается в зависимости от того, какое поле ввода редактируется.
      -Внутри этих методов компонент Calculator указывает React сделать повторный рендер себя, используя вызов this.setState() со значением нового поля ввода и текущей шкалой.
      -React вызывает метод render() компонента Calculator, чтобы узнать, как должен выглядеть UI. Значения обоих полей ввода пересчитываются исходя из текущей температуры и шкалы. В этом методе выполняется конвертация температуры.
      -React вызывает методы render() конкретных компонентов TemperatureInput с их новыми пропсами, переданными компонентом Calculator. Он узнает, как должен выглядеть UI.
      -React вызывает метод render() компонента Boiling Verdict, передавая температуру в градусах Цельсия как проп.
      -React DOM обновляет DOM, чтобы привести его в соответствие с нужными нам значениями в полях ввода. Отредактированное нами только что поле ввода получает его текущее значение, а другое поле ввода обновляется конвертированным значением температуры.
      -Каждое обновление проходит через одни и те же шаги, поэтому поля ввода остаются синхронизированными.
  Извлечённые уроки
    Для любых изменяемых данных в React-приложении должен быть один «источник истины». Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.
      Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка. Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на однонаправленный поток данных.
    Для подъёма состояния приходится писать больше «шаблонного» кода, чем при подходах с двусторонней привязкой данных, но мы получаем преимущество в виде меньших затрат на поиск и изолирование багов.
      Так как любое состояние «живёт» в каком-нибудь компоненте, и только этот компонент может его изменить, количество мест с возможными багами значительно уменьшается. 
      Кроме того, вы можете реализовать любую пользовательскую логику для отклонения или преобразования данных, введённых пользователем.
    Если что-то может быть вычислено из пропсов или из состояния, то скорее всего оно не должно находиться в состоянии. Например, вместо сохранения celsiusValue и fahrenheitValue, мы сохраняем только последнюю введённую температуру (temperature) и её шкалу (scale). Значение другого поля ввода можно всегда вычислить из них в методе render().
      Это позволяет очистить или применить округление к значению другого поля, не теряя при этом точности значений, введённых пользователем.
    Когда вы видите, что в UI что-то отображается неправильно, то можете воспользоваться расширением React Developer Tools. С помощью него можно проверить пропсы и перемещаться по дереву компонентов вверх до тех пор, пока не найдёте тот компонент, который отвечает за обновление состояния. 
      Это позволяет отследить источник багов:
+ Композиция против наследования
  React имеет мощную модель композиции, поэтому для повторного использования кода между компонентами мы рекомендуем использовать композицию вместо наследования.
    В этой главе мы рассмотрим несколько проблем, которые новички в React решают наследованием и попробуем решить их с помощью композиции.
    Вставка
      Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.
      Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
      */
      function FancyBorder(props) {
        return (
          <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
          </div>
        );
      }
      // Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
      function WelcomeDialog() {
        return (
          <FancyBorder color="blue">
            <h1 className="Dialog-title">
              Добро пожаловать
            </h1>
            <p className="Dialog-message">
              Спасибо, что посетили наш космический корабль!
            </p>
          </FancyBorder>
        );
      }
      /*
      Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри <div>, все переданные элементы отображаются в конечном выводе.
      Иногда в компоненте необходимо иметь несколько мест для вставки. В таком случае можно придумать свой формат, а не использовать children:
      */
      function SplitPane(props) {
        return (
          <div className="SplitPane">
            <div className="SplitPane-left">
              {props.left}
            </div>
            <div className="SplitPane-right">
              {props.right}
            </div>
          </div>
        );
      }
      
      function App() {
        return (
          <SplitPane
            left={
              <Contacts />
            }
            right={
              <Chat />
            } />
        );
      }
      /* // Такие React-элементы, как <Contacts /> и <Chat /> являются просто объектами, поэтому их можно передать в виде пропсов, как и любые другие данные.
  Специализация
    Некоторые компоненты можно рассматривать как «частные случаи» других компонентов. Например, WelcomeDialog может быть частным случаем Dialog.
    В React это можно сделать через композицию, где «частный» вариант компонента рендерит более «общий» и настраивает его с помощью пропсов:
  Так что насчёт наследования?
    Пропсы и композиция дают вам всю гибкость, необходимую для настройки внешнего вида и поведения компонента явным и безопасным способом. Помните, что компоненты могут принимать произвольные пропсы, включая примитивные значения, React-элементы или функции.
    Если вы хотите повторно использовать не связанную с внешним видом функциональность между компонентами, извлеките её в отдельный JavaScript-модуль.
    Импортируйте его в компонент и используйте эту функцию, объект или класс, не расширяя их.
+ Введение в хуки
  Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
  Мотивация
    1. Трудно повторно использовать логику состояний между компонентами
      В React нет способа «присоединить» повторно используемое поведение к компоненту (например, подключение к хранилищу). Если вы работали с React какое-то время, то вам могут быть знакомы такие паттерны, как рендер-пропсы и компоненты 
      высшего порядка, которые пытаются решить эту проблему. Но эти паттерны заставляют вас изменять структуру компонентов, что делает код громоздким и трудным в поддержке. Если вы посмотрите на типичное React-приложение в React DevTools, 
      то увидите «ад обёрток» из компонентов, окружённых провайдерами, консьюмерами, компонентами высшего порядка, рендер-пропсами и другими абстракциями.
    -С помощью хуков вы можете извлечь логику состояния из компонента, чтобы её протестировать или повторно использовать. Хуки позволяют вам повторно использовать логику состояния, не затрагивая дерево компонентов. 
      Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с сообществом.
    2. Сложные компоненты становятся трудными для понимания
      Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в неуправляемый беспорядок, состоящий из логики состояния и побочных эффектов.
      Каждый метод жизненного цикла часто содержит смесь несвязанной логики. Например, компоненты могут загружать данные в componentDidMount и componentDidUpdate. Однако тот же метод componentDidMount может содержать несвязанную логику, 
      которая добавляет обработчики события с отменой подписки в componentWillUnmount. Взаимосвязанный код, который изменяется вместе, разделяется, но совершенно несвязанный код в конечном итоге объединяется в один метод. Это легко приводит 
      к багам и несоответствиям в приложении. В некоторых случаях невозможно разбить компоненты на более мелкие, потому что логика состояния раскидана повсюду. Такие компоненты сложно тестировать. Это одна из причин, по которой люди предпочитают 
      использовать в React отдельную библиотеку для управления состоянием. Однако, это добавляет множество абстракций, заставляет прыгать между разными файлами и усложняет повторное использование компонентов.
    -Чтобы решить эту проблему, хуки позволяют разбить один компонент на маленькие функции по их назначению (например, подписке или загрузке данных), а не на основе методов жизненного цикла. Вы также можете контролировать внутреннее состояние 
      с помощью редюсера, чтобы поведение было более предсказуемым.
    3. Классы путают как людей, так и машины
      Вдобавок к усложнению организации кода и его повторного использования, классы создают существенный барьер в изучении React. Нужно понимать, как работает this в JavaScript, поведение которого отличается от большинства языков.
      Приходится помнить про привязку контекста для обработчиков событий. Без использования ES2022 публичных полей класса, код становится многословным. Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, 
      но всё равно путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда их использовать, приводят к разногласиям даже между опытными React-разработчиками. Однако мы заметили, что классовые 
      компоненты могут приводить к ненамеренным паттернам, сводящим оптимизации на нет. Классы создают сложности для инструментов и сегодня. Например, классы плохо минифицируются, а горячая перезагрузка (hot reloading) ненадёжна и 
      часто ломает их. Наша цель — предоставить API, который повысит вероятность того, что код можно будет оптимизировать.
    -Чтобы решить эти проблемы, хуки позволяют использовать больше возможностей React без написания классов. Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к функционалу, но не обесценивают опыт использования React.
      Хуки предоставляют императивные лазейки и не требуют от вас изучения сложных функциональных или реактивных подходов.
+ useState
  Что такое хук?
    Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. 
  Когда применить хук? 
    Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента.
  Что делает вызов useState?
    Он объявляет «переменную состояния». Мы называли переменную count, но могли дать ей любое имя, хоть банан. Таким образом мы можем «сохранить» некоторые значения между вызовами функции. useState — это новый способ использовать те же возможности, 
    что даёт this.state в классах. Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не относится, потому что их сохраняет React.
  Какие аргументы передавать useState?
    Единственный аргумент useState — это исходное состояние. В отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так удобно.
  Что возвращается из useState?
    Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. Поэтому мы пишем const [count, setCount] = useState().
  Теперь мы знаем, что делает useState, и пример должен быть ясен:
  */
  import React, { useState } from 'react';

  function Example() {
    // Объявление новой переменной состояния «count»
    const [count, setCount] = useState(0);
  /*
  Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить count, мы вызовем setCount.
  
  1. useState асинхронно менякт значение! И новое значение мы сможем увидеть только при следующем рендере! Даже если мы 2 раза вызовем setCount(counter + 1), то значение count изменится только один раз!
    И если нужно использовать новое значение сразу, то нужно использовать функцию в качестве аргумента! setCount((prevCount) => prevCount + 1);
  2. Обратите внимание, что, в отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.
    */ // так же и с массивом!
    const [state, setState] = useState({ count: 0, theme: 'blue' });
    setState(prevState => {
      return { ...prevState, count: prevState.count + 1 }
    }
    /*
  3. Инициализационное значение хоть и отбрасывается, но все равно создается при каждом рендере. И если там сложное вычисление, то лучше передавать не вычисленное значение, а функцию, которая будет вычислять это значение только тогда, когда оно действительно понадобится.
    Пример: const [count, setCount] = useState(() => 10);












  */