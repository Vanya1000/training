/* 
+JSX — расширение языка JavaScript. JSX производит «элементы» React.
  JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, 2 + 2, user.firstName и formatName(user) являются допустимыми выражениями.
  JSX это тоже выражение. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
  Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
  */
  function getGreeting(user) {
    if (user) {
      return <h1>Здравствуй, {formatName(user)}!</h1>;
    }
    return <h1>Здравствуй, незнакомец.</h1>;
  }
  /*
  Использование атрибутов JSX
    Чтобы использовать строковый литерал в качестве значения атрибута, используются кавычки:
    Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
    */
    const element = <a href="https://www.reactjs.org"> link </a>;
    const element = <img src={user.avatarUrl}></img>;
    /* 
    Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в значении атрибута. Следует либо применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
    Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. class становится className в JSX, а tabindex становится tabIndex.
  Использование дочерних элементов в JSX
    Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:
    Но JSX-теги могут и содержать дочерние элементы:
  JSX предотвращает атаки, основанные на инъекции кода
    По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
    Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).
  JSX представляет собой объекты
    Babel компилирует JSX в вызовы React.createElement().
    */
    const element = (
      <h1 className="greeting">
        Привет, мир!
      </h1>
    );
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Привет, мир!'
    );
    // React.createElement() проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой:
    // Примечание: этот код несколько упрощён.
    const element = {
      type: 'h1',
      props: {
        className: 'greeting',
        children: 'Привет, мир!'
      }
    };
    // Эти объекты называются React-элементами.
    /*
+Рендеринг элемента 
  В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.
  Рендеринг элемента в DOM
    Для рендеринга React-элемента, сперва передайте DOM-элемент в ReactDOM.createRoot(), далее передайте с React-элементом в root.render():
    */
    const root = ReactDOM.createRoot(
      document.getElementById('root')
    );
    const element = <h1>Hello, world</h1>;
    root.render(element);
    /*
  Обновление элементов на странице
    Элементы React иммутабельны. После создания элемента нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.
  React обновляет только то, что необходимо
    React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.
+Компоненты и пропсы
  Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.
  Функциональные и классовые компоненты
    Проще всего объявить React-компонент как функцию:
    */
    function Welcome(props) {
      return <h1>Привет, {props.name}</h1>;
    }
    /*
      Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.
    Ещё компоненты можно определять как классы ES6:
    */
    class Welcome extends React.Component {
      render() {
        return <h1>Привет, {this.props.name}</h1>;
      }
    }
    /*
  Как отрендерить компонент
    элементы могут описывать и наши собственные компоненты: const element = <Welcome name="Алиса" />;
      Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).
      */
      function Welcome(props) {
        return <h1>Привет, {props.name}</h1>;
      }
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      const element = <Welcome name="Алиса" />;
      root.render(element);
      /*
      Давайте разберём, что именно здесь происходит:
        1. Мы вызываем root.render() c React-элементом <Welcome name="Алиса" />.
        2. React вызывает наш компонент Welcome с пропсами {name: 'Алиса'}.
        3. Наш компонент Welcome возвращает элемент <h1>Привет, Алиса</h1> в качестве результата.
        4. React DOM делает минимальные изменения в DOM, чтобы получилось <h1>Привет, Алиса</h1>.
        Примечание: Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег.
  Композиция компонентов
    Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения.
  Извлечение компонентов
    Извлечение компонентов может сначала показаться неблагодарной работой. Тем не менее, в больших приложениях очень полезно иметь палитру компонентов, которые можно многократно использовать.
    Если вы не уверены, извлекать компонент или нет, вот простое правило. Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная (App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.
  Пропсы можно только читать
    Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    React достаточно гибкий, но есть одно правило, которое нельзя нарушать:
    React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
      Состояние даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая чистоту компонента.
+Состояние и жизненный цикл
  */
  class Clock extends React.Component {
    constructor(props) { 
      super(props); // Обратите внимание, что мы передаём props базовому (родительскому) конструктору: Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.
      this.state = {date: new Date()}; // Добавим конструктор класса, в котором укажем начальное состояние в переменной this.state:
    }
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
  
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
  
    tick() {
      this.setState({
        date: new Date()
      });
    }

    render() { // Метод render будет вызываться каждый раз, когда происходит обновление. Так как мы рендерим <Clock /> в один и тот же DOM-контейнер, мы используем единственный экземпляр класса Clock — поэтому мы можем задействовать внутреннее состояние и методы жизненного цикла.
      return (
        <div>
          <h1>Привет, мир!</h1>
          <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
        </div>
      );
    }
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<Clock />);
  /*
  Добавим методы жизненного цикла в класс
    В приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы, когда компоненты удаляются.
      -Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting). Нам нужно устанавливать таймер всякий раз, когда это происходит.
      -Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
      Эти методы называются «методами жизненного цикла» (lifecycle methods).
    Метод componentDidMount() запускается после того, как компонент отрендерился в DOM — здесь мы и установим таймер:
    */
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
    /*
    Обратите внимание, что мы сохраняем ID таймера в this (this.timerID).
    Поля this.props и this.state в классах — особенные, и их устанавливает сам React. Вы можете вручную добавить новые поля, если компоненту нужно хранить дополнительную информацию (например, ID таймера).
    Теперь нам осталось сбросить таймер в методе жизненного цикла componentWillUnmount():
    */
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
    /*
    Наконец, реализуем метод tick(). Он запускается таймером каждую секунду и вызывает this.setState().
    Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:
      1. Когда мы передаём <Clock /> в root.render(), React вызывает конструктор компонента. Clock должен отображать текущее время, поэтому мы задаём начальное состояние this.state объектом с текущим временем. Позже мы обновим это состояние.
      2. React вызывает метод render() компонента Clock. Таким образом React узнаёт, что отобразить на экране. Далее React обновляет DOM так, чтобы он соответствовал выводу рендера Clock.
      3. Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock указывает браузеру установить таймер, который будет вызывать tick() раз в секунду.
      4. Таймер вызывает tick() ежесекундно. Внутри tick() мы просим React обновить состояние компонента, вызывая setState() с текущим временем. React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM. Таким образом компонент Clock каждую секунду обновляет UI.
      5. Если компонент Clock когда-либо удалится из DOM, React вызовет метод жизненного цикла componentWillUnmount() и сбросит таймер.
  Как правильно использовать состояние
    Важно знать три детали о правильном применении setState().
      -


  */
  