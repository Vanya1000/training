/* 
+JSX — расширение языка JavaScript. JSX производит «элементы» React.
  JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, 2 + 2, user.firstName и formatName(user) являются допустимыми выражениями.
  JSX это тоже выражение. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
  Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
  */
  function getGreeting(user) {
    if (user) {
      return <h1>Здравствуй, {formatName(user)}!</h1>;
    }
    return <h1>Здравствуй, незнакомец.</h1>;
  }
  /*
  Использование атрибутов JSX
    Чтобы использовать строковый литерал в качестве значения атрибута, используются кавычки:
    Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
    */
    const element = <a href="https://www.reactjs.org"> link </a>;
    const element = <img src={user.avatarUrl}></img>;
    /* 
    Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в значении атрибута. Следует либо применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
    Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. class становится className в JSX, а tabindex становится tabIndex.
  Использование дочерних элементов в JSX
    Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:
    Но JSX-теги могут и содержать дочерние элементы:
  JSX предотвращает атаки, основанные на инъекции кода
    По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
    Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).
  JSX представляет собой объекты
    Babel компилирует JSX в вызовы React.createElement().
    */
    const element = (
      <h1 className="greeting">
        Привет, мир!
      </h1>
    );
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Привет, мир!'
    );
    // React.createElement() проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой:
    // Примечание: этот код несколько упрощён.
    const element = {
      type: 'h1',
      props: {
        className: 'greeting',
        children: 'Привет, мир!'
      }
    };
    // Эти объекты называются React-элементами.
    /*
+Рендеринг элемента 
  В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.
  Рендеринг элемента в DOM
    Для рендеринга React-элемента, сперва передайте DOM-элемент в ReactDOM.createRoot(), далее передайте с React-элементом в root.render():
    */
    const root = ReactDOM.createRoot(
      document.getElementById('root')
    );
    const element = <h1>Hello, world</h1>;
    root.render(element);
    /*
  Обновление элементов на странице
    Элементы React иммутабельны. После создания элемента нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.
  React обновляет только то, что необходимо
    React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.
+Компоненты и пропсы
  Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.
  Функциональные и классовые компоненты
    Проще всего объявить React-компонент как функцию:
    */
    function Welcome(props) {
      return <h1>Привет, {props.name}</h1>;
    }
    /*
      Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.
    Ещё компоненты можно определять как классы ES6:
    */
    class Welcome extends React.Component {
      render() {
        return <h1>Привет, {this.props.name}</h1>;
      }
    }
    /*
  Как отрендерить компонент
    элементы могут описывать и наши собственные компоненты: const element = <Welcome name="Алиса" />;
      Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).
      */
      function Welcome(props) {
        return <h1>Привет, {props.name}</h1>;
      }
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      const element = <Welcome name="Алиса" />;
      root.render(element);
      /*
      Давайте разберём, что именно здесь происходит:
        1. Мы вызываем root.render() c React-элементом <Welcome name="Алиса" />.
        2. React вызывает наш компонент Welcome с пропсами {name: 'Алиса'}.
        3. Наш компонент Welcome возвращает элемент <h1>Привет, Алиса</h1> в качестве результата.
        4. React DOM делает минимальные изменения в DOM, чтобы получилось <h1>Привет, Алиса</h1>.
        Примечание: Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег.
  Композиция компонентов
    Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения.
  Извлечение компонентов
    Извлечение компонентов может сначала показаться неблагодарной работой. Тем не менее, в больших приложениях очень полезно иметь палитру компонентов, которые можно многократно использовать.
    Если вы не уверены, извлекать компонент или нет, вот простое правило. Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная (App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.
  Пропсы можно только читать
    Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
    React достаточно гибкий, но есть одно правило, которое нельзя нарушать:
    React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
      Состояние даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая чистоту компонента.
+Состояние и жизненный цикл
  */
  class Clock extends React.Component {
    constructor(props) { 
      super(props); // Обратите внимание, что мы передаём props базовому (родительскому) конструктору: Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.
      this.state = {date: new Date()}; // Добавим конструктор класса, в котором укажем начальное состояние в переменной this.state:
    }
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
  
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
  
    tick() {
      this.setState({
        date: new Date()
      });
    }

    render() { // Метод render будет вызываться каждый раз, когда происходит обновление. Так как мы рендерим <Clock /> в один и тот же DOM-контейнер, мы используем единственный экземпляр класса Clock — поэтому мы можем задействовать внутреннее состояние и методы жизненного цикла.
      return (
        <div>
          <h1>Привет, мир!</h1>
          <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
        </div>
      );
    }
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<Clock />);
  /*
  Добавим методы жизненного цикла в класс
    В приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы, когда компоненты удаляются.
      -Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting). Нам нужно устанавливать таймер всякий раз, когда это происходит.
      -Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
      Эти методы называются «методами жизненного цикла» (lifecycle methods).
    Метод componentDidMount() запускается после того, как компонент отрендерился в DOM — здесь мы и установим таймер:
    */
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }
    /*
    Обратите внимание, что мы сохраняем ID таймера в this (this.timerID).
    Поля this.props и this.state в классах — особенные, и их устанавливает сам React. Вы можете вручную добавить новые поля, если компоненту нужно хранить дополнительную информацию (например, ID таймера).
    Теперь нам осталось сбросить таймер в методе жизненного цикла componentWillUnmount():
    */
    componentWillUnmount() {
      clearInterval(this.timerID);
    }
    /*
    Наконец, реализуем метод tick(). Он запускается таймером каждую секунду и вызывает this.setState().
    Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:
      1. Когда мы передаём <Clock /> в root.render(), React вызывает конструктор компонента. Clock должен отображать текущее время, поэтому мы задаём начальное состояние this.state объектом с текущим временем. Позже мы обновим это состояние.
      2. React вызывает метод render() компонента Clock. Таким образом React узнаёт, что отобразить на экране. Далее React обновляет DOM так, чтобы он соответствовал выводу рендера Clock.
      3. Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock указывает браузеру установить таймер, который будет вызывать tick() раз в секунду.
      4. Таймер вызывает tick() ежесекундно. Внутри tick() мы просим React обновить состояние компонента, вызывая setState() с текущим временем. React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM. Таким образом компонент Clock каждую секунду обновляет UI.
      5. Если компонент Clock когда-либо удалится из DOM, React вызовет метод жизненного цикла componentWillUnmount() и сбросит таймер.
  Как правильно использовать состояние
    Важно знать три детали о правильном применении setState().
      -Не изменяйте состояние напрямую this.state.comment = 'Привет'; Не делайте этого! Вместо этого используйте this.setState({comment: 'Привет'});
        Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.
      -Обновления состояния могут быть асинхронными
        React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.
        Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.
        Например, следующий код может не обновить счётчик:
        */ // Неправильно
        this.setState({
          counter: this.state.counter + this.props.increment,
        });
        /*
        Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект.
        */
        // Правильно
        this.setState((state, props) => ({ // Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
          counter: state.counter + props.increment
        }));
        /*
      -Обновления состояния объединяются
        Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием.
        */ // Например, состояние может состоять из нескольких независимых полей:
        constructor(props) {
          super(props);
          this.state = {
            posts: [],
            comments: []
          };
        }
        // Их можно обновлять по отдельности с помощью отдельных вызовов setState():
        componentDidMount() {
          fetchPosts().then(response => {
            this.setState({
              posts: response.posts
            });
          });
      
          fetchComments().then(response => {
            this.setState({
              comments: response.comments
            });
          });
        }
        /* Состояния объединяются поверхностно, поэтому вызов this.setState({comments}) оставляет this.state.posts нетронутым, но полностью заменяет this.state.comments.
  Однонаправленный поток данных
    В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.
    Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
    Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов: <FormattedDate date={this.state.date} />. Они будут доступны как this.props.date в FormattedDate компоненте.
    Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:
    Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.
    Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.
    В React-приложениях, имеет ли компонент состояние или нет — это внутренняя деталь реализации компонента, которая может меняться со временем. Можно использовать компоненты без состояния в компонентах с состоянием, и наоборот.
+Обработка событий
  Обработка событий в React-элементах очень похожа на обработку событий в DOM-элементах. Но есть несколько синтаксических отличий:
    -События в React именуются в стиле camelCase вместо нижнего регистра.
    -С JSX вы передаёте функцию как обработчик события вместо строки. <button onClick={activateLasers}>Activate Lasers</button>
    -Ещё одно отличие — в React нельзя предотвратить обработчик события по умолчанию, вернув false. Нужно явно вызвать preventDefault.
    */
    function Form() {
      function handleSubmit(e) {
        e.preventDefault();
        console.log('Отправлена форма.');
      }
    
      return (
        <form onSubmit={handleSubmit}>
          <button type="submit">Отправить</button>
        </form>
      );
    }
    /*
    В приведённом выше коде e — это синтетическое событие. React определяет синтетические события в соответствии со спецификацией W3C, поэтому не волнуйтесь о кроссбраузерности.
    При использовании React обычно не нужно вызывать addEventListener, чтобы добавить обработчики в DOM-элемент после его создания. Вместо этого добавьте обработчик сразу после того, как элемент отрендерился.
    В компоненте, определённом с помощью ES6-класса, в качестве обработчика события обычно выступает один из методов класса. Например, этот компонент Toggle рендерит кнопку, которая позволяет пользователю переключать состояния между «Включено» и «Выключено»:
    */
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};
    
        // Эта привязка обязательна для работы `this` в колбэке.
        this.handleClick = this.handleClick.bind(this);
      }
    
      handleClick() {
        this.setState(prevState => ({
          isToggleOn: !prevState.isToggleOn
        }));
      }
    
      render() {
        return (
          <button onClick={this.handleClick}>
            {this.state.isToggleOn ? 'Включено' : 'Выключено'}
          </button>
        );
      }
    }
    /*
    При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. Если вы забудете привязать метод this.handleClick и передать его в onClick, значение this будет undefined в момент вызова функции.
    Если вам не по душе bind, существует два других способа. Вы можете использовать синтаксис публичных полей класса чтобы правильно привязать колбэки:
    */ // Такой синтаксис доступен в Create React App по умолчанию.
    class LoggingButton extends React.Component {
      // Такой синтаксис гарантирует, что `this` привязан к handleClick.
      handleClick = () => {
        console.log('значение this:', this);
      };
      render() {
        return (
          <button onClick={this.handleClick}>
            Нажми на меня
          </button>
        );
      }
    }
    // Если вы не пользуетесь синтаксисом полей, можете попробовать стрелочные функции в колбэке:
    class LoggingButton extends React.Component {
      handleClick() {
        console.log('значение this:', this);
      }
    
      render() {
        // Такой синтаксис гарантирует, что `this` привязан к handleClick.
        return (
          <button onClick={() => this.handleClick()}>
            Нажми на меня
          </button>
        );
      }
    }
    /*
    Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
    Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
    Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
    */
    <>
  /*
  Проблема этого синтаксиса в том, что при каждом рендере LoggingButton создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
  Мы рекомендуем делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью.
  Передача аргументов в обработчики событий
  Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если id — это идентификатор строки, можно использовать следующие варианты:
  */
  <button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
  <button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button></>
  /*
  Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.
  В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются автоматически.
+ Условный рендеринг
  React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или прятать в зависимости от текущего состояния.
  Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. 
    В таких ситуациях используйте условный оператор JavaScript или выражения подобные if.
    Можно создать компонент Greeting, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:
    */ // В этом примере рендерится различное приветствие в зависимости от значения пропа isLoggedIn.
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
        return <UserGreeting />;
      }
      return <GuestGreeting />;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root')); 
    // Попробуйте заменить на isLoggedIn={true}:
    root.render(<Greeting isLoggedIn={false} />);
    /*
  Встроенные условия if с логическим оператором &&
    Вы можете внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор && языка JavaScript, которым можно удобно вставить элемент в зависимости от условия:
    {unreadMessages.length > 0 && <h2>У вас {unreadMessages.length} непрочитанных сообщений.</h2>}
    Приведённый выше вариант работает корректно, потому что в JavaScript-выражение true && expression всегда вычисляется как expression, а выражение false && expression — как false.
    То есть, если условие истинно (true), то элемент, идущий непосредственно за &&, будет передан на вывод. Если же оно ложно (false), то React проигнорирует и пропустит его.
    Обратите внимание, что ложное выражение, как ожидается, пропустит элемент после &&, но при этом выведет результат этого выражения. В примере ниже метод render вернёт <div>0</div>.
    */
    render() {
      const count = 0;
      return (
        <div>
          {count && <h1>Количество сообщений: {count}</h1>}
        </div>
      );
    }
    /*
  Встроенные условия if-else с тернарным оператором
    Есть ещё один способ писать условия прямо в JSX. Вы можете воспользоваться тернарным оператором condition ? true : false.
    Вот как этот метод можно использовать, чтобы отрендерить кусочек текста.
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          Пользователь <b>{isLoggedIn ? 'сейчас' : 'не'}</b> на сайте.
        </div>
      );
    }
    /*
    Этот метод можно использовать и с выражениями покрупнее, но это может сделать код менее очевидным:
    */
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        <div>
          {isLoggedIn
            ? <LogoutButton onClick={this.handleLogoutClick} />
            : <LoginButton onClick={this.handleLoginClick} />
          }
        </div>
      );
    }
    /* Как в JavaScript, так и в React выбор синтаксиса зависит от ваших предпочтений и принятого в команде стиля. Не забывайте, что если какое-то условие выглядит очень сложным, возможно пришло время извлечь часть кода в отдельный компонент.
  Предотвращение рендеринга компонента
    В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните null вместо того, что обычно возвращается на рендеринг.
    Например, будет ли содержимое <WarningBanner /> отрендерено, зависит от значения пропа под именем warn. Если значение false, компонент ничего не рендерит:
    Сам факт возврата null из метода render компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, componentDidUpdate будет всё равно вызван.
    */
    function WarningBanner(props) {
      if (!props.warn) {
        return null;
      }
    
      return (
        <div className="warning">
          Предупреждение!
        </div>
      );
    }
    /*
+ Списки и ключи
  Рендер нескольких компонентов
    Вы можете создать коллекцию элементов и встроить её в JSX с помощью фигурных скобок {}. К примеру, пройдём по массиву numbers, используя функцию JavaScript map(), и вернём элемент <li> в каждой итерации. Получившийся массив элементов сохраним в listItems:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li>{number}</li>
    );
    // Теперь мы включим массив listItems внутрь элемента <ul>:
    <ul>{listItems}</ul>
    /*
  Ключи
    Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:
    */
    const numbers = [1, 2, 3, 4, 5];
    const listItems = numbers.map((number) =>
      <li key={number.toString()}>
        {number}
      </li>
    );
    /*
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:
    Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:
    Мы не рекомендуем использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента.
    Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.
    Извлечение компонентов с ключами
      Ключи нужно определять непосредственно внутри массивов. Например, если вы извлекаете компонент ListItem, то нужно указывать ключ для <ListItem /> в массиве, а не в элементе <li> внутри самого ListItem.
      */
      function ListItem(props) {
        const value = props.value;
        return (
          // Неправильно! Нет необходимости задавать здесь ключ:
          <li key={value.toString()}>
            {value}
          </li>
        );
      }
      
      function NumberList(props) {
        const numbers = props.numbers;
        const listItems = numbers.map((number) =>
          // Неправильно! Ключ необходимо определить здесь:
          <ListItem value={number} /> // <ListItem key={number.toString()} value={number} />
        );
        return (
          <ul>
            {listItems}
          </ul>
        );
      }
      /*
    Ключи должны быть уникальными среди соседних элементов
      Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.
      Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты. Если в компоненте нужно то же самое значение, то передайте его явно через проп с другим именем:
  Встраивание map() в JSX
    JSX позволяет встроить любое выражение в фигурные скобки, так что мы можем включить результат выполнения map():
    */
    function NumberList(props) {
      const numbers = props.numbers;
      return (
        <ul>
          {numbers.map((number) =>
            <ListItem key={number.toString()}
                      value={number} />
          )}
        </ul>
      );
    }
    /* Иногда это приводит к более чистому коду, но бывает и наоборот. Как и в любом JavaScript-коде, вам придётся самостоятельно решать, стоит ли извлекать код в переменную ради читабельности.
+ Формы
  В React HTML-элементы формы ведут себя немного иначе по сравнению с DOM-элементами, так как у элементов формы изначально есть внутреннее состояние. К примеру, в эту HTML-форму можно ввести имя:
    */
    <form>
      <label>
        Имя:
        <input type="text" name="name" />
      </label>
      <input type="submit" value="Отправить" />
    </form>
    /*
    По умолчанию браузер переходит на другую страницу при отправке HTML-форм, в том числе и этой. Если вас это устраивает, то не надо ничего менять, в React формы работают как обычно. 
      Однако чаще всего форму удобнее обрабатывать с помощью JavaScript-функции, у которой есть доступ к введённым данным. Стандартный способ реализации такого поведения называется «управляемые компоненты».
  Управляемые компоненты
    В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
    Мы можем скомбинировать оба подхода и сделать состояние React-компонента «единственным источником правды». Тогда React-компонент будет рендерить форму и контролировать её поведение в ответ на пользовательский ввод. 
      Значение элемента формы input в этом случае будет контролировать React, а сам элемент будет называться «управляемый компонент».
      */
      class NameForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: ''};
      
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Отправленное имя: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Имя:
                <input type="text" value={this.state.value} onChange={this.handleChange} />
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      А так как каждое нажатие клавиши вызывает handleChange, который обновляет состояние React-компонента, значение в поле будет обновляться по мере того, как пользователь печатает.
      В управляемом компоненте значение поля ввода всегда определяется состоянием React. Хотя это означает, что вы должны написать немного больше кода, теперь вы сможете передать значение и другим UI-элементам или сбросить его с других обработчиков событий.
    Тег textarea
      В React <textarea> использует атрибут value. Таким образом, форму с <textarea> можно написать почти тем же способом, что и форму с однострочным <input>:
    Тег select
      */
      class FlavorForm extends React.Component {
        constructor(props) {
          super(props);
          this.state = {value: 'coconut'};
        
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }
      
        handleChange(event) {
          this.setState({value: event.target.value});
        }
      
        handleSubmit(event) {
          alert('Ваш любимый вкус: ' + this.state.value);
          event.preventDefault();
        }
      
        render() {
          return (
            <form onSubmit={this.handleSubmit}>
              <label>
                Выберите ваш любимый вкус:
                <select value={this.state.value} onChange={this.handleChange}>
                  <option value="grapefruit">Грейпфрут</option>
                  <option value="lime">Лайм</option>
                  <option value="coconut">Кокос</option>
                  <option value="mango">Манго</option>
                </select>
              </label>
              <input type="submit" value="Отправить" />
            </form>
          );
        }
      }
      /*
      Подводя итог, <input type="text">, <textarea>, и <select> работают очень похоже. Все они принимают атрибут value, который можно использовать, чтобы реализовать управляемый компонент.
      В атрибут value можно передать массив, что позволит выбрать несколько опций в теге select: <select multiple={true} value={['Б', 'В']}>
  Загрузка файла
    Так как значение такого элемента доступно только для чтения, это неуправляемый React-компонент.
  Обработка нескольких элементов input
    Если вам нужны несколько управляемых элементов input, вы можете назначить каждому из них атрибут name, что позволит функции-обработчику решать, что делать, основываясь на значении event.target.name.
    */
    class Reservation extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          isGoing: true,
          numberOfGuests: 2
        };
    
        this.handleInputChange = this.handleInputChange.bind(this);
      }
    
      handleInputChange(event) {
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;
    
        this.setState({
          [name]: value
        });
      }
    
      render() {
        return (
          <form>
            <label>
              Пойдут:
              <input
                name="isGoing"
                type="checkbox"
                checked={this.state.isGoing}
                onChange={this.handleInputChange} />
            </label>
            <br />
            <label>
              Количество гостей:
              <input
                name="numberOfGuests"
                type="number"
                value={this.state.numberOfGuests}
                onChange={this.handleInputChange} />
            </label>
          </form>
        );
      }
    }
    /* Кроме того, setState() автоматически производит слияние части состояния с текущим состоянием, то есть нам нужно передать в него только ту часть state, которую хотим изменить.
  Значение null управляемого компонента
    Если установить управляемому компоненту проп value, то пользователь не сможет изменить его значение без вашего желания. Если вы установили value, а поле ввода по-прежнему можно редактировать, то, возможно, вы случайно задали value, равный undefined или null.
  Альтернативы управляемым компонентам
    Использование управляемых компонентов иногда может быть утомительным. В такой ситуации могут пригодиться неуправляемые компоненты — альтернативная техника реализации ввода данных в форму. https://ru.reactjs.org/docs/uncontrolled-components.html
  Полноценные решения 
    react hook form
+ Подъём состояния
  Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. Давайте посмотрим, как это работает.
  В React совместное использование состояния достигается перемещением его до ближайшего предка компонентов, которым оно требуется. Это называется «подъём состояния». 
  */
  class Calculator extends React.Component {
    constructor(props) {
      super(props);
      this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
      this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
      this.state = {temperature: '', scale: 'c'};
    }
  
    handleCelsiusChange(temperature) {
      this.setState({scale: 'c', temperature});
    }
  
    handleFahrenheitChange(temperature) {
      this.setState({scale: 'f', temperature});
    }
  
    render() {
      const scale = this.state.scale;
      const temperature = this.state.temperature;
      const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
      const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
  
      return (
        <div>
          <TemperatureInput
            scale="c"
            temperature={celsius}
            onTemperatureChange={this.handleCelsiusChange} />
          <TemperatureInput
            scale="f"
            temperature={fahrenheit}
            onTemperatureChange={this.handleFahrenheitChange} />
          <BoilingVerdict
            celsius={parseFloat(celsius)} />
        </div>
      );
    }
  }
  /*
  Теперь, независимо от того, какое поле ввода вы редактируете, this.state.temperature и this.state.scale в Calculator обновляются. Одно из полей ввода получает значение как есть, поэтому введённые пользователем данные сохраняются, а значение другого поля ввода всегда пересчитывается на их основе.
    Давайте посмотрим, что происходит, когда вы редактируете поле ввода:
      -React вызывает функцию, указанную в onChange на DOM-элементе <input>. В нашем случае это метод handleChange() компонента TemperatureInput.
      -Метод handleChange() в компоненте TemperatureInput вызывает this.props.onTemperatureChange() с новым требуемым значением. Его пропсы, включая onTemperatureChange, были предоставлены его родительским компонентом — Calculator.
      -Когда Calculator рендерился ранее, он указал, что onTemperatureChange в компоненте TemperatureInput по шкале Цельсия — это метод handleCelsiusChange в компоненте Calculator, а onTemperatureChange компонента TemperatureInput по шкале Фаренгейта — это метод handleFahrenheitChange в компоненте Calculator. Поэтому один из этих двух методов Calculator вызывается в зависимости от того, какое поле ввода редактируется.
      -Внутри этих методов компонент Calculator указывает React сделать повторный рендер себя, используя вызов this.setState() со значением нового поля ввода и текущей шкалой.
      -React вызывает метод render() компонента Calculator, чтобы узнать, как должен выглядеть UI. Значения обоих полей ввода пересчитываются исходя из текущей температуры и шкалы. В этом методе выполняется конвертация температуры.
      -React вызывает методы render() конкретных компонентов TemperatureInput с их новыми пропсами, переданными компонентом Calculator. Он узнает, как должен выглядеть UI.
      -React вызывает метод render() компонента Boiling Verdict, передавая температуру в градусах Цельсия как проп.
      -React DOM обновляет DOM, чтобы привести его в соответствие с нужными нам значениями в полях ввода. Отредактированное нами только что поле ввода получает его текущее значение, а другое поле ввода обновляется конвертированным значением температуры.
      -Каждое обновление проходит через одни и те же шаги, поэтому поля ввода остаются синхронизированными.
  Извлечённые уроки
    Для любых изменяемых данных в React-приложении должен быть один «источник истины». Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.
      Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка. Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на однонаправленный поток данных.
    Для подъёма состояния приходится писать больше «шаблонного» кода, чем при подходах с двусторонней привязкой данных, но мы получаем преимущество в виде меньших затрат на поиск и изолирование багов.
      Так как любое состояние «живёт» в каком-нибудь компоненте, и только этот компонент может его изменить, количество мест с возможными багами значительно уменьшается. 
      Кроме того, вы можете реализовать любую пользовательскую логику для отклонения или преобразования данных, введённых пользователем.
    Если что-то может быть вычислено из пропсов или из состояния, то скорее всего оно не должно находиться в состоянии. Например, вместо сохранения celsiusValue и fahrenheitValue, мы сохраняем только последнюю введённую температуру (temperature) и её шкалу (scale). Значение другого поля ввода можно всегда вычислить из них в методе render().
      Это позволяет очистить или применить округление к значению другого поля, не теряя при этом точности значений, введённых пользователем.
    Когда вы видите, что в UI что-то отображается неправильно, то можете воспользоваться расширением React Developer Tools. С помощью него можно проверить пропсы и перемещаться по дереву компонентов вверх до тех пор, пока не найдёте тот компонент, который отвечает за обновление состояния. 
      Это позволяет отследить источник багов:
      ----------------
+ Композиция против наследования
  React имеет мощную модель композиции, поэтому для повторного использования кода между компонентами мы рекомендуем использовать композицию вместо наследования.
    В этой главе мы рассмотрим несколько проблем, которые новички в React решают наследованием и попробуем решить их с помощью композиции.
    Вставка
      Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.
      Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
      */
      function FancyBorder(props) {
        return (
          <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
          </div>
        );
      }
      // Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
      function WelcomeDialog() {
        return (
          <FancyBorder color="blue">
            <h1 className="Dialog-title">
              Добро пожаловать
            </h1>
            <p className="Dialog-message">
              Спасибо, что посетили наш космический корабль!
            </p>
          </FancyBorder>
        );
      }
      /*
      Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри <div>, все переданные элементы отображаются в конечном выводе.
      Иногда в компоненте необходимо иметь несколько мест для вставки. В таком случае можно придумать свой формат, а не использовать children:
      */
      function SplitPane(props) {
        return (
          <div className="SplitPane">
            <div className="SplitPane-left">
              {props.left}
            </div>
            <div className="SplitPane-right">
              {props.right}
            </div>
          </div>
        );
      }
      
      function App() {
        return (
          <SplitPane
            left={
              <Contacts />
            }
            right={
              <Chat />
            } />
        );
      }
      /* // Такие React-элементы, как <Contacts /> и <Chat /> являются просто объектами, поэтому их можно передать в виде пропсов, как и любые другие данные.
  Специализация
    Некоторые компоненты можно рассматривать как «частные случаи» других компонентов. Например, WelcomeDialog может быть частным случаем Dialog.
    В React это можно сделать через композицию, где «частный» вариант компонента рендерит более «общий» и настраивает его с помощью пропсов:
  Так что насчёт наследования?
    Пропсы и композиция дают вам всю гибкость, необходимую для настройки внешнего вида и поведения компонента явным и безопасным способом. Помните, что компоненты могут принимать произвольные пропсы, включая примитивные значения, React-элементы или функции.
    Если вы хотите повторно использовать не связанную с внешним видом функциональность между компонентами, извлеките её в отдельный JavaScript-модуль.
    Импортируйте его в компонент и используйте эту функцию, объект или класс, не расширяя их.
+ Введение в хуки
  Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
  Мотивация
    1. Трудно повторно использовать логику состояний между компонентами
      В React нет способа «присоединить» повторно используемое поведение к компоненту (например, подключение к хранилищу). Если вы работали с React какое-то время, то вам могут быть знакомы такие паттерны, как рендер-пропсы и компоненты 
      высшего порядка, которые пытаются решить эту проблему. Но эти паттерны заставляют вас изменять структуру компонентов, что делает код громоздким и трудным в поддержке. Если вы посмотрите на типичное React-приложение в React DevTools, 
      то увидите «ад обёрток» из компонентов, окружённых провайдерами, консьюмерами, компонентами высшего порядка, рендер-пропсами и другими абстракциями.
    -С помощью хуков вы можете извлечь логику состояния из компонента, чтобы её протестировать или повторно использовать. Хуки позволяют вам повторно использовать логику состояния, не затрагивая дерево компонентов. 
      Благодаря этому, хуки легко использовать в разных компонентах и делиться ими с сообществом.
    2. Сложные компоненты становятся трудными для понимания
      Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в неуправляемый беспорядок, состоящий из логики состояния и побочных эффектов.
      Каждый метод жизненного цикла часто содержит смесь несвязанной логики. Например, компоненты могут загружать данные в componentDidMount и componentDidUpdate. Однако тот же метод componentDidMount может содержать несвязанную логику, 
      которая добавляет обработчики события с отменой подписки в componentWillUnmount. Взаимосвязанный код, который изменяется вместе, разделяется, но совершенно несвязанный код в конечном итоге объединяется в один метод. Это легко приводит 
      к багам и несоответствиям в приложении. В некоторых случаях невозможно разбить компоненты на более мелкие, потому что логика состояния раскидана повсюду. Такие компоненты сложно тестировать. Это одна из причин, по которой люди предпочитают 
      использовать в React отдельную библиотеку для управления состоянием. Однако, это добавляет множество абстракций, заставляет прыгать между разными файлами и усложняет повторное использование компонентов.
    -Чтобы решить эту проблему, хуки позволяют разбить один компонент на маленькие функции по их назначению (например, подписке или загрузке данных), а не на основе методов жизненного цикла. Вы также можете контролировать внутреннее состояние 
      с помощью редюсера, чтобы поведение было более предсказуемым.
    3. Классы путают как людей, так и машины
      Вдобавок к усложнению организации кода и его повторного использования, классы создают существенный барьер в изучении React. Нужно понимать, как работает this в JavaScript, поведение которого отличается от большинства языков.
      Приходится помнить про привязку контекста для обработчиков событий. Без использования ES2022 публичных полей класса, код становится многословным. Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, 
      но всё равно путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда их использовать, приводят к разногласиям даже между опытными React-разработчиками. Однако мы заметили, что классовые 
      компоненты могут приводить к ненамеренным паттернам, сводящим оптимизации на нет. Классы создают сложности для инструментов и сегодня. Например, классы плохо минифицируются, а горячая перезагрузка (hot reloading) ненадёжна и 
      часто ломает их. Наша цель — предоставить API, который повысит вероятность того, что код можно будет оптимизировать.
    -Чтобы решить эти проблемы, хуки позволяют использовать больше возможностей React без написания классов. Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к функционалу, но не обесценивают опыт использования React.
      Хуки предоставляют императивные лазейки и не требуют от вас изучения сложных функциональных или реактивных подходов.
+ useState
  Что такое хук?
    Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React. 
  Когда применить хук? 
    Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента.
  Что делает вызов useState?
    Он объявляет «переменную состояния». Мы называли переменную count, но могли дать ей любое имя, хоть банан. Таким образом мы можем «сохранить» некоторые значения между вызовами функции. useState — это новый способ использовать те же возможности, 
    что даёт this.state в классах. Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не относится, потому что их сохраняет React.
  Какие аргументы передавать useState?
    Единственный аргумент useState — это исходное состояние. В отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так удобно.
  Что возвращается из useState?
    Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. Поэтому мы пишем const [count, setCount] = useState().
  Теперь мы знаем, что делает useState, и пример должен быть ясен:
  */
  import React, { useState } from 'react';

  function Example() {
    // Объявление новой переменной состояния «count»
    const [count, setCount] = useState(0);
  /*
  Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить count, мы вызовем setCount.
  
  1. useState асинхронно менякт значение! И новое значение мы сможем увидеть только при следующем рендере! Даже если мы 2 раза вызовем setCount(counter + 1), то значение count изменится только один раз!
    И если нужно использовать новое значение сразу, то нужно использовать функцию в качестве аргумента! setCount((prevCount) => prevCount + 1);
  2. Обратите внимание, что, в отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.
    */ // так же и с массивом!
    const [state, setState] = useState({ count: 0, theme: 'blue' });
    setState(prevState => {
      return { ...prevState, count: prevState.count + 1 }
    }
    /*
  3. Инициализационное значение хоть и отбрасывается, но все равно создается при каждом рендере. И если там сложное вычисление, то лучше передавать не вычисленное значение, а функцию, которая будет вычислять это значение только тогда, когда оно действительно понадобится.
    Пример: const [count, setCount] = useState(() => 10);
+ useEffect
  Хук эффекта даёт вам возможность выполнять побочные эффекты в функциональном компоненте.
    Побочными эффектами в React-компонентах могут быть: загрузка данных, оформление подписки и изменение DOM вручную. Неважно, называете ли вы эти операции «побочными эффектами» (или просто «эффектами») или нет, скорее всего вам доводилось ранее использовать их в своих компонентах.
    Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют сброса. Давайте рассмотрим оба примера более детально.
  Эффекты без сброса
    Иногда мы хотим выполнить дополнительный код после того, как React обновил DOM. Сетевые запросы, изменения DOM вручную, логирование — всё это примеры эффектов, которые не требуют сброса.
    После того, как мы запустили их, можно сразу забыть о них, ведь больше никаких дополнительных действий не требуется.
    Что же делает useEffect? 
      Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM.
      В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.
    Почему же мы вызываем useEffect непосредственно внутри компонента?
      Это даёт нам доступ к переменной состояния count (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. 
      Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
    Выполняется ли useEffect после каждого рендера?
      Разумеется! По умолчанию он будет выполняться после каждого рендера и обновления. 
      Вместо того, чтобы воспринимать это с позиции «монтирования» и «обновления», мы советуем просто иметь в виду, что эффекты выполняются после каждого рендера. React гарантирует, что он запустит эффект только после того, как DOM уже обновился.
    Подробное объяснение
      Опытные JavaScript-разработчики могут подметить, что функция, которую мы передаём в useEffect, будет меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что даёт нам возможность получать актуальную версию 
      переменной count изнутри эффекта, не беспокоясь о том, что её значение устареет. Каждый раз при повторном рендере, мы ставим в очередь новый эффект, который заменяет предыдущий. В каком-то смысле, это включает поведение эффектов как часть результата рендера, 
      то есть каждый эффект «принадлежит» определённому рендеру.
      (Совет) В отличие от componentDidMount или componentDidUpdate, эффекты, запланированные с помощью useEffect, не блокируют браузер при попытке обновить экран. Ваше приложение будет быстрее реагировать на действия пользователя, даже когда эффект ещё не закончился.
        Большинству эффектов не нужно работать в синхронном режиме. Есть редкие случаи, когда им всё же нужно это делать (например, измерять раскладку), но для этого мы разработали специальный хук useLayoutEffect с точно таким же API, как и у useEffect.
  Эффекты со сбросом
    Например, нам может потребоваться установить подписку на какой-нибудь внешний источник данных. В этом случае очень важно выполнять сброс, чтобы не случилось утечек памяти!
    Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.
    */
    function FriendStatus(props) {
      const [isOnline, setIsOnline] = useState(null);
    
      useEffect(() => {
        function handleStatusChange(status) {
          setIsOnline(status.isOnline);
        }
        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
        // Указываем, как сбросить этот эффект:
        return function cleanup() {
          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
        };
      });
    
      if (isOnline === null) {
        return 'Загрузка...';
      }
      return isOnline ? 'В сети' : 'Не в сети';
    }
    /*
    Зачем мы вернули функцию из нашего эффекта?
      Это необязательный механизм сброса эффектов. Каждый эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
    Когда именно React будет сбрасывать эффект? 
      React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий. 
      Мы рассмотрим почему это позволяет избежать багов и как отказаться от этой логики, если это вызывает проблемы с производительностью
  Советы по использованию эффектов
    используйте разные хуки для разных задач
      С помощью хуков, мы можем разделить наш код основываясь на том, что он делает, а не по принципам методов жизненного цикла. React будет выполнять каждый используемый эффект в компоненте, согласно порядку их объявления.
    ?Объяснение: почему эффекты выполняются при каждом обновлении
      Если вы привыкли пользоваться классами, вам может быть не совсем ясно, почему этап сброса эффекта происходит после каждого последующего рендера, а не один лишь раз во время размонтирования. 
      Давайте рассмотрим на практике, почему такой подход помогает создавать компоненты с меньшим количеством багов.
      Ранее на этой странице, мы рассматривали пример с компонентом FriendStatus, который отображает в сети наш друг или нет. Наш класс берёт friend.id из this.props, подписывается на статус друга после того, как компонент смонтировался, и отписывается во время размонтирования.
      */
      componentDidMount() {
        ChatAPI.subscribeToFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }
    
      componentWillUnmount() {
        ChatAPI.unsubscribeFromFriendStatus(
          this.props.friend.id,
          this.handleStatusChange
        );
      }
      /*
      Но что же произойдёт, если проп friend поменяется, пока компонент все ещё находится на экране? Наш компонент будет отображать статус в сети уже какого-нибудь другого друга. Это как раз таки баг. Это также может привести к утечке памяти или вообще к вылету нашего приложения при размонтировании, 
      так как метод отписки будет использовать неправильный ID друга, от которого мы хотим отписаться. В классовом компоненте нам бы пришлось добавить componentDidUpdate, чтобы решить эту задачу
      Не использовать componentDidUpdate надлежащим образом — это один из самых распространённых источников багов в приложениях React.
      Теперь давайте рассмотрим версию этого же компонента, но уже написанного с использованием хуков:
      */
      function FriendStatus(props) {
        // ...
        useEffect(() => {
          // ...
          ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
          return () => {
            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
          };
        });
        /*
      Здесь нет никакого особого кода для решения проблем с обновлениями, так как useEffect решает их по умолчанию. Он сбрасывает предыдущие эффекты прежде чем выполнить новые. Чтобы показать это на практике, давайте рассмотрим последовательность подписок и отписок, 
        которые этот компонент может выполнить в течение некоторого времени.
      */
       // Монтируем с пропсами { friend: { id: 100 } } 
      ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Выполняем первый эффект

      // Обновляем с пропсами { friend: { id: 200 } }
      ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Сбрасываем предыдущий эффект
      ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Выполняем следующий эффект

      // Обновляем с пропсами { friend: { id: 300 } }
      ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Сбрасываем предыдущий эффект
      ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Выполняем следующий эффект

      // Размонтируем
      ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Сбрасываем последний эффект
      /*
      Эта логика по умолчанию гарантирует согласованность выполняемых нами действий и исключает баги, распространённые в классовых компонентах из-за упущенной логики обновления.
  Совет: оптимизация производительности за счёт пропуска эффектов
    В некоторых случаях сброс или выполнение эффекта при каждом рендере может вызвать проблему с производительностью. В классовых компонентах, мы можем решить это используя дополнительное сравнение prevProps или prevState внутри componentDidUpdate:
    */
    componentDidUpdate(prevProps, prevState) {
      if (prevState.count !== this.state.count) {
        document.title = `Вы нажали ${this.state.count} раз`;
      }
    }
    /*
    Эту логику приходится использовать довольно часто, поэтому мы решили встроить её в API хука useEffect. Вы можете сделать так, чтобы React пропускал вызов эффекта, если определённые значения остались без изменений между последующими рендерами. 
      Чтобы сделать это, передайте массив в useEffect вторым необязательным аргументом.
      */
      useEffect(() => {
        document.title = `Вы нажали ${count} раз`;
      }, [count]); // Перезапускать эффект только если count поменялся
      /*
      В этом примере, мы передаём [count] вторым аргументом. Что это вообще значит? Это значит, что если count будет равен 5 и наш компонент повторно рендерится с тем же значением count = 5, React сравнит [5] из предыдущего рендера и [5] из следующего рендера. 
        Так как, все элементы массива остались без изменений (5 === 5), React пропустит этот эффект. Это и есть оптимизация данного процесса.
      Когда при следующем рендере наша переменная count обновится до 6, React сравнит элементы в массиве [5] из предыдущего рендера и элементы массива [6] из следующего рендера. На этот раз, React выполнит наш эффект, так как 5 !== 6. Если у вас будет несколько элементов в массиве, 
        React будет выполнять наш эффект, в том случае, когда хотя бы один из них будет отличаться.
  Примечание
    Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом.
    В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров.
+ Правила хуков
  Используйте хуки только на верхнем уровне
    Не вызывайте хуки внутри циклов, условных операторов или вложенных функций. Вместо этого всегда используйте хуки только внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой 
    последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами useState и useEffect.
  Вызывайте хуки только из React-функций
    Не вызывайте хуки из обычных функций JavaScript. Вместо этого можно:
      ✅ Вызывать хуки из функционального компонента React.
      ✅ Вызывать хуки из пользовательского хука (мы научимся делать это на следующей странице).
+ Пользовательские хуки
  Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки. Например, функция useFriendStatus ниже — это наш первый пользовательский хук:
  */
  import { useState, useEffect } from 'react';

  function useFriendStatus(friendID) {
    const [isOnline, setIsOnline] = useState(null);
  
    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline);
      }
  
      ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
      };
    });
  
    return isOnline;
  }
  /*
  В отличие от React-компонента, пользовательский хук не обязательно должен иметь конкретную сигнатуру. Мы можем решить, что он принимает в качестве аргументов, и должен ли он что-либо возвращать. 
  Другими словами, всё как в обычных функциях. Имя функции-хука всегда следует начинать с use, чтобы вы могли сразу увидеть, что к ней применяются правила хуков.
  Цель нашего хука useFriendStatus — подписать нас на статус друга. Поэтому он принимает в качестве аргумента friendID и возвращает статус друга в сети:
  Использование пользовательского хука
  */
  function FriendStatus(props) {
    const isOnline = useFriendStatus(props.friend.id);
  
    if (isOnline === null) {
      return 'Загрузка...';
    }
    return isOnline ? 'В сети' : 'Не в сети';
  }
  /*
  Код будет работать как раньше? 
    Да, он работает точно так же. Если вы посмотрите внимательно, вы заметите, что мы не вносили никаких изменений в логику. Всё, что мы сделали, это извлекли общий код в отдельную функцию. 
    Пользовательские хуки — это скорее соглашение, соответствующее дизайну хуков, нежели чем возможность самого React.
  У хука, используемого в двух компонентах, одинаковое состояние?
    Пользовательские хуки — это механизм повторного использования логики с состоянием (например, установка подписки и сохранение текущего значения), но каждый раз, когда вы используете пользовательский хук, всё состояние и эффекты внутри него полностью изолированы.
  Как пользовательский хук получает изолированное состояние?
    Каждый вызов хука получает изолированное состояние. Поскольку мы вызываем useFriendStatus напрямую, с точки зрения React наш компонент просто вызывает useState и useEffect. И как мы узнали ранее, мы можем вызывать 
    useState и useEffect много раз в одном компоненте, и они будут полностью независимы.
  Совет: Передача информации между хуками
    Поскольку хуки являются функциями, мы можем передавать информацию между ними.
  используйтеВоображение()
    Пользовательские хуки предлагают гибкую логику совместного использования, которая раньше была невозможна в React-компонентах. Вы можете написать собственные хуки, которые охватывают широкий спектр вариантов использования, таких как обработка форм, 
    анимация, декларативные подписки, таймеры и, возможно, многих других, которые мы не рассматривали. Более того, вы можете создавать хуки, которые также просты в использовании, как и встроенные функции React.
+ useContext
  const value = useContext(MyContext);
    Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.
    Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext.
    Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext.
    Запомните, аргументом для useContext должен быть непосредственно сам объект контекста: useContext(MyContext)
    Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации.
  Совет
    Если вы были знакомы с API контекстов до появления хуков, то вызов useContext(MyContext) аналогичен выражению static contextType = MyContext в классе, либо компоненту <MyContext.Consumer>.
    useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста.
    */
    const themes = {
      light: {
        foreground: "#000000",
        background: "#eeeeee"
      },
      dark: {
        foreground: "#ffffff",
        background: "#222222"
      }
    };
    
    const ThemeContext = React.createContext(themes.light);
    
    function App() {
      return (
        <ThemeContext.Provider value={themes.dark}>
          <Toolbar />
        </ThemeContext.Provider>
      );
    }
    
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }
    
    function ThemedButton() {
      const theme = useContext(ThemeContext);
      return (
        <button style={{ background: theme.background, color: theme.foreground }}>
          Я стилизован темой из контекста!
        </button>
      );
    }
    /*
+ useReducer
  const [state, dispatch] = useReducer(reducer, initialArg, init);
  Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. (Если вы знакомы с Redux, вы уже знаете, как это работает.)
  Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. useReducer также 
    позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать dispatch вместо колбэков.
  Вот пример счётчика из раздела useState, переписанный для использования редюсера:
  */
  const initialState = {count: 0};

  function reducer(state, action) {
    switch (action.type) {
      case 'increment':
        return {count: state.count + 1};
      case 'decrement':
        return {count: state.count - 1};
      default:
        throw new Error();
    }
  }
  
  function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    return (
      <>
        Count: {state.count}
        <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        <button onClick={() => dispatch({type: 'increment'})}>+</button>
      </>
    );
  }
  /*
  React гарантирует, что идентичность функции dispatch стабильна и не изменяется при повторных рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков useEffect и useCallback.
  Указание начального состояния
    Существует два разных способа инициализации состояния useReducer. Вы можете выбрать любой из них в зависимости от ситуации. Самый простой способ — передать начальное состояние в качестве второго аргумента:
    */ const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
    );
    /*
    Примечание
      React не использует соглашение об аргументах state = initialState, популярное в Redux. Начальное значение иногда должно зависеть от пропсов и поэтому указывается вместо вызова хука.
      Если вы сильно в этом уверены, вы можете вызвать useReducer(reducer, undefined, reducer), чтобы эмулировать поведение Redux, но это не рекомендуется.
    Ленивая инициализация
      ?Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию init в качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова init(initialArg).
      Это позволяет извлечь логику для расчёта начального состояния за пределы редюсера. Это также удобно для сброса состояния позже в ответ на действие:
      */
      function init(initialCount) {
        return {count: initialCount};
      }
      
      function reducer(state, action) {
        switch (action.type) {
          case 'increment':
            return {count: state.count + 1};
          case 'decrement':
            return {count: state.count - 1};
          case 'reset':
            return init(action.payload);
          default:
            throw new Error();
        }
      }
      
      function Counter({initialCount}) {
        const [state, dispatch] = useReducer(reducer, initialCount, init);
        return (
          <>
            Count: {state.count}
            <button
              onClick={() => dispatch({type: 'reset', payload: initialCount})}>
              Reset
            </button>
            <button onClick={() => dispatch({type: 'decrement'})}>-</button>
            <button onClick={() => dispatch({type: 'increment'})}>+</button>
          </>
        );
      }
      /*
      Досрочное прекращение dispatch
      Если вы вернёте то же значение из редюсера хука, что и текущее состояние, React выйдет без перерисовки дочерних элементов или запуска эффектов. (React использует алгоритм сравнения Object.is.)
+ useRef
  const refContainer = useRef(initialValue);
  useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.
  Обычный случай использования — это доступ к потомку в императивном стиле:
  */
  function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
      // `current` указывает на смонтированный элемент `input`
      inputEl.current.focus();
    };
    return (
      <>
        <input ref={inputEl} type="text" />
        <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
      </>
    );
  }
  /*
  По сути, useRef похож на «коробку», которая может содержать изменяемое значение в своём свойстве .current.
  Возможно, вы знакомы с рефами в основном как со способом получить доступ к DOM. Если вы передадите React объект рефа с помощью подобного выражения <div ref={myRef}/>, React установит собственное 
    свойство .current на соответствующий DOM-узел при каждом его изменении.
  Но хук useRef() полезен не только установкой атрибута с рефом. Он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах.
    Это возможно, поскольку useRef() создаёт обычный JavaScript-объект. Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере.
    Имейте в виду, что useRef не уведомляет вас, когда изменяется его содержимое. Мутирование свойства .current не вызывает повторный рендер. Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, 
    вы можете использовать колбэк-реф вместо этого.
    Также мы можем сохранять предыдущее состояние  используя хук useRef:
+ useMemo
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.
  Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo.
  Если массив не был передан, новое значение будет вычисляться при каждом рендере.
  Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов 
  вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.
  

  */
  function complexCompute(num) {
    console.log('complexCompute')
    let i = 0
    while (i < 1000000000) i++
    return num * 2
  }

  function App() {
    const [number, setNumber] = useState(42)
    const [colored, setColored] = useState(false)

    const styles = useMemo(() => ({ // можно закэшировать объект стилей и тогда useEffect не будет вызываться при каждом рендере, а только при изменении цвета
      color: colored ? 'darkred' : 'black' // т.к  на каждом рендере будет создаваться новый объект, то useEffect будет вызываться при каждом рендере
    }), [colored])

    const computed = useMemo(() => { // useMemo - кеширует результат вызова функции
      return complexCompute(number)
    }, [number]) // и вызывает функцию только если изменился number

    useEffect(() => {
      console.log('Styles changed')
    }, [styles])

    return (
      <>
        <h1 style={styles}>Вычисляемое свойство: {computed}</h1>
        <button className={'btn btn-success'} onClick={() => setNumber(prev => prev + 1)}>Добавить</button>
        <button className={'btn btn-danger'} onClick={() => setNumber(prev => prev - 1)}>Убрать</button>
        <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button>
      </>
    )
  }
  /*
+ useCallback
  */
  const memoizedCallback = useCallback(
    () => {
      doSomething(a, b);
    },
    [a, b],
  );
  /* Возвращает мемоизированный колбэк.
  Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. 
  Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).
  useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).
  */
  function App() {
    const [colored, setColored] = useState(false)
    const [count, setCount] = useState(1)
  
    const styles = {
      color: colored ? 'darkred' : 'black'
    }
  
    const generateItemsFromAPI = useCallback((indexNumber) => {
      return new Array(count).fill('').map((_, i) => `Элемент ${i + indexNumber}`)
    }, [count])
  
    return (
      <>
        <h1 style={styles}>Количество элементов: {count}</h1>
        <button className={'btn btn-success'} onClick={() => setCount(prev => prev + 1)}>Добавить</button>
        <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button> Предотвращает ререндер дочерних компонентов если мы именили цвет
  
        <ItemsList getItems={generateItemsFromAPI} />
      </>
    )
  }

  export default function ItemsList({ getItems }) {
    const [items, setItems] = useState([])
  
    useEffect(() => {
      const newItems = getItems(42)
      setItems(newItems)
      console.log('render')
    }, [getItems])
  
    return (
      <ul>
        { items.map(i => <li key={i}>{i}</li>) }
      </ul>
    )
  }  
  /*
+ useLayoutEffect
  Сигнатура идентична useEffect, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, 
    запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.
  Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений.
  При useEffect наоснове return создается виртуальное дерево => далее оно отдается на отрисовку в браузер и только после этого вызывается функция переданная в useEffect 
------------
+ Доступность контента
  Доступность контента — это специальные технические и архитектурные решения, которые помогают людям с ограниченными возможностями использовать сайты. Применение таких решений необходимо 
    для интерпретации страниц техническими средствами реабилитации, встроенными в операционные системы и браузеры. Термин «доступность контента» также может обозначаться аббревиатурой a11y.
    React поддерживает создание сайтов c доступным контентом в том числе с помощью стандартных возможностей HTML.
  Доступность контента в веб-приложениях (WAI-ARIA)
    Свод правил по доступности контента в веб-приложениях (WAI-ARIA) — это документ, который посвящён реализации требований доступности контента при разработке JavaScript-программ и компонентов.
    Нужно отметить, что все HTML-атрибуты aria-* полностью поддерживаются в JSX. Несмотря на то, что большинство DOM-свойств и атрибутов в React пишутся в стиле camelCase, атрибуты aria-* должны быть написаны с разделением дефисами.
  Семантическая вёрстка
    Семантическая вёрстка — это основа доступности контента в веб-приложениях. Используя различные HTML-элементы можно улучшить восприимчивость и понятность ваших сайтов. Это позволяет сделать контент доступным без особых усилий.
  Доступность контента в формах
    Подписи - Каждый элемент управления, например, <input> или <textarea>, должен иметь подпись, обеспечивающую доступность контента.
    Сообщения об ошибках - Необходимо, чтобы ошибки и их причины были понятны всем пользователям. 
    Управление фокусом - Приложение с доступным контентом должно функционировать при использовании только клавиатуры. Убедитесь, соответствует ли ваше приложение этому требованию:
      Чтобы управлять фокусом в React, можно использовать рефы на DOM-элементы.
+ Разделение кода
  Бандлинг
    Большинство React-приложений «собирают» свои файлы такими инструментами, как Webpack, Rollup или Browserify. Сборка (или «бандлинг») — это процесс выявления импортированных файлов и объединения их в один «собранный» 
      файл (часто называемый «bundle» или «бандл»). Этот бандл после подключения на веб-страницу загружает всё приложение за один раз.
    Если вы используете Create React App, Next.js, Gatsby или похожие инструменты, то у вас уже будет настроенный Webpack для бандлинга приложения.
  Бандлинг — это хорошо, но по мере роста вашего приложения, ваш бандл тоже будет расти. Особенно если вы подключаете крупные сторонние библиотеки. Вам нужно следить за кодом, который вы подключаете, чтобы случайно 
    не сделать приложение настолько большим, что его загрузка займёт слишком много времени.
    Разделение кода — это возможность, поддерживаемая такими бандлерами как Webpack, Rollup или Browserify (с factor-bundle), которая может создавать несколько бандлов и загружать их по мере необходимости.
      Хоть вы и не уменьшите общий объём кода вашего приложения, но избежите загрузки кода, который может никогда не понадобиться пользователю и уменьшите объём кода, необходимый для начальной загрузки.
  import()
    Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: import().
    */
    import { add } from './math';
    console.log(add(16, 26));
    // после
    import("./math").then(math => {
      console.log(math.add(16, 26));
    });
    /*
    Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения. Если вы используете Create React App, то всё уже настроено и вы можете сразу начать использовать 
      синтаксис динамического импорта. Он также поддерживается «из коробки» в Next.js.
  React.lazy
    Функция React.lazy позволяет рендерить динамический импорт как обычный компонент.
    */
    import OtherComponent from './OtherComponent';
    // после
    const OtherComponent = React.lazy(() => import('./OtherComponent'));
    /*
    Она автоматически загрузит бандл, содержащий OtherComponent, когда этот компонент будет впервые отрендерен.
    React.lazy принимает функцию, которая должна вызвать динамический import(). Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент (export default).
    Задержка
      Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.
      */
      function MyComponent() {
        return (
          <div>
            <Suspense fallback={<div>Загрузка...</div>}>
              <OtherComponent />
            </Suspense>
          </div>
        );
      }
      /*
      Проп fallback принимает любой React-элемент, который вы хотите показать, пока происходит загрузка компонента. Компонент Suspense можно разместить в любом месте над ленивым компонентом. 
      Кроме того, можно обернуть несколько ленивых компонентов одним компонентом Suspense.
    Как избежать откатов
      Любой компонент может приостановиться в результате рендеринга, даже компоненты, которые уже были показаны пользователю.
      Чтобы содержимое экрана всегда было согласованным, если уже показанный компонент приостанавливается, React должен скрыть его дерево до ближайшей <Suspense>границы. Однако с точки зрения пользователя это может дезориентировать.
      Рассмотрим этот переключатель вкладок:
      */
      import React, { Suspense } from 'react';
      import Tabs from './Tabs';
      import Glimmer from './Glimmer';
      
      const Comments = React.lazy(() => import('./Comments'));
      const Photos = React.lazy(() => import('./Photos'));
      
      function MyComponent() {
        const [tab, setTab] = React.useState('photos');
        
        function handleTabSelect(tab) {
          setTab(tab);
        };
      
        return (
          <div>
            <Tabs onTabSelect={handleTabSelect} />
            <Suspense fallback={<Glimmer />}>
              {tab === 'photos' ? <Photos /> : <Comments />}
            </Suspense>
          </div>
        );
      }
      /* В этом примере, если вкладка изменяется с 'photos'на 'comments', но Commentsприостанавливается, пользователь увидит мерцание.
      Это имеет смысл, потому что пользователь больше не хочет видеть Photos, Commentsкомпонент не готов что-либо отображать, а React нужно поддерживать согласованность взаимодействия с пользователем, 
        поэтому у него нет другого выбора, кроме как показать Glimmer вышеперечисленное.
      Однако иногда такой пользовательский опыт нежелателен. В частности, иногда лучше показать «старый» UI, пока готовится новый UI. Вы можете использовать новый startTransitionAPI, чтобы заставить React сделать это:
      */
      function handleTabSelect(tab) {
        startTransition(() => {
          setTab(tab);
        });
      }
      /*
      Здесь вы сообщаете React, что настройка вкладки 'comments'не является срочным обновлением, а является переходом , который может занять некоторое время. Затем React сохранит старый пользовательский интерфейс на месте 
        и будет интерактивным и переключится на отображение, <Comments />когда он будет готов. Смотрите Переходы для получения дополнительной информации.
    Предохранители Error boundaries
      Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. Вы можете обрабатывать эти ошибки для улучшения пользовательского опыта с помощью Предохранителей. После создания предохранителя, 
        его можно использовать в любом месте над ленивыми компонентами для отображения состояния ошибки.
        */
        import React, { Suspense } from 'react';
        import MyErrorBoundary from './MyErrorBoundary';
        
        const OtherComponent = React.lazy(() => import('./OtherComponent'));
        const AnotherComponent = React.lazy(() => import('./AnotherComponent'));
        
        const MyComponent = () => (
          <div>
            <MyErrorBoundary>
              <Suspense fallback={<div>Загрузка...</div>}>
                <section>
                  <OtherComponent />
                  <AnotherComponent />
                </section>
              </Suspense>
            </MyErrorBoundary>
          </div>
        );
        /*
    Разделение кода на основе маршрутов
      Решение о том, где в вашем приложении ввести разделение кода, может быть непростым. В идеале, следует выбрать такие места, чтобы код разделялся на бандлы примерно одного размера, тем самым поддерживая хороший пользовательский опыт.
      Часто таким удобным местом оказываются маршруты. Большинство интернет-пользователей привыкли к задержкам во время переходов между страницами. Поэтому и вам может быть выгодно повторно отрендерить всю страницу целиком.
    Именованный экспорт
      React.lazy в настоящее время поддерживает только экспорт по умолчанию. Если модуль, который требуется импортировать, использует именованный экспорт, можно создать промежуточный модуль, который повторно экспортирует его как модуль по умолчанию. 
        Это гарантирует работоспособность tree shaking — механизма устранения неиспользуемого кода.
+ Контекст
  Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.
  В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, подобный способ использования может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые 
    необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.
  Когда использовать контекст
    Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).
  Перед тем, как вы начнёте использовать контекст
    Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет повторное использование компонентов.
    Если вы хотите избавиться от передачи некоторых пропсов на множество уровней вниз, обычно композиция компонентов является более простым решением, чем контекст.
    Один из способов решить эту проблему без контекста — передать вниз сам компонент Avatar, в случае чего промежуточным компонентам не нужно знать о пропсах user и avatarSize:
    */
    function Page(props) {
      const user = props.user;
      const userLink = (
        <Link href={user.permalink}>
          <Avatar user={user} size={props.avatarSize} />
        </Link>
      );
      return <PageLayout userLink={userLink} />;
    }
    
    // Теперь, это выглядит так:
    <>
      // Теперь, это выглядит так:
      <Page user={user} avatarSize={avatarSize} />
      // ... который рендерит ...
      <PageLayout userLink={...} />
      // ... который рендерит ...
      <NavigationBar userLink={...} />
    </>
    // ... который рендерит ...
    {props.userLink}
    /*
    С этими изменениями, только корневой компонент Page знает о том, что компоненты Link и Avatar используют user и avatarSize.
    Этого паттерна достаточно для большинства случаев, когда вам необходимо отделить дочерний компонент от его промежуточных родителей. Вы можете пойти ещё дальше, используя рендер-пропсы, если дочерним компонентам необходимо взаимодействовать с родителем перед рендером.
  API
    const MyContext = React.createContext(defaultValue); Создаёт объект Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
      Аргумент defaultValue используется только в том случае, если для компонента нет подходящего Provider выше в дереве. Значение по умолчанию может быть полезно для тестирования компонентов в изоляции без необходимости оборачивать их. Обратите внимание: 
        если передать undefined как значение Provider, компоненты, использующие этот контекст, не будут использовать defaultValue.
      MyContext.displayName = 'MyDisplayName'; // Объекту Context можно задать строковое свойство displayName. React DevTools использует это свойство при отображении контекста.
    <MyContext.Provider value={некоторое значение}> Каждый объект Context используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.
      Компонент Provider принимает проп value, который будет передан во все компоненты, использующие этот контекст и являющиеся потомками этого компонента Provider. Один Provider может быть связан с несколькими компонентами, потребляющими контекст.
      Так же компоненты Provider могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве.
      Все потребители, которые являются потомками Provider, будут повторно рендериться, как только проп value у Provider изменится. Потребитель (включая .contextType и useContext) перерендерится при изменении контекста, даже если его родитель, 
        не использующий данный контекст, блокирует повторные рендеры с помощью shouldComponentUpdate.
  Изменение контекста из вложенного компонента
    Довольно часто необходимо изменить контекст из компонента, который находится где-то глубоко в дереве компонентов. В этом случае вы можете добавить в контекст функцию, которая позволит потребителям изменить значение этого контекста:
      в самом объекте контекста нужно определить функцию, которая будет изменять контекст и вызвать этот колбэк внутри компонента, который будет изменять контекст https://ru.reactjs.org/docs/context.html#when-to-use-context
  Использование нескольких контекстов
    Чтобы последующие рендеры (связанные с контекстом) были быстрыми, React делает каждого потребителя контекста отдельным компонентом в дереве.
  Предостережения
    Контекст использует сравнение по ссылкам, чтобы определить, когда запускать последующий рендер. Из-за этого существуют некоторые подводные камни, например, случайные повторные рендеры потребителей, при перерендере родителя Provider-компонента. 
      В следующем примере будет происходить повторный рендер потребителя каждый повторный рендер Provider-компонента, потому что новый объект, передаваемый в value, будет создаваться каждый раз:
      */
      class App extends React.Component {
        render() {
          return (
            <MyContext.Provider value={{something: 'something'}}>
              <Toolbar />
            </MyContext.Provider>
          );
        }
      }
      // Один из вариантов решения этой проблемы — хранение этого объекта в состоянии родительского компонента.
      class App extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            value: {something: 'something'},
          };
        }
      
        render() {
          return (
            <MyContext.Provider value={this.state.value}>
              <Toolbar />
            </MyContext.Provider>
          );
        }
      }
      /* 
+ Предохранители
  Ранее ошибки JavaScript внутри компонентов портили внутреннее состояние React и заставляли его выдавать таинственные сообщения об ошибках во время следующего рендера. 
    Эти сообщения всегда вызывались ошибками, расположенными где-то выше в коде приложения, но React не предоставлял способа адекватно обрабатывать их в компонентах и не мог обработать их самостоятельно.
  Представляем предохранители (компоненты Error Boundary)
    Ошибка JavaScript где-то в коде UI не должна прерывать работу всего приложения. Чтобы исправить эту проблему для React-пользователей, React 16 вводит концепцию «предохранителя» (error boundary).
    Предохранители — это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.
    Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов, расположенных под ними.
    Предохранители не поймают ошибки в:
      -обработчиках событий (подробнее);
      -асинхронном коде (например колбэках из setTimeout или requestAnimationFrame);
      -серверном рендеринге (Server-side rendering);
      -самом предохранителе (а не в его дочерних компонентах).
    Классовый компонент является предохранителем, если он включает хотя бы один из следующих методов жизненного цикла: static getDerivedStateFromError() или componentDidCatch(). Используйте static 
      getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки. Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке.
      */
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false };
        }
      
        static getDerivedStateFromError(error) {
          // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
          return { hasError: true };
        }
      
        componentDidCatch(error, errorInfo) {
          // Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
          logErrorToMyService(error, errorInfo);
        }
      
        render() {
          if (this.state.hasError) {
            // Можно отрендерить запасной UI произвольного вида
            return <h1>Что-то пошло не так.</h1>;
          }
      
          return this.props.children; 
        }
      }
      
      // И можно дальше им пользоваться, как обыкновенным компонентом:
      <ErrorBoundary>
        <MyWidget />
      </ErrorBoundary>
      /*
      Предохранители работают как JavaScript-блоки catch {}, но только для компонентов. Только классовые компоненты могут выступать в роли предохранителей. 
      На практике чаще всего целесообразным будет один раз описать предохранитель и дальше использовать его по всему приложению.
      Обратите внимание, что предохранители отлавливают ошибки исключительно в своих дочерних компонентах. Предохранитель не сможет отловить ошибку внутри самого себя. Если предохранителю не удаётся отрендерить сообщение 
        об ошибке, то ошибка всплывает до ближайшего предохранителя, расположенного над ним в дереве компонентов. Этот аспект их поведения тоже напоминает работу блоков catch {} в JavaScript.
    Где размещать предохранители
      Степень охвата кода предохранителями остаётся на ваше усмотрение. Например, вы можете защитить им навигационные (route) компоненты верхнего уровня, чтобы выводить пользователю сообщение «Что-то пошло не так», как это часто делают 
      при обработке ошибок серверные фреймворки. Или вы можете охватить индивидуальными предохранителями отдельные виджеты, чтобы помешать им уронить всё приложение.
    Новое поведение при обработке неотловленных ошибок
      Это изменение влечёт за собой существенное последствие. Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к размонтированию всего дерева компонентов React.
      Хотя принятие этого решения и вызвало споры, судя по нашему опыту, бо́льшим злом будет вывести некорректный UI, чем удалить его целиком. К примеру, в приложении типа Messenger, вывод поломанного UI может привести к тому, 
      что пользователь отправит сообщение не тому адресату. Аналогично, будет хуже, если приложение для проведения платежей выведет пользователю неправильную сумму платежа, чем если оно не выведет вообще ничего.
  Стек вызовов компонентов
    В режиме разработки React 16 выводит на консоль сообщения обо всех ошибках, возникших при рендеринге, даже если они никак не сказались на работе приложения. Помимо сообщения об ошибке и стека JavaScript, React 16 также выводит и стек вызовов компонентов. 
      Теперь вы можете увидеть, где именно в дереве компонентов произошел сбой:
    Кроме этого, в стеке вызовов компонентов выводятся имена файлов и номера строк. Такое поведение по умолчанию настроено в проектах, созданных при помощи Create
    Примечание
      Имена компонентов, выводимые в их стеке вызовов, определяются свойством Function.name.
  А как насчёт try/catch?
    try / catch — отличная конструкция, но она работает исключительно в императивном коде:
    */
    try {
      showButton();
    } catch (error) {
      // ...
    }
    // В то время, как компоненты React являются декларативными, указывая что должно быть отрендерено:
    <Button />
    /*
    Предохранители сохраняют декларативную природу React и ведут себя так, как вы уже привыкли ожидать от компонентов React. Например, если ошибка, произошедшая в методе componentDidUpdate, будет вызвана setState где-то в 
      глубине дерева компонентов, она всё равно корректно всплывёт к ближайшему предохранителю.
+ Фрагменты
  Возврат нескольких элементов из компонента является распространённой практикой в React. Фрагменты позволяют формировать список дочерних элементов, не создавая лишних узлов в DOM.
    */
    class Columns extends React.Component {
      render() {
        return (
          <>
            <td>Привет</td>
            <td>Мир</td>
          </>
        );
      }
    }
    /* Можно использовать <></> так же, как используется любой другой элемент. Однако такая запись не поддерживает ключи или атрибуты.
  Фрагменты с ключами
    Фрагменты, объявленные с помощью <React.Fragment>, могут иметь ключи. Например, их можно использовать при создании списка определений, преобразовав коллекцию в массив фрагментов.
    */
    function Glossary(props) {
      return (
        <dl>
          {props.items.map(item => (
            // Без указания атрибута `key`, React выдаст предупреждение об его отсутствии
            <React.Fragment key={item.id}>
              <dt>{item.term}</dt>
              <dd>{item.description}</dd>
            </React.Fragment>
          ))}
        </dl>
      );
    }
    /* key — это единственный атрибут, допустимый у Fragment. В будущем мы планируем добавить поддержку дополнительных атрибутов, например, обработчиков событий.
+ Компоненты высшего порядка
  HOC — это функция, которая на входе принимает один компонент, а на выходе возвращает новый с более расширенным функционалом. Другими словами, hoc — это функция, ожидающая в качестве параметров компонент 
    (назовем его входным), который оборачивается в другой, объявленный в теле функции, компонент, выступающий в роли возвращаемого из функции значения (назовем его выходным).
  Слово “оборачивание”, применимое относительно компонентов, означает, что один компонент отрисовывает (рендерит) другой компонент, со всеми вытекающими из этого процесса (проксирования). За счет того, что входной 
    компонент оборачивается в выходной, достигается расширение его и/или общего функционала. Кроме того, это позволяет устанавливать входному компоненту как зависимости, так и данные, полученные из внешних сервисов.
    */
    import React from 'react';

    const withSecretToLife = (WrappedComponent) => {
      class HOC extends React.Component {
        render() {
          return (
            <WrappedComponent
              {...this.props}
              secretToLife={42}
            />
          );
        }
      }

      return HOC;
    };

    export default withSecretToLife;
    /* Всё, что мы сделали, так это просто проп secretToLife={42}, который позволил обернутому компоненту получить доступ к значению через this.props.secretToLife.
    Первый вызов функции higherOrderComponent возвращает вторую функцию, которая принимает в качестве параметра компонент, который оборачивается в HOC. Второй вызов функции higherOrderComponent возвращает
+ JSX в деталях
  JSX — синтаксический сахар для функции React.createElement(component, props, ...children).
    <MyButton color="blue" shadowSize={2}>
      Нажми меня
    </MyButton>
    Скомпилируется в:
    */
    React.createElement(
      MyButton,
      {color: 'blue', shadowSize: 2},
      'Нажми меня'
    )/*
    Вы также можете использовать самозакрывающийся тег, если отсутствуют дочерние элементы. Поэтому код:
    <div className="sidebar" />
    */
    React.createElement(
      'div',
      {className: 'sidebar'}
    )
    /*
  Указание типа React-элемента
      Первая часть JSX-тега определяет тип React-элемента.
      Типы, написанные с большой буквы, указывают, что JSX-тег ссылается на React-компонент. Эти теги компилируются в прямую ссылку на именованную переменную, поэтому, если вы используете JSX-выражение <Foo />, то Foo должен быть в области видимости.
    Названия типов пользовательских компонентов должны начинаться с большой буквы
      Если название типа элемента начинается с маленькой буквы, он ссылается на встроенный компонент, к примеру <div> или <span>, что в результате приведёт к тому, что в React.createElement будет передана строка 'div' или 'span'. Типы, начинающиеся с 
      заглавной буквы, такие как <Foo />, компилируются в React.createElement(Foo) и соответствуют компоненту, который был объявлен или импортирован в вашем JavaScript-файле.
  Пропсы в JSX
    JavaScript-выражения как пропсы
      Вы можете передавать любые JavaScript-выражения как пропсы, обернув их в {}. К примеру, в этом JSX:
      <MyComponent foo={1 + 2 + 3 + 4} />
      Оператор if и цикл for не являются выражениями в JavaScript, поэтому их нельзя непосредственно использовать в JSX. Вместо этого, вы можете окружить ими JSX-код. К примеру:
      */
      function NumberDescriber(props) {
        let description;
        if (props.number % 2 == 0) {
          description = <strong>чётным</strong>;
        } else {
          description = <i>нечётным</i>;
        }
        return <div>{props.number} является {description} числом</div>;
      }
      /*
    Вы можете передать строковый литерал как проп. Эти два выражения эквивалентны:
      <MyComponent message="привет, мир" /> 
      <MyComponent message={'привет, мир'} />
      Когда вы передаёте строковый литерал, все его возможные символы будут преобразованы в соответствующие HTML-сущности. Поэтому эти два JSX-выражения будут эквивалентны:
        <MyComponent message="&lt;3" />
        <MyComponent message={'<3'} />
    Установка пропсов по умолчанию в «true»
      Если вы не передаёте значение в проп, то по умолчанию оно будет true. Эти два JSX выражения эквивалентны:
        <MyTextBox autocomplete />
        <MyTextBox autocomplete={true} />
    Атрибуты расширения
      Если у вас уже есть пропсы внутри объекта props и вы хотите передать их в JSX, вы можете использовать оператор расширения ..., чтобы передать весь объект с пропсами.
  Дочерние компоненты в JSX
    В JSX-выражениях содержимое, которое расположено между открывающими и закрывающими тегами, передаётся с помощью специального пропа: props.children. Существует несколько способов передать дочерние компоненты:
      Строковые литералы
        Если вы поместите строку между открывающим и закрывающим тегом, то props.children будет равно этой строке. Это полезно при создании встроенных HTML-элементов. К примеру: <MyComponent>Привет, мир!</MyComponent>
      Дочерние JSX-компоненты
      */
      <MyContainer>
        <MyFirstComponent />
        <MySecondComponent />
      </MyContainer>
      /*
      JavaScript-выражения как дочерние компоненты <MyComponent>{'Пример'}</MyComponent>
      Функции как дочерние компоненты 
        Обычно JavaScript-выражения, вставленные в JSX, будут приведены к строке, React-элементу или списку из всего этого. Тем не менее, props.children работает так же, как и любой другой проп, поэтому в него можно передавать любые типы данных, 
          а не только те, которые React знает как рендерить. К примеру, если у вас есть пользовательский компонент, можно было бы передать колбэк в props.children:
          Дочерние компоненты, передаваемые пользовательскому компоненту, могут быть чем угодно с тем условием, что компонент преобразует их во что-то, что React сможет понять и отрендерить.
      Логические значения, null и undefined игнорируются
        Значения false, null, undefined и true — валидные дочерние компоненты. Просто они не рендерятся. Эти JSX-выражения будут рендерить одно и то же:
          <div />
          <div></div>
          <div>{false}</div>
          <div>{null}</div>
          <div>{undefined}</div>
          <div>{true}</div>
          Этот подход может быть полезным для рендера по условию. Вот пример, где JSX рендерит <Header />, если showHeader равняется true: {showHeader && <Header />}
          Есть один нюанс в том, что React будет рендерить «ложные» (falsy) значения, такие как число 0. props.messages.length && <MessageList messages={props.messages} />
+ Согласование
  Базовая работа:
    1. Из node с помощъю метода render создается дерево элементов Которые описывает все состояние приложения и хранится в памяти. current tree
    2. Далее это дерево попадает в среду рендеринга в случае веба среда переведет это в набор операций необходимых для отрисовки на экране. Приоритезировав их по срочности их попадания к пользователю.
    3. При первой загрузке среда рендеринга отрисовывает все DOM дерево (опять же по приоритету) и мы видим нашу страницу. 
    4. После каких либо изменений снова запускается процесс рендеринга и на основе него строится новое дерево - work in progress tree
    5. Далее сравнивается work in progress tree с current tree и среда рендеринга понимает какие элементы нужно обновить, а какие нет. И снова превращение разницы в набор операций необходимых для отрисовки и их приоритезация. 

  Что такое виртуальный DOM?
    Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.
  React предоставляет декларативный API, который позволяет не беспокоиться о том, что именно изменяется при каждом обновлении. Благодаря этому, писать приложения становится намного проще, но может 
    быть неочевидно как именно это реализовано внутри React. В этой статье объясняются решения, принятые нами для алгоритма сравнения в React, которые делают обновления компонента предсказуемыми, 
    и в то же время достаточно быстрыми для высокопроизводительных приложений.
  Мотивация
    При работе с React вы можете понимать render() как функцию, которая создаёт дерево React-элементов в какой-то момент времени. При последующем обновлении состояния или пропсов функция render() вернёт новое дерево React-элементов. 
    Теперь React должен понять, как эффективно обновить UI, чтобы он совпадал с новейшим из деревьев.
    Существует несколько общих решений алгоритмической проблемы трансформации одного дерева в другое за минимальное количество операций. Тем не менее, передовые алгоритмы имеют сложность порядка O(n3), где n — это число элементов в дереве.
    Если бы мы использовали это в React, отображение 1000 элементов потребовало бы порядка миллиарда сравнений. Это слишком дорого. Взамен, React реализует эвристический алгоритм O(n), который основывается на двух предположениях:
      1. Два элемента с разными типами произведут разные деревья.
      2. Разработчик может указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью пропа key.
      На практике эти предположения верны почти во всех случаях.
  Алгоритм сравнения
      При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.
    ?Элементы различных типов
      Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Переходы от <a> к <img>, или от <Article> к <Comment>, или от <Button> к <div> приведут к полному перестроению.
      При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают componentWillUnmount().
      При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают UNSAFE_componentWillMount(), а затем componentDidMount(). Любое состояние, связанное со старым деревом, теряется.
      Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. Например, это произойдёт при таком сравнении:
      <div>
        <Counter />
      </div>

      <span>
        <Counter />
      </span>
      При этом старый Counter уничтожится, а новый — смонтируется.
    ?DOM-элементы одного типа
      При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Например:
          <div className="before" title="stuff" />
          <div className="after" title="stuff" />
        Сравнивая эти элементы, React знает, что нужно модифицировать только className у лежащего в основе DOM-узла.
        Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства. Например:
          <div style={{color: 'red', fontWeight: 'bold'}} />
          <div style={{color: 'green', fontWeight: 'bold'}} />
          После обработки DOM-узла React рекурсивно проходится по дочерним элементам.
    ?Компоненты одного типа
      Когда class компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами.
      React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает UNSAFE_componentWillReceiveProps(), UNSAFE_componentWillUpdate и componentDidUpdate() на базовом экземпляре.
      Далее вызывается метод render() и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты.
    ?Рекурсия по дочерним элементам
      По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие.
      Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:
        <ul>
          <li>первый</li>
          <li>второй</li>
        </ul  >

        <ul>
          <li>первый</li>
          <li>второй</li>
          <li>третий</li>
        </ul>
        React сравнит два дерева <li>первый</li>, сравнит два дерева <li>второй</li>, а затем вставит дерево <li>третий</li>.

        При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо:
          <ul>
            <li>первый</li>
            <li>второй</li>
          </ul  >

          <ul>
            <li>третий</li>
            <li>первый</li>
            <li>второй</li>
          </ul>
          React будет мутировать каждого потомка, вместо того чтобы оставить первого и второго и вставить третьего. Эта неэффективность может стать проблемой.
      Ключи
        Для решения этой проблемы React поддерживает атрибут key. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. 
        Например, если добавить key к неэффективному примеру выше, преобразование дерева станет эффективным:
        Теперь React знает, что элемент с ключом '2014' — новый, а элементы с ключами '2015' и '2016' только что переместились.
        Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.
        В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление.
  Компромиссы
    Важно помнить, что алгоритм согласования — это деталь реализации. React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов 
      функции render для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он применит различия только следуя правилам, которые были обозначены в предыдущих разделах.
    Мы регулярно совершенствуем эвристику, чтобы ускорить часто встречающиеся варианты использования. В текущей реализации вы можете выразить факт того, что поддерево сдвинулось среди его соседей, но вы не можете сказать, 
      что оно сдвинулось куда-то в другое место. Алгоритм повторно отрендерит всё поддерево.
    React полагается на эвристику, следовательно, если предположения, на которых она основана, не соблюдены, пострадает производительность.
      1. Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов. Если вы заметите за собой, что пытаетесь чередовать компоненты разных типов с очень схожим выводом, то желательно сделать их компонентами одного типа. На практике мы не выявили с этим проблем.
      2. Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать 
          ухудшение производительности и потерю состояния у дочерних компонентов.
  React fiber - это новая реализация алгоритма согласования, которая позволяет React делать больше работы в фоновом режиме, не блокируя основной поток. Это означает, что React может начать рендерить приложение, даже если некоторые компоненты ещё не загрузились.
+ Методы жизненного цикла
  В процессе работы компонент проходит через ряд этапов жизненного цикла. На каждом из этапов вызывается определенная функция, в которой мы можем определить какие-либо действия:
    1. constructor()
      Вы можете не использовать конструктор в React-компоненте, если вы не определяете состояние или не привязываете методы.
      Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
      Конструкторы в React обычно используют для двух целей:
        -Инициализация внутреннего состояния через присвоение объекта this.state.
        -Привязка обработчиков событий к экземпляру.
        Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
    2. static getDerivedStateFromProps(props, state): 
      getDerivedStateFromProps вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
      Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах. Например, это подойдёт для реализации компонента <Transition>, который сравнивает свои предыдущие и следующие дочерние компоненты, чтобы решить, какой из них нужно анимировать.
      Этот метод не имеет доступа к экземпляру компонента. Чтобы использовать пропсы, состояние и методы класса в getDerivedStateFromProps(), их нужно вынести за пределы класса в виде чистых функций.
      Если вы хотите повторно использовать код между getDerivedStateFromProps() и другими методами класса, извлеките чистые функции пропсов и состояния компонента и поместите их вне определения класса.
    3. shouldComponentUpdate(nextProps, nextState)
      Используйте shouldComponentUpdate(), чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. В большинстве случаев вы должны полагаться на это поведение.
        shouldComponentUpdate() вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод не вызывается при первом рендере или когда используется forceUpdate().
      Этот метод нужен только для повышения производительности. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам.
        Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
      Если вы уверены, что хотите написать его вручную, вы можете сравнить this.props с nextProps, а this.state с nextState. Верните false чтобы пропустить обновление React. Возврат false не предотвращает повторный рендер дочерних компонентов при изменении их состояния.
      В настоящее время, если shouldComponentUpdate() возвращает false, то UNSAFE_componentWillUpdate(), render() и componentDidUpdate() не будут вызваны. В будущем React может рассматривать shouldComponentUpdate() как подсказку, 
        а не строгое указание. В таком случае возврат false сможет привести к повторному рендеру компонента.
    4. render() — единственный обязательный метод в классовом компоненте.
      При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов:
        -Элемент React. Обычно создаётся с помощью JSX. Указывает React, что рендерить: DOM-узел или пользовательский компонент. Например, <div /> или <MyComponent />.
        -Массивы и фрагменты. Возвращает несколько элементов из render(). Подробнее про фрагменты.
        -Порталы. Рендерит несколько дочерних элементов в другое поддерево DOM. Подробнее про порталы.
        -Строки и числа. Рендерит текстовые DOM-узлы.
        -Booleans или null. Ничего не рендерит. (Обычно необходим для поддержки паттерна return test && <Child />, где test — логическое значение.)
      Функция render() должна быть чистой. Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же результат, не взаимодействует напрямую с браузером.
    5. getSnapshotBeforeUpdate(prevProps, prevState)
      getSnapshotBeforeUpdate() вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. 
        Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
      Это применяется редко, но может быть полезно в таких интерфейсах, как цепочка сообщений в чатах, в которых позиция прокрутки обрабатывается особым образом.
      Значение снимка (или null) должно быть возвращено. componentDidUpdate(prevProps, prevState, snapshot) {}.
    6. componentDidMount() 
      Вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
      Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
    7. componentDidUpdate(prevProps, prevState, snapshot)
      componentDidUpdate() вызывается сразу после обновления. Не вызывается при первом рендере.
        Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
      В componentDidUpdate() можно вызывать setState(), однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл. 
    8. componentWillUnmount()
      componentWillUnmount() вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
+ Оптимизация производительности
  React использует несколько умных подходов для минимизации количества дорогостоящих DOM-операций, необходимых для обновления пользовательского интерфейса. Для многих приложений, использование React приведёт к быстрому пользовательскому интерфейсу без особых усилий по оптимизации производительности. 
    Тем не менее, существует несколько способов ускорить React-приложение.
    1. Использование продакшен-сборки
      По умолчанию в React есть много вспомогательных предупреждений, очень полезных при разработке. Тем не менее, они делают React больше и медленнее, поэтому вам обязательно следует использовать продакшен-версию при деплое приложения.
    2. Анализ производительности компонентов с помощью инструмента разработки «Profiler»
      Пакеты react-dom версии 16.5+ и react-native версии 0.57+ предоставляют расширенные возможности анализа производительности в режиме разработки с помощью инструментов разработчика React Profiler.
    3. Виртуализация длинных списков
      Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать метод известный как «оконный доступ». Этот метод рендерит только небольшое подмножество строк в данный момент времени и может значительно сократить время, 
        необходимое для повторного рендера компонентов, а также количество создаваемых DOM-узлов.
      react-window и react-virtualized — это популярные библиотеки для оконного доступа. Они предоставляют несколько повторно используемых компонентов для отображения списков, сеток и табличных данных. Если вы хотите использовать что-то более специфическое для вашего конкретного случая, 
        то вы можете создать собственный компонент с оконным доступом, как это сделано в Twitter.
    4. Избежание согласования
      React создаёт и поддерживает внутреннее представление отображаемого пользовательского интерфейса. Оно также включает React-элементы возвращаемые из ваших компонентов. Это представление позволяет React избегать создания DOM-узлов и не обращаться к текущим без необходимости, 
        поскольку эти операции могут быть медленнее, чем операции с JavaScript-объектами. Иногда его называют «виртуальный DOM», но в React Native это работает точно так же.
      Когда изменяются пропсы или состояние компонента, React решает нужно ли обновление DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM.
      Несмотря на то, что React обновляет только изменённые DOM-узлы, повторный рендеринг всё же занимает некоторое время. В большинстве случаев это не проблема, но если замедление заметно, то вы можете всё ускорить, переопределив метод жизненного цикла shouldComponentUpdate, 
        который вызывается перед началом процесса ререндеринга. Реализация этой функции по умолчанию возвращает true, указывая React выполнить обновление:
        */
        shouldComponentUpdate(nextProps, nextState) {
          return true;
        }
        /*
        Если вы знаете ситуации, в которых ваш компонент не нуждается в обновлении, вы можете вернуть false из shouldComponentUpdate, чтобы пропустить весь процесс рендеринга, включая вызов render() и так далее ниже по иерархии.
        В большинстве случаев вместо того, чтобы писать shouldComponentUpdate() вручную, вы можете наследоваться от React.PureComponent. Это эквивалентно реализации shouldComponentUpdate() с поверхностным сравнением текущих и предыдущих пропсов и состояния.
      shouldComponentUpdate в действии
        Если единственный случай изменения вашего компонента это когда переменная props.color или state.count изменяются, вы могли бы выполнить проверку в shouldComponentUpdate следующим образом:
        */
        class CounterButton extends React.Component {
          constructor(props) {
            super(props);
            this.state = {count: 1};
          }
        
          shouldComponentUpdate(nextProps, nextState) {
            if (this.props.color !== nextProps.color) {
              return true;
            }
            if (this.state.count !== nextState.count) {
              return true;
            }
            return false;
          }
        
          render() {
            return (
              <button
                color={this.props.color}
                onClick={() => this.setState(state => ({count: state.count + 1}))}>
                Счётчик: {this.state.count}
              </button>
            );
          }
        }
        /*
        В этом коде shouldComponentUpdate — это простая проверка на наличие каких-либо изменений в props.color или state.count. Если эти значения не изменяются, то компонент не обновляется.
        Если ваш компонент стал более сложным, вы можете использовать аналогичный паттерн «поверхностного сравнения» между всеми полями props и state, чтобы определить должен ли обновиться компонент.
        Этот механизм достаточно распространён, поэтому React предоставляет вспомогательную функцию для работы с ним — просто наследуйтесь от React.PureComponent. Поэтому, следующий код — это более простой способ добиться того же самого эффекта:
        */class CounterButton extends React.PureComponent {
          constructor(props) {
            super(props);
            this.state = {count: 1};
          }
        
          render() {
            return (
              <button
                color={this.props.color}
                onClick={() => this.setState(state => ({count: state.count + 1}))}>
                Счётчик: {this.state.count}
              </button>
            );
          }
        }
        /*
        В большинстве случаев вы можете использовать React.PureComponent вместо написания собственного shouldComponentUpdate. Но он делает только поверхностное сравнение, поэтому его нельзя использовать, если 
          пропсы и состояние могут измениться таким образом, который не сможет быть обнаружен при поверхностном сравнении.
        Это может стать проблемой для более сложных структур данных.
          Проблема в том, что PureComponent сделает сравнение по ссылке между старыми и новыми значениями this.props.words. Поскольку этот код мутирует массив words в методе handleClick компонента WordAdder, старые и новые 
          значения this.props.words при сравнении по ссылке будут равны, даже если слова в массиве изменились. ListOfWords не будет обновляться, даже если он содержит новые слова, которые должны быть отрендерены.
        Сила иммутабельных данных
          Лучший способ решения этой проблемы — избегать мутирования значений, которые вы используете как свойства или состояние. ES6 поддерживает синтаксис расширения для массивов, который поможет сделать это проще.
          Синтаксис расширения свойств объекта упрощает обновление объектов без мутаций:
          function updateColorMap(colormap) {
            return {...colormap, right: 'blue'};
          }
+ Порталы
  Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.
    ReactDOM.createPortal(child, container) Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
    Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла:
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
  Всплытие событий через порталы
    Как уже было сказано, портал может находиться в любом месте DOM-дерева. Несмотря на это, во всех других аспектах он ведёт себя как обычный React-компонент. Такие возможности, как контекст, работают привычным образом, даже если потомок является порталом, 
    поскольку сам портал всё ещё находится в React-дереве, несмотря на его расположение в DOM-дереве.
    Так же работает и всплытие событий. Событие, сгенерированное изнутри портала, будет распространяться к родителям в содержащем React-дереве, даже если эти элементы не являются родительскими в DOM-дереве. Представим следующую HTML-структуру:
    <html>
      <body>
        <div id="app-root"></div>
        <div id="modal-root"></div>
      </body>
    </html>
    Родительский компонент в #app-root сможет поймать неперехваченное всплывающее событие из соседнего узла #modal-root.
    Перехват событий, всплывающих от портала к родительскому компоненту, позволяет создавать абстракции, которые не спроектированы специально под порталы. Например, вы отрендерили компонент <Modal />. Тогда его события могут быть перехвачены родительским компонентом, вне зависимости от того, 
      был ли <Modal /> реализован с использованием порталов или без них.
    В index.html <div id="modal"></div>
    */const modalRootElement = document.querySelector("#modal");
      const Modal = (props) => {
        const { open, onClose } = props;
      
        const element = useMemo(() => document.createElement("div"), []); // создаем элемент div
      
        useEffect(() => {
          if (open) {
            modalRootElement.appendChild(element); // добавляем элемент в DOM
          
            return () => {
              modalRootElement.removeChild(element);
            };
          }
        });
      
        if (open) {
          return createPortal( // создаем портал 
          <div className={style.modal_background} onClick={onClose}> // ренднрим в него компонент
            <div className={style.modal_card}>{props.children}</div>
            </div>,
            element // указываем элемент, в который рендерить
            );
          }
      
          return null;
      };

      const App = () => {
        const [open, setOpen] = useState(false);
      
        return (
          <>
            <button onClick={() => setOpen(true)}>Открыть / Закрыть</button>
            <Modal open={open} onClose={() => setOpen(false)}>
              <P>123</P>
            </Modal>
          </>
        );
      };
      /*
+ Рефы и DOM
  Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.
  В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы. Чтобы модифицировать потомка, вы должны заново отрендерить его с новыми пропсами. Тем не менее, могут возникать ситуации, когда вам требуется императивно изменить дочерний элемент, обойдя обычный поток данных. 
    Подлежащий изменениям дочерний элемент может быть как React-компонентом, так и DOM-элементом. React предоставляет лазейку для обоих случаев.
  Когда использовать рефы
    -Управление фокусом, выделение текста или воспроизведение медиа.
    -Императивный вызов анимаций.
    -Интеграция со сторонними DOM-библиотеками.
    Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом. Не злоупотребляйте рефами!
  Создание рефов
    Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.
    */
    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.myRef = React.createRef();
      }
      render() {
        return <div ref={this.myRef} />;
      }
    }
    /*
  Доступ к рефам
    Когда реф передаётся элементу в методе render, ссылка на данный узел доступна через свойство рефа current. const node = this.myRef.current;
      -Когда атрибут ref используется с HTML-элементом, свойство current созданного рефа в конструкторе с помощью React.createRef() получает соответствующий DOM-элемент.
      -Когда атрибут ref используется с классовым компонентом, свойство current объекта-рефа получает экземпляр смонтированного компонента.
      -Нельзя использовать ref атрибут с функциональными компонентами, потому что для них не создаётся экземпляров.
  Рефы и функциональные компоненты
    По умолчанию нельзя использовать атрибут ref с функциональными компонентами, потому что для них не создаётся экземпляров:
    Если вам нужен реф на функциональный компонент, можете воспользоваться forwardRef (возможно вместе с useImperativeHandle), либо превратить его в классовый компонент.
    Тем не менее, можно использовать атрибут ref внутри функционального компонента при условии, что он ссылается на DOM-элемент или классовый компонент: 
    */
    function CustomTextInput(props) {
      // textInput должна быть объявлена здесь, чтобы реф мог иметь к ней доступ
      const textInput = useRef(null);
    
      function handleClick() {
        textInput.current.focus();
      }
    
      return (
        <div>
          <input
            type="text"
            ref={textInput} />
          <input
            type="button"
            value="Фокус на поле для ввода текста"
            onClick={handleClick}
          />
        </div>
      );
    }
    /*
+ Рендер-пропсы
  Термин «рендер-проп» относится к возможности компонентов React разделять код между собой с помощью пропа, значение которого является функцией.
  Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера.
    <DataProvider render={data => (
      <h1>Привет, {data.target}</h1>
    )}/>
    Такой подход, в частности, применяется в библиотеках React Router v5, React hook form, Downshift и Formik.
  Использование рендер-пропа для сквозных задач
    Компоненты — это основа повторного использования кода в React. Однако бывает неочевидно, как сделать, чтобы одни компоненты разделяли своё инкапсулированное состояние или поведение с другими компонентами, заинтересованными в таком же состоянии или поведении.
    Иными словами, рендер-проп — функция, которая сообщает компоненту что необходимо рендерить.
  */
  const Mouse = () => {
    const [position, setPosition] = useState({
      x: 0,
      y: 0
    });
    const mouseMoveHandler = (e) => {
      setPosition({
        x: e.clientX,
        y: e.clientY
      })
    }
    return <p onMouseMove={mouseMoveHandler}>{position.x}:{position.y}</p>
  }
  
  
  export default function App() {
    return (
      <>
      <Mouse />
      </>
    );
  }
  //--------------------------------------------------------------------------
  const Mouse = ({ render }) => {
    const [position, setPosition] = useState({
      x: 0,
      y: 0
    });
    const mouseMoveHandler = (e) => {
      setPosition({
        x: e.clientX,
        y: e.clientY
      })
    }
    return <div onMouseMove={mouseMoveHandler}>{render(position)}</div>
  }
  
  
  export default function App() {
    return (
      <>
      <Mouse render={(data)=> {
        return <p>{data.x}:{data.y}</p>
      }} />
      <Mouse render={(data)=> {
        return <div style={{width: '100px', height: '100px', background: 'lightBlue'}}> // либо передать как children
          <p>{data.x}:{data.y}</p>
        </div>
      }} />
      </>
    );
  }
  //--------------------------------------------------------------------------
  const Mouse = ({ render }) => {
    const [position, setPosition] = useState({
      x: 0,
      y: 0
    });
    // const ref = useRef();
    const mouseMoveHandler = (e) => {
      setPosition({
        x: e.clientX, //- rect.left
        y: e.clientY //- rect.top
      })
    }
    return <div onMouseMove={mouseMoveHandler}>{render(position)}</div>
    {/*
          Вместо статического представления того, что рендерит <Mouse>,
          используем рендер-проп для динамического определения, что надо отрендерить.
        */}
  }
  
  const Card = () => {
  
    return <Mouse /* ref={ref} */ render={(data) => {
      return <div style={{width: '100%', height: '150px', background: 'lightBlue'}}>
      <p>{data.x}:{data.y}</p>
    </div>
    }} />
  }
  
  export default function App() {
    return (
      <>
      <Card />
      <Card />
      <Card />
      </>
    );
  }
  /*
  Один интересный момент касательно рендер-пропсов заключается в том, что вы можете реализовать большинство компонентов высшего порядка (HOC), используя обычный компонент вместе с рендер-пропом. 
    Например, если для вас предпочтительней HOC withMouse вместо компонента <Mouse>, вы можете создать обычный компонент <Mouse> вместе с рендер-пропом:
    */
    // Если вам действительно необходим HOC по некоторым причинам, вы можете просто
    // создать обычный компонент с рендер-пропом!
    function withMouse(Component) {
      return class extends React.Component {
        render() {
          return (
            <Mouse render={mouse => (
              <Component {...this.props} mouse={mouse} />
            )}/>
          );
        }
      }
    }
    /*
    Таким образом, рендер-пропы позволяют реализовать любой из описанных выше паттернов.
  Использование пропсов, отличных от render (как название передаваемого свойства)
    Важно запомнить, что из названия паттерна «рендер-проп» вовсе не следует, что для его использования вы должны обязательно называть проп render. На самом деле, любой проп, который используется компонентом и 
    является функцией рендеринга, технически является и «рендер-пропом». Несмотря на то, что в вышеприведённых примерах мы используем render, мы можем также легко использовать проп children!
    <Mouse children={mouse => (
      <p>Текущее положение курсора мыши: {mouse.x}, {mouse.y}</p>
    )}/>
  Предостережения
    Будьте осторожны при использовании рендер-проп вместе с React.PureComponent
    Использование рендер-пропа может свести на нет преимущество, которое даёт React.PureComponent, если вы создаёте функцию внутри метода render. Это связано с тем, что поверхностное сравнение пропсов всегда будет возвращать false для новых пропсов и каждый render будет генерировать новое значение для рендер-пропа.
+ Строгий режим
  https://ru.reactjs.org/docs/strict-mode.html
  StrictMode — инструмент для обнаружения потенциальных проблем в приложении. Также как и Fragment, StrictMode не рендерит видимого UI. Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.
  Проверки строгого режима работают только в режиме разработки; они не оказывают никакого эффекта в продакшен-сборке.
  Строгий режим может быть включён для любой части приложения.
  На данный момент StrictMode помогает в:
    -Обнаружении небезопасных методов жизненного цикла
    -Предупреждении об использовании устаревшего API строковых реф
    -Предупреждении об использовании устаревшего метода findDOMNode
    -Обнаружении неожиданных побочных эффектов
    -Обнаружении устаревшего API контекста
    -Обеспечение переиспользованного состояния
+ Неуправляемые компоненты
  В большинстве случаев при работе с формами мы рекомендуем использовать управляемые компоненты. В управляемом компоненте, данные формы обрабатываются React-компонентом. 
    В качестве альтернативы можно использовать неуправляемые компоненты. Они хранят данные формы прямо в DOM.
  Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.
  */
  class NameForm extends React.Component {
    constructor(props) {
      super(props);
      this.handleSubmit = this.handleSubmit.bind(this);
      this.input = React.createRef();
    }
  
    handleSubmit(event) {
      alert('Отправленное имя: ' + this.input.current.value);
      event.preventDefault();
    }
  
    render() {
      return (
        <form onSubmit={this.handleSubmit}>
          <label>
            Имя:
            <input type="text" ref={this.input} />
          </label>
          <input type="submit" value="Отправить" />
        </form>
      );
    }
  }
  /*
  Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. 
    Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
  Тег поля загрузки файла <input type="file" />
    В React <input type="file"> всегда является неуправляемым компонентом, потому что его значение может быть установлено только пользователем, а не программным путём.
    Для взаимодействия с файлами следует использовать File API. В следующем примере показано, как создать реф на DOM-узел, чтобы затем получить доступ к файлам в обработчике отправки формы:
    */
    class FileInput extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.fileInput = React.createRef();
      }
      handleSubmit(event) {
        event.preventDefault();
        alert(
          `Selected file - ${this.fileInput.current.files[0].name}`
        );
      }
    
      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Upload file:
              <input type="file" ref={this.fileInput} />
            </label>
            <br />
            <button type="submit">Submit</button>
          </form>
        );
      }
    }
    
    const root = ReactDOM.createRoot(
      document.getElementById('root')
    );
    root.render(<FileInput />);
    /*
+ API для работы с Profiler
  https://ru.reactjs.org/docs/profiler.html#gatsby-focus-wrapper  
  Profiler измеряет то, как часто рендерится React-приложение и какова «стоимость» этого. Его задача — помочь найти медленные части приложения, которые можно оптимизировать (например, через мемоизацию).
    Использование
      Profiler может быть добавлен в любую часть React-дерева для измерения стоимости рендеринга этой части. Он принимает два пропа: id (string) и колбэк onRender (function), который React вызывает каждый раз, когда компонент внутри дерева «фиксирует» обновление.
      */
      render(
        <App>
          <Profiler id="Navigation" onRender={callback}>
            <Navigation {...props} />
          </Profiler>
          <Profiler id="Main" onRender={callback}>
            <Main {...props} />
          </Profiler>
        </App>
      );
      /*
      Также Profiler может быть вложенным с целью замера разных компонентов внутри поддерева.
    Колбэк onRender
      Profiler принимает функцию onRender в качестве пропа. React вызывает эту функцию каждый раз, когда компонент внутри профилируемого дерева «фиксирует» изменение. Эта функция принимает параметры, которые описывают, что было отрендерено и сколько времени это заняло.
      */
      function onRenderCallback(
        id, // проп "id" из дерева компонента Profiler, для которого было зафиксировано изменение
        phase, // либо "mount" (если дерево было смонтировано), либо "update" (если дерево было повторно отрендерено)
        actualDuration, // время, затраченное на рендер зафиксированного обновления
        baseDuration, // предполагаемое время рендера всего поддерева без кеширования
        startTime, // когда React начал рендерить это обновление
        commitTime, // когда React зафиксировал это обновление
        interactions // Множество «взаимодействий» для данного обновления 
      ) {
        // Обработка или логирование результатов...
      }
      /*
+Новое в React 18
  ?Новый render API
    Использование старого Root API будет сопровождаться предупреждением в консоли о необходимости переключения на новый.
    */
    import ReactDOM from 'react-dom/client';

    import App from 'App';
        
    const container = document.getElementById('app');
        
    // До
    ReactDOM.render(<App tab="home" />, container);
        
    // После
    const root = ReactDOM.createRoot(container);
    root.render(<App tab="home" />);
    /*
    Теперь отдельно создается “корень” — указатель верхнеуровневой структуры данных, которую React использует для отслеживания дерева для рендеринга. В предыдущих версиях React “корень” 
      был недоступен для пользователя, React прикреплял его к DOM-узлу и никуда не возвращал.
    Без createRoot не Не работают новые возможности.
  ?Batching 
    React 18 добавляет возможность автоматического батчинга обновления состояний для асинхронных операций: promise, таймауты, fetch запросы. Батчингом в React называют процесс группировки 
      нескольких вызовов обновления состояния в один этап ререндера. Это положительно сказывается на производительности.
    До React 18 батчинг также существовал, но автоматически работал только для обработчиков DOM событий:
    */ // вот так в 17 версии не работал батчинг
    const update = () => {
      setTimeout(() => {
        setCount(prev => prev + 1);
        setCount(prev => prev + 2);
      }, 100);
    }
    /*
    */function App() {
      const [count, setCount] = useState(0);
      const [flag, setFlag] = useState(false);

      function handleClick() { 
        setCount(c => c + 1); // Не вызывает ререндер
        setFlag(f => !f); // Не вызывает ререндер
        // React вызовет ререндер только один раз, в конце
      }
    
    /*
      function handleClick() {
        fetchSomething().then(() => {
            /До React 17 следующие вызовы не батчились
            /Установка состояния происходит “после” события, в колбэке асинхронного вызова
          setCount(c => c + 1); // Спровоцирует ререндер
          setFlag(f => !f); // Спровоцирует ререндер
        });
      }
    */
    
      return (
        <div>
          <button onClick={handleClick}>Next</button>
          <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
        </div>
      );
    }
    /*
    В React 18 все обновления состояния внутри Promise, таймаутов, fetch-запросов будут батчиться также, как для обработчиков DOM-событий. Код ниже:
    */function handleClick() {
      setCount(c => c + 1);
      setFlag(f => !f);
      // React будет вызывать ререндер только один раз, в конце
    }

    //работает так же, как и этот код:

    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // React будет вызывать ререндер только один раз, в конце
    }, 1000);
    /*
    Как отменить батчинг?
    Обычно батчинг безопасен и не вызывает проблем при разработке, но если сразу после обновления состояния нужно прочитать изменения в DOM, то можно использовать ​​ReactDOM.flushSync() для отмены батчинга:
    */import { flushSync } from 'react-dom'; // Внимание: react-dom, не react

    function handleClick() {
      flushSync(() => {
        setCounter(c => c + 1);
      });
      // React вызовет ререндер 
      flushSync(() => {
        setFlag(f => !f);
      });
      // React вызовет ререндер 
    }
    /*
  ?Конкурентный режим
    Меняет подход работы реакта. Рендеринг становится параллельным, может происходить сразу несколько рендеров. Он становится прерываемым, то есть в любой react может поставить его на паузу.
    Представьте, что пользователь вводит в строку поиска текст. Это событие обновляет состояние компонента, и происходит рендер нового списка результатов. Во время этого процесса залипает ввод: 
      браузер не может обновить введенный в поле текст, так как занимается рендером нового списка результатов. Конкурентный режим исправляет это ограничение, делая рендер прерываемым.
    Конкурентный режим позволяет сделать эту перерисовку отложенной. Он сам строит очередь приоритетов и сам определяет, когда эту перерисовку произвести. При этом нам обещают, что на интерфейсе это никак не отобразится. 
      Он также будет целостным согласованным, как это и было в синхронной модели. При этом вся реализация скрыто от нас.
      const [isPending, startTransition] = useTransition(); Returns a stateful value for the pending state of the transition, and a function to start it.
      startTransition lets you mark updates in the provided callback as transitions:
      startTransition(() => {
        setCount(count + 1);
      })
      isPending indicates when a transition is active to show a pending state:
      */
      function App() {
        const [isPending, startTransition] = useTransition(); // первый аргумент - подготавливается рендер или нет, второй - функция, которая запускает отложенный рендер
        const [count, setCount] = useState(0);
        
        function handleClick() {
          startTransition(() => {
            setCount(c => c + 1);
          })
        }
      
        return (
          <div>
            {isPending && <Spinner />}
            <button onClick={handleClick}>{count}</button>
          </div>
        );
      }
      /*
    const deferredValue = useDeferredValue(value); // Почти аргумента он принимает какое то значение это значение он будет изменять отложено.
    Фактически то же самое, только мы сами не вызываем star транзишн, а за нас это делает этот хук. Мы просто вверху передаем значение, которое нужно отложено использовать.
  ? const id = useId(); // Возвращает уникальный идентификатор, который не будет изменяться между рендерами.
  ? Добавлена возможность использовать lazy и suspense на стороне сервера SSR

+REDUX 
  Redux — это инструмент для управления состоянием данных и пользовательским интерфейсом в приложениях JavaScript с большим количеством сущностей. Представляет собой библиотеку JavaScript.
    Название читается как «Редакс» и составлено из двух слов: reduce и flux. Reduce — это функция, которая приводит большую структуру данных к одному значению. Flux — архитектура приложения, 
      при которой данные передаются в одну сторону. Инструмент основан на этих двух понятиях, поэтому они вынесены в название.
  Redux базируется на трех принципах, из которых следует характер работы с ним.
    -Единый источник состояния.
      Все данные о состоянии приложения хранятся в одном месте, без копий. Глобальное состояние организовано как дерево объектов и называется state tree. Также используются термины «источник состояния» и «хранилище». 
        Оба означают местонахождение глобального состояния. Единый источник нужен для централизации и отладки приложения. Работа становится проще, если данные находятся в одном месте.
    -Доступ к состоянию — только для чтения.
      Глобальное состояние заблокировано для записи. Компоненты приложения могут читать из него, но не переписывать по своему желанию. Это предотвращает непредсказуемые изменения. Ситуаций, когда объект изменился, 
        а функции об этом не узнали, не бывает. При изменениях в состояние нужно отправить действие (action). Специальный объект сообщит о произошедшем.
    -Изменения — только через редукторы. 
      Когда в состояние поступает действие, его обрабатывают редукторы, или редьюсеры (reducers). Это чистые функции — результат их выполнения зависит только от входных данных.
      Редукторы берут объект состояния компонента, который изменился, и действие. На их основе они генерируют новый объект состояния. Функции всегда создают новый объект. Если действие сложное, а приложение большое, для него могут запуститься несколько редукторов.
      Результат работы редуктора — новый объект состояния с актуальными данными, рассчитанными на основе информации из объекта-действия. Он попадает в дерево состояний вместо старого.






*/
