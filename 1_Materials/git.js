/* 
?Merge
  git merge master  - (забираем все commit)находять в ответвлении мы к себе мержим ветку master.  Все накопленные изменения переместятся к нам.
  git merge master newBranch – Смержи состояние мастера в ветку newBranch
  В итоге все комиты с ветки master собираются в один коммит. Там теперь все изменения пока нас не было в мастере.
?Rebase
  git checkout newBranch 
  git rebase master
  Мы как будто бы полностью пересоздали нашу ветку, но все коммиты из master скопируются в нашу новую ветку. Не теже самые коммиты, а копия наших коммитов. Звездочкой помеченны наши новые коммиты.
?Rebase -i
  git rebase –i  master нтерактивный rebase – хотим перебазироваться на свежий master интерактивно. Мы увидим команду, хеш коммита и message. Меняя текст дейтвия мы можем наприм забрать commit при помощи 
    команды pick можем удалить (отбросить) fixup – мы берем один и 2й коммит и склеиваим их вместе. Команда fixup объединяет коммиты.
  Нюанс! После merge мы можем выполнить команду git push, потому что мы в конец нашей истории добавили новый комит. В случае когда выполняем rebase – мы меняем полностью историю нашей ветки. И так как эти 2 ветки по сути не 
    соеденины мы должны выполнить команду git push –force (мы переписываем историю для этой ветки). Очень аккуратно с force, так как он полностью перезаписывает историю!
  Мы можем не перемещаясь по мастеру на более свежую версию работать внутри своей ветки и например объединить несколько коммитов git rebase –i HEAD-3 (в качестве ветки HEAD это ссылка на самый последний коммит нашей текущей ветки. 
    По сути Head это наше текущее положение на этой ветке -3 обозначает сдвинься на 3 коммита левее). Т.е. мы выполняем rebase c 3го коммита с конца, а все остальный коммиты мы можем как то изменить(например сложить их вместе).
?Отличия – merge не меняет точку начала нашей ветки, а по сути добавляет новый коммит который содержит все изменения из другой ветки. А rebase берет начало нашей ветки и перемещает ее на актуальную версию другой ветки, т.е. мы меняем базу!
?git revert <хеш красного commit> -  создает новый коммит который в себе содержит обратные изменения (зеркальные) для выбранного коммита. Есть наприм 3 коммита и мы поняои что во 2м мы допустили ошибку и хотим его откатить. Либо отменить эти изменения. И таким образом будут изменения обратные красному коммиту.
?git reset – меняет не только текущий head, но и указатель ветки (Мы меняем ресетаем указатель текущей ветки на какое то другое значение.)
  Существует несколько режимов в котором мы можем выполнить reset:
    -По умолчанию –mixed (мы поменяем указатель head текущий  - на что указывает ветка, но при этом все файлы оставим на месте.) Т.е. если мы 2 коммита назад имели файлы А и Б, а на нашем текущем коммите А, Б, С, то после ресета у нас 
      в рабочей директории останется 3 файла. Таким образом все новые файли или все изменения будут видны как что то измененное, но еще не закомиченное.
    -soft разница только в Staging зоне ( в том какие файлы попали в index) mixed и soft можно считать одной командой, так как в IDE не имеет значения файлы попали в staging или нет.
    -hard меняет не тоько историю коммитов(меняет указатель HEAD, указатель ветки а также меняет состояние рабочей директории на состояние коммита к которому мы пришли). Т.е. если мы 2 коммита назад имели файлы А и Б, 
      а на нашем текущем коммите А, Б, С, то после ресета hard у нас в рабочей директории остануться А и Б.
    Разница между hard и soft: hard полезен в том случае, когда мы поняли что сделали ерунду либо наш подход не сработал и мы просто откатываем наш код до n коммитов назад. soft полезен тогда когда мы выполнили задачу, в целом она выглядит хорошо, 
      но нужно немного по другому перестороить коммиты => делаем git reset –soft на начало нашей ветки (мы получаем состояние ветки от старта), но в рабочей директории все наши файлы присутствуют которые мы меняли в этой ветке и дальше мы можем 
      групировать эти файлы по коммитам. Не так как мы с ними работали наприм сделали правки  файлов А и Б затем файлов Б и С, а затем а А и С. А закомитили по порядку сначала А затем Б затем С.
Отличие revert от reset: Мы можем выполнить ту же самую операцию (откатить изменения), но в случае с revert мы создаем новый коммит который выполняет обратные изменения и вся история сохраняется (какой то подход попробовали он не сработал и мы перешли назад). 
  В случае с reset мы отменяем эти изменения и переходим к предыдущему состоянию и если мы запушим эти изменения, то в истории ничего не сохранится.
?git cherry-pick commitHash 
  позволяет копировать коммит из одной ветки в другую. Из ветки master хотим скопировать в ветку staging => перемещаемся на ветку staging и выполняем команду выше и в итоге у нас появляется коммит который повторяет все изменения коммита из master, 
  но это будет совершенно новый коммит который относится к ветке staging. Применение – кто то в команде обновил конфиг и он нужен нам для нашей задачи. Мы не хотим перемещатся и меджить master к себе, так как будут какие то конфликты и мы хотим 
  как можно быстрее получить новый конфиг и продолжить работу на своей ветке. Еще как пример: мы решили сделать от master новый релиз. В релизе мы находим баг, далее исправляем его и далее cherrypick исправленого файла в master








*/