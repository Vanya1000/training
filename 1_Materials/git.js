/* 
?Merge
  git checkout feature => git merge master (мы коммиты из мастера мерджим в фичу) или одной строкой git merge feature master
    В итоге все комиты с ветки master собираются в один коммит. Там теперь все изменения пока нас не было в мастере.
  В результе произойдет создание нового коммита с сообщением Merge branch 'master' into feature который в себе будет содержать все изменения с мастера.
    В этом и преимущество что не разрушается история коммитов. И если над нашей фичей работали еще другие люди, то если мы запушим в удаленный репозиторий, то коллега просто подобновит свою текущую ветку и у него появятся все изменения с мастера.
    Но в этом и недостаток что если мы часто будем подобновляться от мастера то наша ветка засориться этими мердж коммитами.
?Rebase
  git checkout feature => git rebase master 
  В результате вся наша фича ветка в которой мы разрабатывали и делали там какие то коммиты она окажется после всех коммитов которые были произведены в мастере.
    Гид отрывает все наши кометы, которые мы делали фича ветке. => В нашей фича ветку заливает свежий мастер. => И затем начинает приклеивать все коммиты, которые были в нашей фича ветке.
    Выглядит так, как будто мы прямо сейчас отпочковались от мастера. И после этого сделали наши коммиты.
  История коммитов будет чистой. И если мы после pull request сделаем merge то у нас не будет мердж коммитов. А если еще и свошитьв один то у нас будет красота.
?Rebase -i HEAD~3 (изменить историю 3х последних коммитов)
  Можем его применять как при рибозе одной ветки в другую, так и на конкретной ветке. Далее откроется текстовый редактор, где мы в ручном режиме сможем отредактировать.
    Команды которые можно использовать:
    pick - оставить коммит как есть
    reword - изменить сообщение коммита
    edit - оставить коммит, но остановиться на нем
    squash - слить коммит с предыдущим
    fixup - слить коммит с предыдущим, но не сохранять сообщение (сообщение коммита будет удалено)
    exec - выполнить команду
    drop - удалить коммит
    reset - сбросить коммит
    merge - слить коммит с предыдущим
    esc :wq - сохранить и выйти => git push origin develop --force
  Подобновление нашей фича ветки от master (Мы хотим переносить не все коммиты с нашей ветки, а только выборочно). Т.е мы хотим сделать ребейз, но что бы туда попали не все коммиты из нашей ветки, а только те, которые мы выберем.
    git rebase -i master и далее в vim редакторе выбираем что вообще хотим сделать при ребейзе, не только сливать коммиты, но и удалять их, переименовывать и т.д.
?Отличия – merge не меняет точку начала нашей ветки, а по сути добавляет новый коммит который содержит все изменения из другой ветки. А rebase берет начало нашей ветки и перемещает ее на актуальную версию другой ветки, т.е. мы меняем базу!

?git reset или git reset --mixed <commit>(по умолчанию)
  --mixed
    При выполнении этой команды мы откатываемся на указанный коммит (перемещаем head), но при этом изменения остаются в рабочей директории. Так же можем и вернуться обратно.
      С этим флагом или по умолчанию мы можем откатиться на любой коммит, но при этом изменения останутся в рабочей директории.
        Откатываем и git commit и git add
  --soft
    Все файлы, которые были в этом комитете, находятся в stage area(как будто git add .). 
      Откатываем только git commit!
  --hard
    Откатываем вплоть до локальных изменений
      Откатываем git commit, git add и локальные изменения

  Разница между hard и soft: hard полезен в том случае, когда мы поняли что сделали ерунду либо наш подход не сработал и мы просто откатываем наш код до n коммитов назад. soft полезен тогда когда мы выполнили задачу, в целом она выглядит хорошо, 
      но нужно немного по другому перестороить коммиты => делаем git reset –soft на начало нашей ветки (мы получаем состояние ветки от старта), но в рабочей директории все наши файлы присутствуют которые мы меняли в этой ветке и дальше мы можем 
      групировать эти файлы по коммитам.
  
  
      Отличие revert от reset: Мы можем выполнить ту же самую операцию (откатить изменения), но в случае с revert мы создаем новый коммит который выполняет обратные изменения и вся история сохраняется (какой то подход попробовали он не сработал и мы перешли назад). 
  В случае с reset мы отменяем эти изменения и переходим к предыдущему состоянию и если мы запушим эти изменения, то в истории ничего не сохранится.

?git revert <хеш красного commit> -  
  Проблема: Обычно мы для отмены коммита используем git reset  или rebase -i, но если мы запушили и другие разработчики уже использовали его изменения, то мы не можем просто так отменить эти изменения. В этом случае мы можем использовать git revert.
  создает новый коммит который в себе содержит обратные изменения (если что то было довавлено, то в этом коммите это будет удалено) для выбранного коммита. 
  Есть наприм 3 коммита и мы поняои что во 2м мы допустили ошибку и хотим его откатить. Либо отменить эти изменения. И таким образом будут изменения обратные красному коммиту.
    Очень похож на cherry-pick, но в коммите будет обратные изменения!

?git cherry-pick commitHash 
  позволяет копировать коммит из одной ветки в другую. Из ветки master хотим скопировать в ветку staging => перемещаемся на ветку staging и выполняем команду выше и в итоге у нас появляется коммит который повторяет все изменения коммита из master, 
  но это будет совершенно новый коммит который относится к ветке staging. 
  Когда применять?
    1. Исправление бага в релизе (на продакшене вдруг нашли критический баг, внутри своей ветки  делаю исправление, а потом cherry-pick в master)
    2. Командная разработка (бэк команда сделала у себя в ветке мок API и я хочу взять этот мок и протестировать свою фронтовую часть, я делаю cherry-pick этого коммита в свою ветку)
    3. Восстановление или сохранение коммитов (забросили разработку какой то ветки, но хотим взять из нее некоторые коммиты)(либо pull request не приняли, но хотим взять из него некоторые коммиты)

git commit --amend (изменения  которые  мы сделали склеиваются с предыдущим коммитом)
git commit --fixup commitHash (как и amend, но можем указать коммит, в который вольем изменения. Создаст пометку !fixup) //todo: проверить
git log ---oneline --graph --all --decorate --color (выводит историю коммитов в виде графа)

Забыл добавить файл в последний коммит. Либо изменить сообщение коммита.
  Предварительно добавить git add этот файл => git commit --amend и через vim редактировать сообщение коммита. Git заменяет последний коммит на новый. Всегда будет меняться хеш коммита.
Как сбросить все изменения на stage?
  git checkout -- . (точка в конце обозначает все файлы либо можно указать конкретный файл)


*/