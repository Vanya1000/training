/* 
Сравнение объектов
  В JavaScript объекты имеют ссылочный тип. Два отдельных объекта никогда не будут равными, даже если они имеют равный набор свойств. Только сравнение двух ссылок на один и тот же объект вернёт true.
Преобразование типов:
  Строковое: Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
        Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
          undefiend => NaN
          null => 0
          true/false => 1/0
          string => Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
        Логическое: Происходит в математических операциях. Может быть вызвано с помощью Boolean(value).
          0, null, undefined, NaN, "" => false
          любое другое значение => true
        Автоматическое: математические операторы преобразуют знач к числам, кроме + если одно из слагаемых строка, то и все остальные приводятся к строкам ‘1’ + 2 // '12’
      ?Преобразование объектов в примитивы:
        JavaScript совершенно не позволяет настраивать, как операторы работают с объектами. В отличие от некоторых других языков программирования, таких как Ruby или C++, мы не можем реализовать специальный объектный метод для обработки сложения (или других операторов).
        В случае таких операций, объекты автоматически преобразуются в примитивы, затем выполняется сама операция над этими примитивами, и на выходе мы получим примитивное значение.
        Это важное ограничение: результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!
      Правила преобразования:
        1. Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
        2. Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
        3. Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
        Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы.
      Хинты:
        Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:
          - "string" Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:
            _вывод alert(obj);
            _используем объект в качестве ключа anotherObj[obj] = 123;
          - "number" Для преобразования объекта к числу, в случае математических операций:
            _явное преобразование let num = Number(obj);
            _математические (не считая бинарного плюса) let n = +obj; // унарный плюс let delta = date1 - date2;
            _сравнения больше/меньше let greater = user1 > user2;
            Большинство встроенных математических функций также включают в себя такое преобразование.
          - "default" Происходит редко, когда оператор «не уверен», какой тип ожидать. Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). 
            Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
            Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".
            _бинарный плюс использует хинт "default" let total = obj1 + obj2;
            _obj == number использует хинт "default" if (user == 1) { ... };
            _Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".
        !Впрочем на практике, всё немного проще.
          Все встроенные объекты, за исключением одного (объект Date), реализуют "default" преобразование тем же способом, что и "number". И нам следует поступать так же.
          Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
            1. Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
            2. Иначе, если хинт равен "string" попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
            3. Иначе, если хинт равен "number" или "default" попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.
        Symbol.toPrimitive - Давайте начнём с первого метода. Есть встроенный символ с именем Symbol.toPrimitive, который следует использовать для обозначения метода преобразования, вот так:
          */
        let user = {
          name: "John",
          money: 1000,
          [Symbol.toPrimitive](hint) { // принимает hint
            alert(`hint: ${hint}`);
            return hint == "string" ? `{name: "${this.name}"}` : this.money;
          }
        };
        alert(user); // hint: string -> {name: "John"}
        alert(+user); // hint: number -> 1000
        alert(user + 500); // hint: default -> 1500
        /*
        Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
        Как мы можем видеть из кода, user становится либо строкой со своим описанием, либо суммой денег в зависимости от преобразования. Единый метод user[Symbol.toPrimitive] обрабатывает все случаи преобразования.
      toString/valueOf - Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:
        -Для хинта "string": вызвать метод toString, а если он не существует, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).
        -Для других хинтов: valueOf, а если он не существует, то toString (таким образом, valueOf имеет приоритет для математических операций).
        Они предоставляют альтернативный «старомодный» способ реализации преобразования.
        Эти методы должны возвращать примитивное значение. Если toString или valueOf возвращает объект, то он игнорируется (так же, как если бы метода не было).
        По умолчанию обычный объект имеет следующие методы toString и valueOf:
          -Метод toString возвращает строку "[object Object]". let user = {name: "John"}; => alert(user); // [object Object]
          -Метод valueOf возвращает сам объект. let user = {name: "John"}; => alert(user.valueOf() === user); // true
        */
          let user2 = {
            name: "John",
            money: 1000,
              // для хинта равного "string"
            toString() {
              return `{name: "${this.name}"}`;
            },
          
            // для хинта равного "number" или "default"
            valueOf() {
              return this.money;
            }
          
          };
          alert(user); // hint: string -> {name: "John"}
          alert(+user); // hint: number -> 1000
          alert(user + 500); // hint: default -> 1500
          /*
          Как видим, получилось то же поведение, что и в предыдущем примере с Symbol.toPrimitive.
      Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. В этом случае мы можем реализовать только toString:
          */
        let user3 = {
          name: "John",
          money: 1000,
          toString() {
            return this.name;
          }
        };
        alert(user); // toString -> John
        alert(user + 500); // toString -> John500
        /*
        В отсутствие Symbol.toPrimitive и valueOf, toString обработает все примитивные преобразования.
          Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.
          Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возращал именно число для хинта "number".
          Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.
      Дальнейшие преобразования
        Если мы передаём объект в качестве аргумента, то в вычислениях будут две стадии:
          -Объект преобразуется в примитив (с использованием правил, описанных выше).
          -Если необходимо для дальнейших вычислений, этот примитив преобразуется дальше.
Генераторы
    Обычные функции возвращают только одно-единственное значение (или ничего). Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.
    Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.
    Основным методом генератора является next(). При вызове он запускает выполнение кода до ближайшей инструкции yield <значение> (значение может отсутствовать, в этом случае оно предполагается равным undefined). 
    По достижении yield выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код:
    */
    function* generateSequence() {
      yield 1;
      yield 2;
      return 3;
    }

    let generator = generateSequence();

    let one = generator.next();

    alert(JSON.stringify(one)); // {value: 1, done: false} Результатом метода next() всегда является объект с двумя свойствами
    /*
    Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield
    Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true}.
    function* f(…) или function *f(…)? Нет разницы, оба синтаксиса корректны.
  Перебор генераторов
    генераторы являются перебираемыми объектами. Возвращаемые ими значения можно перебирать через for..of:
    …Но обратите внимание: пример выше выводит значение 1, затем 2. Значение 3 выведено не будет!
  Мы можем использовать функцию-генератор для итерации, указав её в Symbol.iterator.
    Вот тот же range, но с гораздо более компактным итератором:
    */
    let range = {
      from: 1,
      to: 5,
    
      *[Symbol.iterator]() { // краткая запись для [Symbol.iterator]: function*()
        for(let value = this.from; value <= this.to; value++) {
          yield value;
        }
      }
    };
    
    alert( [...range] ); // 1,2,3,4,5
    /*
    Это работает, потому что range[Symbol.iterator]() теперь возвращает генератор, и его методы – в точности то, что ожидает for..of:
      -у него есть метод .next()
      -который возвращает значения в виде {value: ..., done: true/false}
    Это не совпадение, конечно. Генераторы были добавлены в язык JavaScript, в частности, с целью упростить создание перебираемых объектов.
instanceof
  Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.
  Синтаксис: obj instanceof Class (Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.)
  */class Rabbit {}
  let rabbit = new Rabbit();
  
  // это объект класса Rabbit?
  alert( rabbit instanceof Rabbit ); // true

  alert( arr instanceof Array ); // true
  /*
AbortController
  Интерфейс AbortController представляет объект контроллера, который позволяет вам при необходимости обрывать один и более DOM запросов.
  Вы можете создать новый объект AbortController используя конструктор AbortController.AbortController(). Взаимодействие с DOM запросами сделано с использованием объекта AbortSignal.
  Конструктор
    AbortController.AbortController() - Создаёт новый экземпляр AbortController.
  Свойства
    AbortController.signal Только для чтения - Возвращает экземпляр AbortSignal, который может быть использован для коммуникаций/останова DOM запросов.
  Методы
    AbortController.abort() - Прерывает DOM запрос до момента его завершения. Это даёт возможность обрывать fetch запросы, потребителей любых ответов с Body и потоки.
    */
    var controller = new AbortController();
    var signal = controller.signal;

    var downloadBtn = document.querySelector('.download');
    var abortBtn = document.querySelector('.abort');

    downloadBtn.addEventListener('click', fetchVideo);

    abortBtn.addEventListener('click', function() {
      controller.abort();
      console.log('Download aborted');
    });

    function fetchVideo() {
      ...
      fetch(url, {signal}).then(function(response) {
        ...
      }).catch(function(e) {
        reports.textContent = 'Download error: ' + e.message;
      })
    }
    /*
cors
  Если браузер отображает страницу с <img>, он должен запросить этот тег из источника. Если браузер запрашивает тег из источника, который отличается от получателя по схеме, в полностью определенному 
      имени хоста или порту, то это и есть запрос между различными источниками (cross-origin request).
    Источник идентифицируется следующей тройкой параметров: схема, полностью определенное имя хоста и порт. Например, <http://example.com> и <https://example.com> имеют разные источники
      первый использует схему http, а второй https. Вдобавок, портом для http по умолчанию является 80, тогда как для https — 443. Следовательно, в данном примере 2 источника отличаются схемой и портом, тогда как хост один и тот же (example.com).
    Таким образом, если хотя бы один из трех элементов у двух ресурсов отличается, то источник ресурсов также считается разным.
  Политика одинакового источника
    Политика одинакового источника предотвращает cross-origin атаки, блокируя доступ для прочтения загружаемых ресурсов из другого источника. Такая политика все еще разрешает нескольким тегам вроде <img> загружать ресурсы из других источников.
    Введена Netscape Navigator 2.02 в 1995 году, изначально для защищенного cross-origin доступа к Объектной модели документа (DOM).
    Политика одинакового источника решает много проблем, но она довольно ограничительная. В век одностраничных приложений и сайтов, нагруженных медиа-контентом, эта политика не дает ни воздуха разработчикам, ни легко играться настройками.
    CORS же появился с целью смягчения политики одинакового источника и для тонкой настройки доступа между различными источниками.
  











*/